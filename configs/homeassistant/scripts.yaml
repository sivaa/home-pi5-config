# =============================================================================
# HOME ASSISTANT SCRIPTS
# Purpose: Reusable automation actions
# =============================================================================

# -----------------------------------------------------------------------------
# SMART TTS - CO2 ALERT WITH RETRY
# Purpose: TTS on kitchen_display with retry logic, obsolescence check, and fallback cascade
#
# Flow:
#   1. Check if kitchen_display is available
#   2. If available AND CO2 still high: play immediately
#   3. If unavailable: wait up to 5 minutes (event-driven with wait_template)
#   4. If kitchen_display becomes available AND CO2 still high: play on it
#   5. If timeout (5 min) AND CO2 still high:
#      a. Try broken_display + master_bedroom_clock (fallback)
#      b. If all speakers unavailable: send mobile notification
#   6. If CO2 drops below threshold during wait: skip (announcement obsolete)
#
# Usage:
#   service: script.smart_tts_co2_alert
#   data:
#     message: "Your message here"
#     co2_threshold: 1200  # or 1600 for critical
# -----------------------------------------------------------------------------
smart_tts_co2_alert:
  alias: "Smart TTS - CO2 Alert with Retry"
  description: "TTS with primary speaker preference, retry logic, and obsolescence check"
  mode: single
  max_exceeded: silent

  fields:
    message:
      description: "The message to announce"
      example: "CO2 level is high. Please ventilate."
    co2_threshold:
      description: "CO2 threshold for obsolescence check"
      example: 1200
      default: 1200

  sequence:
    # Check if primary speaker is immediately available
    - if:
        # Kitchen Display is available (not unavailable/unknown) AND CO2 still above threshold
        - condition: template
          value_template: >
            {{ states('media_player.kitchen_display') not in ['unavailable', 'unknown']
               and states('sensor.hallway_co2_co2') | int >= co2_threshold | int }}
      then:
        # Play immediately on primary speaker
        - service: tts.google_translate_say
          data:
            entity_id: media_player.kitchen_display
            message: "{{ message }}"
            language: "en"
      else:
        # Primary speaker unavailable - wait for it (up to 5 min) or for obsolescence
        - wait_template: >
            {{ states('media_player.kitchen_display') not in ['unavailable', 'unknown']
               or states('sensor.hallway_co2_co2') | int < co2_threshold | int }}
          timeout: "00:05:00"
          continue_on_timeout: true

        # Check what caused the wait to end
        - choose:
            # Case 1: CO2 dropped below threshold - announcement is obsolete
            - conditions:
                - condition: template
                  value_template: >
                    {{ states('sensor.hallway_co2_co2') | int < co2_threshold | int }}
              sequence:
                - stop: "CO2 dropped below threshold - announcement obsolete"

            # Case 2: Primary speaker became available AND CO2 still high
            - conditions:
                - condition: template
                  value_template: >
                    {{ states('media_player.kitchen_display') not in ['unavailable', 'unknown']
                       and states('sensor.hallway_co2_co2') | int >= co2_threshold | int }}
              sequence:
                # Play on primary speaker (Kitchen Display)
                - service: tts.google_translate_say
                  data:
                    entity_id: media_player.kitchen_display
                    message: "{{ message }}"
                    language: "en"

          # Default: Timeout reached (5 min) - kitchen_display still unavailable, try fallback speakers
          default:
            - if:
                - condition: template
                  value_template: >
                    {{ states('sensor.hallway_co2_co2') | int >= co2_threshold | int }}
              then:
                # Check fallback speaker availability
                - variables:
                    broken_ok: "{{ states('media_player.broken_display') not in ['unavailable', 'unknown'] }}"
                    bedroom_ok: "{{ states('media_player.master_bedroom_clock') not in ['unavailable', 'unknown'] }}"

                - choose:
                    # Try fallback speakers (broken_display and/or bedroom_clock)
                    - conditions: "{{ broken_ok or bedroom_ok }}"
                      sequence:
                        - service: tts.google_translate_say
                          data:
                            entity_id: >
                              {% set speakers = [] %}
                              {% if broken_ok %}{% set speakers = speakers + ['media_player.broken_display'] %}{% endif %}
                              {% if bedroom_ok %}{% set speakers = speakers + ['media_player.master_bedroom_clock'] %}{% endif %}
                              {{ speakers }}
                            message: "{{ message }}"
                            language: "en"

                  # All speakers unavailable - send mobile notification
                  default:
                    - service: notify.all_phones
                      data:
                        title: "ðŸ”‡ TTS Failed - All Speakers Offline"
                        message: >
                          CO2 is {{ states('sensor.hallway_co2_co2') }} ppm. {{ message }}
                        data:
                          channel: "Critical"
                          importance: max
                          tag: "tts_failed"

# -----------------------------------------------------------------------------
# SMART TTS - WINDOW ALERT WITH RETRY
# Purpose: TTS on kitchen_display with retry logic, obsolescence check, and fallback cascade
#
# Flow:
#   1. Check if kitchen_display is available
#   2. If available AND window still open: play immediately
#   3. If unavailable: wait up to 5 minutes (event-driven with wait_template)
#   4. If kitchen_display becomes available AND window still open: play on it
#   5. If timeout (5 min) AND window still open:
#      a. Try broken_display + master_bedroom_clock (fallback)
#      b. If all speakers unavailable: send mobile notification
#   6. If window closes during wait: skip (announcement obsolete)
#
# Usage:
#   service: script.smart_tts_window_alert
#   data:
#     message: "Your message here"
#     window_entity: binary_sensor.bath_window_contact_sensor_contact
# -----------------------------------------------------------------------------
smart_tts_window_alert:
  alias: "Smart TTS - Window Alert with Retry"
  description: "TTS on kitchen_display with retry logic and obsolescence check for window alerts"
  mode: parallel
  max: 4

  fields:
    message:
      description: "The message to announce"
      example: "Bathroom window has been open for 10 minutes."
    window_entity:
      description: "Window sensor entity to check if still open"
      example: "binary_sensor.bath_window_contact_sensor_contact"

  sequence:
    # Check if primary speaker is immediately available
    - if:
        # Kitchen Display is available (not unavailable/unknown) AND window still open
        - condition: template
          value_template: >
            {{ states('media_player.kitchen_display') not in ['unavailable', 'unknown']
               and is_state(window_entity, 'on') }}
      then:
        # Play immediately on primary speaker
        - service: tts.google_translate_say
          data:
            entity_id: media_player.kitchen_display
            message: "{{ message }}"
            language: "en"
      else:
        # Primary speaker unavailable - wait for it (up to 5 min) or for window to close
        - wait_template: >
            {{ states('media_player.kitchen_display') not in ['unavailable', 'unknown']
               or is_state(window_entity, 'off') }}
          timeout: "00:05:00"
          continue_on_timeout: true

        # Check what caused the wait to end
        - choose:
            # Case 1: Window closed - announcement is obsolete
            - conditions:
                - condition: template
                  value_template: "{{ is_state(window_entity, 'off') }}"
              sequence:
                - stop: "Window closed - announcement obsolete"

            # Case 2: Primary speaker became available AND window still open
            - conditions:
                - condition: template
                  value_template: >
                    {{ states('media_player.kitchen_display') not in ['unavailable', 'unknown']
                       and is_state(window_entity, 'on') }}
              sequence:
                # Play on primary speaker (Kitchen Display)
                - service: tts.google_translate_say
                  data:
                    entity_id: media_player.kitchen_display
                    message: "{{ message }}"
                    language: "en"

          # Default: Timeout reached (5 min) - kitchen_display still unavailable, try fallback speakers
          default:
            - if:
                - condition: template
                  value_template: "{{ is_state(window_entity, 'on') }}"
              then:
                # Check fallback speaker availability
                - variables:
                    broken_ok: "{{ states('media_player.broken_display') not in ['unavailable', 'unknown'] }}"
                    bedroom_ok: "{{ states('media_player.master_bedroom_clock') not in ['unavailable', 'unknown'] }}"

                - choose:
                    # Try fallback speakers (broken_display and/or bedroom_clock)
                    - conditions: "{{ broken_ok or bedroom_ok }}"
                      sequence:
                        - service: tts.google_translate_say
                          data:
                            entity_id: >
                              {% set speakers = [] %}
                              {% if broken_ok %}{% set speakers = speakers + ['media_player.broken_display'] %}{% endif %}
                              {% if bedroom_ok %}{% set speakers = speakers + ['media_player.master_bedroom_clock'] %}{% endif %}
                              {{ speakers }}
                            message: "{{ message }}"
                            language: "en"

                  # All speakers unavailable - send mobile notification
                  default:
                    - service: notify.all_phones
                      data:
                        title: "ðŸ”‡ TTS Failed - All Speakers Offline"
                        message: "{{ message }}"
                        data:
                          channel: "Critical"
                          importance: max
                          tag: "tts_failed"

# -----------------------------------------------------------------------------
# SMART TTS - GENERIC ANNOUNCEMENT
# Purpose: TTS with speaker fallback cascade and mobile notification backup
#
# Use this for one-time announcements that don't need obsolescence checks.
# For repeated alerts (CO2, window), use the specialized smart_tts scripts.
#
# Flow:
#   1. kitchen_display (primary)
#   2. broken_display + master_bedroom_clock (fallback)
#   3. phone notification (final fallback)
#
# Usage:
#   service: script.smart_tts_announce
#   data:
#     message: "Your message here"
#     title: "Optional title for mobile fallback"  # defaults to "ðŸ“¢ Announcement"
# -----------------------------------------------------------------------------
smart_tts_announce:
  alias: "Smart TTS - Generic Announcement"
  description: "TTS with fallback cascade: kitchen â†’ broken+bedroom â†’ phones"
  mode: parallel
  max: 10

  fields:
    message:
      description: "The message to announce"
      example: "Mailbox opened"
      required: true
    title:
      description: "Title for mobile fallback notification"
      example: "ðŸ“¬ Mailbox"
      default: "ðŸ“¢ Announcement"

  sequence:
    # Calculate speaker availability once
    - variables:
        kitchen_ok: "{{ states('media_player.kitchen_display') not in ['unavailable', 'unknown'] }}"
        broken_ok: "{{ states('media_player.broken_display') not in ['unavailable', 'unknown'] }}"
        bedroom_ok: "{{ states('media_player.master_bedroom_clock') not in ['unavailable', 'unknown'] }}"

    - choose:
        # Priority 1: Kitchen Display (primary)
        - conditions: "{{ kitchen_ok }}"
          sequence:
            - service: tts.google_translate_say
              data:
                entity_id: media_player.kitchen_display
                message: "{{ message }}"
                language: "en"

        # Priority 2: Fallback speakers (broken_display and/or bedroom_clock)
        - conditions: "{{ broken_ok or bedroom_ok }}"
          sequence:
            - service: tts.google_translate_say
              data:
                entity_id: >
                  {% set speakers = [] %}
                  {% if broken_ok %}{% set speakers = speakers + ['media_player.broken_display'] %}{% endif %}
                  {% if bedroom_ok %}{% set speakers = speakers + ['media_player.master_bedroom_clock'] %}{% endif %}
                  {{ speakers }}
                message: "{{ message }}"
                language: "en"

      # Priority 3: Phone notification (final fallback - all speakers offline)
      default:
        - service: notify.all_phones
          data:
            title: "ðŸ”‡ {{ title }}"
            message: "{{ message }} (All speakers offline)"
            data:
              channel: "Alerts"
              importance: high
              tag: "tts_fallback"

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE OVERRIDE - START
# Purpose: Disable 17Â°C cap for 90 minutes (called from dashboard)
#
# Flow:
#   1. Set expiry datetime (now + 90 minutes)
#   2. Turn off night mode enforcement (input_boolean)
#   3. Publish state to MQTT for dashboard
#   4. Send notification
#
# Usage:
#   service: script.bedroom_night_override_start
# -----------------------------------------------------------------------------
bedroom_night_override_start:
  alias: "Bedroom Night Override - Start"
  description: "Disable 17Â°C cap for 90 minutes (called from dashboard)"
  mode: single

  sequence:
    # Calculate expiry time
    - variables:
        expiry_time: "{{ (now() + timedelta(minutes=90)).strftime('%Y-%m-%d %H:%M:%S') }}"

    # Set expiry datetime
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.bedroom_night_override_end
      data:
        datetime: "{{ expiry_time }}"

    # Turn off night mode enforcement
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Publish state to MQTT for dashboard (retained so new connections get state)
    - service: mqtt.publish
      data:
        topic: "dashboard/bedroom-night-mode"
        retain: true
        payload: >
          {"active": false, "override_active": true, "override_expires": "{{ expiry_time }}"}

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸŒ™ Night Mode Override"
        message: "17Â°C cap disabled for 90 minutes (until {{ expiry_time[11:16] }})"
        data:
          channel: "Info"
          importance: default
          tag: "bedroom_night_override"

# -----------------------------------------------------------------------------
# THERMOSTAT BOOST - START (22Â°C for 60 minutes)
# Purpose: Temporarily boost thermostat to 22Â°C for 60 minutes (called from dashboard)
#
# Flow:
#   1. Map thermostat_id to climate entity and input helpers
#   2. Save current setpoint to input_number
#   3. Set thermostat to 22Â°C
#   4. Set expiry datetime (now + 60 minutes)
#   5. Publish state to MQTT for dashboard
#
# Usage:
#   service: script.thermostat_boost_start
#   data:
#     thermostat_id: study  # or living_inner, living_outer, bedroom
# -----------------------------------------------------------------------------
thermostat_boost_start:
  alias: "Thermostat Boost - Start"
  description: "Boost thermostat to 22Â°C for 60 minutes (called from dashboard)"
  mode: parallel
  max: 4

  fields:
    thermostat_id:
      description: "The thermostat to boost (study, living_inner, living_outer, bedroom)"
      example: "study"

  variables:
    # Map thermostat_id to climate entity
    climate_entity: >
      {% set mapping = {
        'study': 'climate.study_thermostat',
        'living_inner': 'climate.living_thermostat_inner',
        'living_outer': 'climate.living_thermostat_outer',
        'bedroom': 'climate.bed_thermostat'
      } %}
      {{ mapping.get(thermostat_id, '') }}
    # Map thermostat_id to input helpers
    input_setpoint: "input_number.{{ thermostat_id }}_pre_boost_setpoint"
    input_expiry: "input_datetime.{{ thermostat_id }}_boost_end"
    # Current setpoint (default 17 if unavailable)
    current_setpoint: >
      {{ state_attr(climate_entity, 'temperature') | float(17) }}
    # Expiry time (60 minutes from now)
    expiry_time: "{{ (now() + timedelta(minutes=60)).strftime('%Y-%m-%d %H:%M:%S') }}"

  sequence:
    # Validate thermostat_id
    - if:
        - condition: template
          value_template: "{{ climate_entity == '' }}"
      then:
        - stop: "Invalid thermostat_id provided"

    # Save current setpoint
    - service: input_number.set_value
      target:
        entity_id: "{{ input_setpoint }}"
      data:
        value: "{{ current_setpoint }}"

    # Set expiry datetime
    - service: input_datetime.set_datetime
      target:
        entity_id: "{{ input_expiry }}"
      data:
        datetime: "{{ expiry_time }}"

    # Set thermostat to 22Â°C
    - service: climate.set_temperature
      target:
        entity_id: "{{ climate_entity }}"
      data:
        temperature: 22

    # Publish state to MQTT for dashboard (retained so new connections get state)
    - service: mqtt.publish
      data:
        topic: "dashboard/thermostat-boost/{{ thermostat_id }}"
        retain: true
        payload: >
          {"active": true, "target_temp": 22, "original_temp": {{ current_setpoint }}, "expires_at": "{{ expiry_time }}"}

    # Notification (low priority, just informational)
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Boost Active"
        message: "{{ thermostat_id | replace('_', ' ') | title }} boosted to 22Â°C for 60 min"
        data:
          channel: "Info"
          importance: low
          tag: "thermostat_boost_{{ thermostat_id }}"

# -----------------------------------------------------------------------------
# THERMOSTAT BOOST - CANCEL
# Purpose: Cancel active boost and restore original temperature
#
# Usage:
#   service: script.thermostat_boost_cancel
#   data:
#     thermostat_id: study
# -----------------------------------------------------------------------------
thermostat_boost_cancel:
  alias: "Thermostat Boost - Cancel"
  description: "Cancel active boost and restore original temperature"
  mode: parallel
  max: 4

  fields:
    thermostat_id:
      description: "The thermostat to cancel boost (study, living_inner, living_outer, bedroom)"
      example: "study"

  variables:
    climate_entity: >
      {% set mapping = {
        'study': 'climate.study_thermostat',
        'living_inner': 'climate.living_thermostat_inner',
        'living_outer': 'climate.living_thermostat_outer',
        'bedroom': 'climate.bed_thermostat'
      } %}
      {{ mapping.get(thermostat_id, '') }}
    input_setpoint: "input_number.{{ thermostat_id }}_pre_boost_setpoint"
    input_expiry: "input_datetime.{{ thermostat_id }}_boost_end"
    saved_setpoint: "{{ states(input_setpoint) | float(17) }}"

  sequence:
    # Validate thermostat_id
    - if:
        - condition: template
          value_template: "{{ climate_entity == '' }}"
      then:
        - stop: "Invalid thermostat_id provided"

    # Restore saved setpoint
    - service: climate.set_temperature
      target:
        entity_id: "{{ climate_entity }}"
      data:
        temperature: "{{ saved_setpoint }}"

    # Clear expiry datetime (reset to epoch)
    - service: input_datetime.set_datetime
      target:
        entity_id: "{{ input_expiry }}"
      data:
        datetime: "1970-01-01 00:00:00"

    # Publish state to MQTT
    - service: mqtt.publish
      data:
        topic: "dashboard/thermostat-boost/{{ thermostat_id }}"
        retain: true
        payload: '{"active": false}'

    # Notification
    - service: notify.all_phones
      data:
        title: "â„ï¸ Boost Cancelled"
        message: "{{ thermostat_id | replace('_', ' ') | title }} restored to {{ saved_setpoint }}Â°C"
        data:
          channel: "Info"
          importance: low
          tag: "thermostat_boost_{{ thermostat_id }}"

# -----------------------------------------------------------------------------
# GLOBAL BOOST MODE - Enable 25Â°C limit for 60 minutes
# Purpose: Allows user to set thermostats up to 25Â°C (normally capped at 22Â°C)
#
# Behavior:
# - Saves current thermostat temps to input_numbers (for restoration on cancel)
# - Enables 25Â°C limit for 60 minutes
# - Does NOT change thermostat temps automatically - just unlocks higher limit
# -----------------------------------------------------------------------------
global_boost_mode_start:
  alias: "Global Boost Mode - Enable 25Â°C limit"
  description: "Enable 25Â°C max temp limit for all thermostats for 60 minutes"
  mode: single

  variables:
    expiry_time: "{{ (now() + timedelta(minutes=60)).strftime('%Y-%m-%d %H:%M:%S') }}"
    study_temp: "{{ state_attr('climate.study_thermostat', 'temperature') | float(18) }}"
    living_inner_temp: "{{ state_attr('climate.living_thermostat_inner', 'temperature') | float(18) }}"
    living_outer_temp: "{{ state_attr('climate.living_thermostat_outer', 'temperature') | float(18) }}"
    bedroom_temp: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(18) }}"

  sequence:
    # 1. Save current temps to input_numbers (for restoration on cancel/expire)
    - service: input_number.set_value
      target:
        entity_id: input_number.global_boost_saved_study
      data:
        value: "{{ study_temp }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.global_boost_saved_living_inner
      data:
        value: "{{ living_inner_temp }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.global_boost_saved_living_outer
      data:
        value: "{{ living_outer_temp }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.global_boost_saved_bedroom
      data:
        value: "{{ bedroom_temp }}"

    # 2. Set expiry datetime
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.global_boost_end
      data:
        datetime: "{{ expiry_time }}"

    # 3. Publish state to MQTT for dashboard (includes saved temps for visibility)
    - service: mqtt.publish
      data:
        topic: "dashboard/global-boost-mode"
        retain: true
        payload: >
          {
            "active": true,
            "expires_at": "{{ expiry_time }}",
            "saved_temps": {
              "study": {{ study_temp }},
              "living_inner": {{ living_inner_temp }},
              "living_outer": {{ living_outer_temp }},
              "bedroom": {{ bedroom_temp }}
            }
          }

    # 4. Notification
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Boost Mode Enabled"
        message: "25Â°C limit unlocked for 60 min. Temps saved: Study={{ study_temp }}Â°C"
        data:
          channel: "Info"
          importance: default
          tag: "global_boost_mode"

global_boost_mode_cancel:
  alias: "Global Boost Mode - Disable and Restore Temps"
  description: "Disable boost mode (25Â°C limit reverts to 22Â°C) and restore saved temps"
  mode: single

  variables:
    study_saved: "{{ states('input_number.global_boost_saved_study') | float(18) }}"
    living_inner_saved: "{{ states('input_number.global_boost_saved_living_inner') | float(18) }}"
    living_outer_saved: "{{ states('input_number.global_boost_saved_living_outer') | float(18) }}"
    bedroom_saved: "{{ states('input_number.global_boost_saved_bedroom') | float(18) }}"
    heaters_paused_window: "{{ is_state('input_boolean.heaters_off_due_to_window', 'on') }}"
    heaters_paused_co2: "{{ is_state('input_boolean.heaters_off_due_to_co2', 'on') }}"
    heaters_paused: "{{ heaters_paused_window or heaters_paused_co2 }}"

  sequence:
    # 1. Restore temps (only if heaters are NOT paused)
    - choose:
        # Case: Heaters are paused - skip temp restoration
        - conditions:
            - condition: template
              value_template: "{{ heaters_paused }}"
          sequence:
            - service: system_log.write
              data:
                message: >-
                  Boost mode ended while heaters paused
                  (window={{ heaters_paused_window }}, co2={{ heaters_paused_co2 }}).
                  Temps NOT restored - will use resume automation values.
                level: warning

      # Default: Heaters running normally - restore temps
      default:
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: "{{ study_saved }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: "{{ living_inner_saved }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: "{{ living_outer_saved }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: "{{ bedroom_saved }}"

    # 2. Clear expiry datetime
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.global_boost_end
      data:
        datetime: "1970-01-01 00:00:00"

    # 3. Publish state to MQTT
    - service: mqtt.publish
      data:
        topic: "dashboard/global-boost-mode"
        retain: true
        payload: '{"active": false}'

    # 4. Notification (different message based on heater state)
    - service: notify.all_phones
      data:
        title: "{% if heaters_paused %}âš ï¸ Boost Ended (Heaters Paused){% else %}â„ï¸ Boost Mode Disabled{% endif %}"
        message: >-
          {% if heaters_paused %}Heaters paused ({% if heaters_paused_window %}window{% endif %}{% if heaters_paused_window and heaters_paused_co2 %}/{% endif %}{% if heaters_paused_co2 %}CO2{% endif %}) - temps will restore when heaters resume.
          {% else %}Temps restored: Study={{ study_saved }}Â°C. Max now 22Â°C.
          {% endif %}
        data:
          channel: "{% if heaters_paused %}Warning{% else %}Info{% endif %}"
          importance: "{% if heaters_paused %}default{% else %}low{% endif %}"
          tag: "global_boost_mode"

# -----------------------------------------------------------------------------
# CO2 OVERRIDE - START (6 hours)
# Purpose: Temporarily override CO2-based heater blocking for 6 hours
#
# Flow:
#   1. Set override flag and expiry (now + 6 hours)
#   2. If CO2 guard is active, restore heaters using saved states
#   3. Clear CO2 guard flag
#   4. Publish state to MQTT for dashboard
#   5. Send notification
#
# Usage:
#   service: script.co2_override_start
# -----------------------------------------------------------------------------
co2_override_start:
  alias: "CO2 Override - Start"
  description: "Override CO2-based heater blocking for 6 hours (called from dashboard)"
  mode: single

  variables:
    expiry_time: "{{ (now() + timedelta(hours=6)).strftime('%Y-%m-%d %H:%M:%S') }}"
    co2_guard_was_active: "{{ is_state('input_boolean.heaters_off_due_to_co2', 'on') }}"
    window_guard_active: "{{ is_state('input_boolean.heaters_off_due_to_window', 'on') }}"
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"
    is_quiet_hours: "{{ now().hour >= 23 or now().hour < 7 }}"

  sequence:
    # 1. Set override flag
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.co2_override_active

    # 2. Set expiry datetime
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.co2_override_end
      data:
        datetime: "{{ expiry_time }}"

    # 3. If CO2 guard was active (and window guard is not), restore heaters
    - if:
        - condition: template
          value_template: "{{ co2_guard_was_active and not window_guard_active }}"
      then:
        # Restore heater modes
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.study_thermostat
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.study_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_inner
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.living_inner_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_outer
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.living_outer_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.bed_thermostat
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.bedroom_heater_was_on', 'on') else 'off' }}"

        # Reset open_window flag on TRVs
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Study] Thermostat/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Bed] Thermostat/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Living] Thermostat Inner/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Living] Thermostat Outer/set"
            payload: '{"open_window": "OFF"}'

        - delay:
            seconds: 3

        # Restore setpoints
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: "{{ states('input_number.study_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: "{{ states('input_number.living_inner_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: "{{ states('input_number.living_outer_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: "{{ states('input_number.bedroom_heater_saved_temp') | float(18) }}"

    # 4. Clear CO2 guard flag (heaters are now allowed despite CO2)
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.heaters_off_due_to_co2

    # 5. Publish state to MQTT for dashboard (retained)
    - service: mqtt.publish
      data:
        topic: "dashboard/co2-override"
        retain: true
        payload: >
          {"active": true, "expires_at": "{{ expiry_time }}", "started_at": "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}", "co2_level": {{ co2_level }}}

    # 6. TTS announcement (respect quiet hours, uses fallback cascade)
    - if:
        - condition: template
          value_template: "{{ not is_quiet_hours }}"
      then:
        - service: script.smart_tts_announce
          data:
            message: "CO2 override enabled for 6 hours. Heaters will run despite high CO2."
            title: "ðŸ”“ CO2 Override"

    # 7. Mobile notification
    - service: notify.all_phones
      data:
        title: "ðŸ”“ CO2 Override Enabled"
        message: "Heaters allowed for 6 hours despite CO2 at {{ co2_level }} ppm. Expires {{ expiry_time[11:16] }}."
        data:
          channel: "Warning"
          importance: default
          tag: "co2_override"

# -----------------------------------------------------------------------------
# CO2 OVERRIDE - CANCEL
# Purpose: Cancel CO2 override and re-enable CO2 protection
#
# Flow:
#   1. Clear override flag
#   2. Re-check CO2 level - if high, turn off heaters (without saving states)
#   3. Clear expiry datetime
#   4. Publish state to MQTT
#   5. Send notification
#
# Usage:
#   service: script.co2_override_cancel
# -----------------------------------------------------------------------------
co2_override_cancel:
  alias: "CO2 Override - Cancel"
  description: "Cancel CO2 override and re-enable CO2 protection"
  mode: single

  variables:
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"
    co2_is_high: "{{ co2_level > 1200 }}"
    window_guard_active: "{{ is_state('input_boolean.heaters_off_due_to_window', 'on') }}"
    is_quiet_hours: "{{ now().hour >= 23 or now().hour < 7 }}"

  sequence:
    # 1. Clear override flag
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.co2_override_active

    # 2. Clear expiry datetime
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.co2_override_end
      data:
        datetime: "1970-01-01 00:00:00"

    # 3. If CO2 is still high and window guard is not active, re-enable CO2 blocking
    - if:
        - condition: template
          value_template: "{{ co2_is_high and not window_guard_active }}"
      then:
        # Set CO2 guard flag (DON'T save states - they're still valid from original trigger)
        - service: input_boolean.turn_on
          target:
            entity_id: input_boolean.heaters_off_due_to_co2

        # Turn off all heaters
        - service: climate.set_hvac_mode
          target:
            entity_id:
              - climate.study_thermostat
              - climate.living_thermostat_inner
              - climate.living_thermostat_outer
              - climate.bed_thermostat
          data:
            hvac_mode: "off"

    # 4. Publish state to MQTT
    - service: mqtt.publish
      data:
        topic: "dashboard/co2-override"
        retain: true
        payload: '{"active": false}'

    # 5. TTS announcement (respect quiet hours, uses fallback cascade)
    - if:
        - condition: template
          value_template: "{{ not is_quiet_hours and co2_is_high }}"
      then:
        - service: script.smart_tts_announce
          data:
            message: "CO2 override cancelled. Heaters paused due to high CO2."
            title: "ðŸ”’ CO2 Override Cancelled"

    # 6. Mobile notification
    - service: notify.all_phones
      data:
        title: "{% if co2_is_high %}ðŸ”’ CO2 Override Cancelled{% else %}âœ… CO2 Override Ended{% endif %}"
        message: >-
          {% if co2_is_high %}CO2 still high ({{ co2_level }} ppm). Heaters paused.
          {% else %}CO2 now {{ co2_level }} ppm. Heaters can run normally.
          {% endif %}
        data:
          channel: "{% if co2_is_high %}Warning{% else %}Info{% endif %}"
          importance: "{% if co2_is_high %}default{% else %}low{% endif %}"
          tag: "co2_override"
