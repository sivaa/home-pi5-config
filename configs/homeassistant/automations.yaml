# =============================================================================
# HOME ASSISTANT AUTOMATIONS
# Purpose: Event-driven actions for smart home
# =============================================================================

# -----------------------------------------------------------------------------
# MAILBOX MOTION ALERT
# Trigger: Motion detected at mailbox (PIR sensor)
# Action: TTS announcement on ALL Google Home devices
# Quiet Hours: 23:00 - 06:00 (no announcements)
# Cooldown: 30 seconds (prevents spam from continuous motion)
# -----------------------------------------------------------------------------
- id: mailbox_motion_alert
  alias: "Mailbox Motion Alert"
  description: "Announces when motion is detected at the mailbox"
  mode: single

  trigger:
    - platform: state
      entity_id: binary_sensor.motion_detector_occupancy
      to: "on"

  condition:
    # Quiet hours: no announcements between 23:00 and 06:00
    - condition: time
      after: "06:00:00"
      before: "23:00:00"
    # 30-second cooldown to prevent spam
    - condition: template
      value_template: >
        {{ (now() - state_attr('automation.mailbox_motion_alert', 'last_triggered')).total_seconds() > 30
           if state_attr('automation.mailbox_motion_alert', 'last_triggered') is not none
           else true }}

  action:
    - service: tts.google_translate_say
      data:
        entity_id:
          - media_player.kitchen_display
          - media_player.broken_display
          - media_player.master_bedroom_clock
        message: "Mailbox opened"
        language: "en"
    - service: notify.all_phones
      data:
        title: "ðŸ“¬ Mailbox"
        message: "Motion detected at mailbox"
        data:
          channel: "Alerts"
          importance: high

# -----------------------------------------------------------------------------
# CO2 LEVEL ALERT
# Trigger: CO2 level rises above 1200 ppm, OR every 30 min while high, OR on HA startup
# Action: TTS announcement to ventilate
# Cooldown: 30 minutes (prevents repeated announcements)
# Quiet Hours: 07:00-23:00 only
# -----------------------------------------------------------------------------
- id: co2_high_alert
  alias: "CO2 High Level Alert"
  description: "Announces when CO2 levels are too high and ventilation is needed"
  mode: single

  trigger:
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200
    # Also trigger on HA startup to catch already-high levels
    - platform: homeassistant
      event: start
    # Periodic check every 30 minutes while CO2 stays high
    - platform: time_pattern
      minutes: "/30"

  condition:
    # Verify CO2 is actually above threshold (needed for startup trigger)
    - condition: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200
    # Only announce during waking hours (7 AM to 11 PM)
    - condition: time
      after: "07:00:00"
      before: "23:00:00"
    # 30-minute cooldown to match periodic trigger
    - condition: template
      value_template: >
        {{ (now() - state_attr('automation.co2_high_level_alert', 'last_triggered')).total_seconds() > 1800
           if state_attr('automation.co2_high_level_alert', 'last_triggered') is not none
           else true }}

  action:
    # Smart TTS with retry logic - waits up to 5 min if Kitchen Display unavailable
    - service: script.smart_tts_co2_alert
      data:
        message: >
          Nithya, the Cruise Owner, please ventilate. The current CO2 level is above {{ (states('sensor.hallway_co2_co2') | int // 100) * 100 }}.
        co2_threshold: 1200
    - service: notify.all_phones
      data:
        title: "âš ï¸ CO2 High"
        message: "CO2 above {{ states('sensor.hallway_co2_co2') }} ppm - please ventilate"
        data:
          channel: "Alerts"
          importance: high

# -----------------------------------------------------------------------------
# CO2 CRITICAL ALERT
# Trigger: Every 10 minutes, checks if CO2 > 1600 ppm
# Action: Urgent TTS announcement + mobile notification
# Quiet Hours: 07:00-23:00 only (same as high alert)
# -----------------------------------------------------------------------------
- id: co2_critical_alert
  alias: "CO2 Critical Level Alert"
  description: "Checks every 10 minutes and announces if CO2 is dangerously high"
  mode: single

  trigger:
    # Check every 10 minutes
    - platform: time_pattern
      minutes: "/10"
    # Also trigger immediately when crossing threshold
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1600

  condition:
    # Only announce if CO2 is above critical level
    - condition: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1600
    # Quiet hours: only announce during waking hours (7 AM to 11 PM)
    - condition: time
      after: "07:00:00"
      before: "23:00:00"

  action:
    # Smart TTS with retry logic - waits up to 5 min if Kitchen Display unavailable
    - service: script.smart_tts_co2_alert
      data:
        message: >
          Warning! CO2 level is critical at {{ states('sensor.hallway_co2_co2') | int }}. Please open windows immediately!
        co2_threshold: 1600
    - service: notify.all_phones
      data:
        title: "ðŸš¨ CO2 CRITICAL"
        message: "CO2 at {{ states('sensor.hallway_co2_co2') }} ppm - OPEN WINDOWS NOW!"
        data:
          channel: "Critical"
          importance: max
          vibrationPattern: "100, 1000, 100, 1000, 100"

# -----------------------------------------------------------------------------
# CO2 GOOD LEVEL NOTIFICATION
# Trigger: CO2 level drops below 500 ppm (good air quality)
# Action: Thank Nithya and announce ventilation complete
# Cooldown: 30 minutes (stable good level)
# -----------------------------------------------------------------------------
- id: co2_good_level
  alias: "CO2 Good Level Notification"
  description: "Announces when air quality is good after ventilation"
  mode: single

  trigger:
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      below: 500

  condition:
    # Only announce during waking hours (7 AM to 11 PM)
    - condition: time
      after: "07:00:00"
      before: "23:00:00"
    # 30-minute cooldown
    - condition: template
      value_template: >
        {{ (now() - state_attr('automation.co2_good_level_notification', 'last_triggered')).total_seconds() > 1800
           if state_attr('automation.co2_good_level_notification', 'last_triggered') is not none
           else true }}
    # Only announce if there was a recent high alert (within last 2 hours)
    - condition: template
      value_template: >
        {% set high_alert = state_attr('automation.co2_high_level_alert', 'last_triggered') %}
        {% set critical_alert = state_attr('automation.co2_critical_level_alert', 'last_triggered') %}
        {% set alerts = [high_alert, critical_alert] | select('ne', none) | list %}
        {{ alerts | length > 0 and (now() - alerts | max).total_seconds() < 7200 }}

  action:
    # Good news announcement - use all speakers for reliability
    - service: tts.google_translate_say
      data:
        entity_id:
          - media_player.kitchen_display
          - media_player.broken_display
          - media_player.master_bedroom_clock
        message: >
          {% set high_alert = state_attr('automation.co2_high_level_alert', 'last_triggered') %}
          {% set critical_alert = state_attr('automation.co2_critical_level_alert', 'last_triggered') %}
          {% set alerts = [high_alert, critical_alert] | select('ne', none) | list %}
          {% set minutes = ((now() - alerts | max).total_seconds() / 60) | round(0) | int %}
          Thanks Nithya! Air quality is good now. Ventilated in {{ minutes }} minutes. You can close the windows.
        language: "en"
    - service: notify.all_phones
      data:
        title: "âœ… Air Quality Good"
        message: "CO2 now {{ states('sensor.hallway_co2_co2') }} ppm - windows can be closed"
        data:
          channel: "Info"
          importance: default

# -----------------------------------------------------------------------------
# WINDOW OPEN TOO LONG (TEMPERATURE-AWARE)
# Trigger: Any window/balcony door open for 5min (freezing) or 10min (normal)
# Condition: Temperature-based (<=0C = freezing = 5min, >0C = 10min)
# Action: TTS + mobile notification, repeat every 1 minute until closed
# Sensors: All 7 windows + balcony door (main door has separate 3-min alert)
# Backup: Cold weather alert (15min, <18C) catches edge cases
# -----------------------------------------------------------------------------
- id: window_open_too_long
  alias: "Window Open Too Long (Temperature-Aware)"
  description: "5min alert if <=0C (freezing), 10min if >0C. Covers all windows + balcony door."
  mode: parallel
  max: 7

  trigger:
    # FREEZING trigger: 5 minutes when temp <= 0C
    - id: "freezing"
      platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
      to: "on"
      for:
        minutes: 5

    # STANDARD trigger: 10 minutes when temp > 0C
    - id: "standard"
      platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
      to: "on"
      for:
        minutes: 10

  condition:
    # Temperature check: freezing trigger needs temp <= 0, standard needs temp > 0
    # Use -999 default so unavailable sensor = assume freezing (safer)
    - condition: template
      value_template: >
        {% set temp = states('sensor.balcony_temperature_humidity_temperature') | float(-999) %}
        {% if trigger.id == 'freezing' %}
          {{ temp <= 0 }}
        {% else %}
          {{ temp > 0 }}
        {% endif %}

  variables:
    window_name: >
      {% set names = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom Window',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom Window',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen Window',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large Window',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small Window',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window',
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}
    is_freezing: "{{ trigger.id == 'freezing' }}"

  action:
    - repeat:
        while:
          - condition: template
            value_template: "{{ is_state(trigger.entity_id, 'on') }}"
        sequence:
          # Use smart TTS script with retry, fallback speakers, and obsolescence check
          - service: script.smart_tts_window_alert
            data:
              message: >
                {% set minutes = ((now() - states[trigger.entity_id].last_changed).total_seconds() / 60) | round(0) | int %}
                {% set temp = states('sensor.balcony_temperature_humidity_temperature') | round(0) | int %}
                {{ window_name }} has been open for {{ minutes }} minutes.
                {% if is_freezing %}It's {{ temp }} degrees outside - freezing!{% endif %}
              window_entity: "{{ trigger.entity_id }}"
          # Mobile notification
          - service: notify.all_phones
            data:
              title: >
                {% if is_freezing %}ðŸ¥¶{% else %}ðŸªŸ{% endif %} {{ window_name }}
              message: >
                {% set minutes = ((now() - states[trigger.entity_id].last_changed).total_seconds() / 60) | round(0) | int %}
                {% set temp = states('sensor.balcony_temperature_humidity_temperature') | round(0) | int %}
                Open for {{ minutes }} min{% if is_freezing %} - {{ temp }}Â° freezing!{% endif %}
              data:
                channel: "{% if is_freezing %}Critical{% else %}Alerts{% endif %}"
                importance: "{% if is_freezing %}max{% else %}high{% endif %}"
                tag: "window_{{ trigger.entity_id | replace('.', '_') }}"
          - delay:
              minutes: 1

# -----------------------------------------------------------------------------
# MAILBOX SENSOR ONLINE ALERT
# Trigger: Sensor becomes available (comes back online)
# Action: TTS announcement on ALL Google Home devices
# Quiet Hours: 23:00 - 06:00 (no announcements)
# -----------------------------------------------------------------------------
- id: mailbox_sensor_online
  alias: "Mailbox Sensor Online"
  description: "Announces when mailbox motion sensor comes back online"
  mode: single

  trigger:
    # Trigger when sensor availability changes to online
    - platform: state
      entity_id: binary_sensor.motion_detector_occupancy
      from: "unavailable"
    - platform: state
      entity_id: binary_sensor.motion_detector_occupancy
      from: "unknown"

  condition:
    # Quiet hours: no announcements between 23:00 and 06:00
    - condition: time
      after: "06:00:00"
      before: "23:00:00"

  action:
    - service: tts.google_translate_say
      data:
        entity_id:
          - media_player.kitchen_display
          - media_player.broken_display
          - media_player.master_bedroom_clock
        message: "Mailbox sensor is now online."
        language: "en"
    - service: notify.all_phones
      data:
        title: "ðŸ“¡ Sensor Online"
        message: "Mailbox motion sensor is back online"
        data:
          channel: "Info"
          importance: default

# =============================================================================
# HEATER NOTIFICATIONS
# Purpose: Notify when heaters start/stop heating
# =============================================================================

# -----------------------------------------------------------------------------
# STUDY HEATER - STARTED
# -----------------------------------------------------------------------------
- id: study_heater_started
  alias: "Study Heater Started"
  description: "Notifies when study heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.study_thermostat
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Study Heater ON"
        message: "Target: {{ state_attr('climate.study_thermostat', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_study"

# -----------------------------------------------------------------------------
# STUDY HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: study_heater_stopped
  alias: "Study Heater Stopped"
  description: "Notifies when study heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.study_thermostat
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Study Heater OFF"
        message: "Current: {{ state_attr('climate.study_thermostat', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_study"

# -----------------------------------------------------------------------------
# LIVING INNER HEATER - STARTED
# -----------------------------------------------------------------------------
- id: living_inner_heater_started
  alias: "Living Inner Heater Started"
  description: "Notifies when living inner heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_inner
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Living Inner Heater ON"
        message: "Target: {{ state_attr('climate.living_thermostat_inner', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_inner"

# -----------------------------------------------------------------------------
# LIVING INNER HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: living_inner_heater_stopped
  alias: "Living Inner Heater Stopped"
  description: "Notifies when living inner heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_inner
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Living Inner Heater OFF"
        message: "Current: {{ state_attr('climate.living_thermostat_inner', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_inner"

# -----------------------------------------------------------------------------
# LIVING OUTER HEATER - STARTED
# -----------------------------------------------------------------------------
- id: living_outer_heater_started
  alias: "Living Outer Heater Started"
  description: "Notifies when living outer heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_outer
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Living Outer Heater ON"
        message: "Target: {{ state_attr('climate.living_thermostat_outer', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_outer"

# -----------------------------------------------------------------------------
# LIVING OUTER HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: living_outer_heater_stopped
  alias: "Living Outer Heater Stopped"
  description: "Notifies when living outer heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_outer
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Living Outer Heater OFF"
        message: "Current: {{ state_attr('climate.living_thermostat_outer', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_outer"

# -----------------------------------------------------------------------------
# BEDROOM HEATER - STARTED
# -----------------------------------------------------------------------------
- id: bed_heater_started
  alias: "Bedroom Heater Started"
  description: "Notifies when bedroom heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.bed_thermostat
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Bedroom Heater ON"
        message: "Target: {{ state_attr('climate.bed_thermostat', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_bedroom"

# -----------------------------------------------------------------------------
# BEDROOM HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: bed_heater_stopped
  alias: "Bedroom Heater Stopped"
  description: "Notifies when bedroom heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.bed_thermostat
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Bedroom Heater OFF"
        message: "Current: {{ state_attr('climate.bed_thermostat', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_bedroom"

# =============================================================================
# THERMOSTAT AUDIT LOGGING
# Purpose: Track ALL setpoint changes for debugging and accountability
# =============================================================================

# -----------------------------------------------------------------------------
# THERMOSTAT SETPOINT CHANGE AUDIT
# Trigger: ANY change to setpoint temperature on ANY thermostat
# Action: Mobile notification with old/new values and timestamp
# Why: To catch rogue temperature changes from unknown sources
# -----------------------------------------------------------------------------
- id: thermostat_setpoint_changed_audit
  alias: "Thermostat Setpoint Changed (Audit)"
  description: "Sends notification when any thermostat setpoint changes - for audit tracking"
  mode: parallel

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: temperature

  condition:
    # Only trigger if temperature actually changed (not just state refresh)
    - condition: template
      value_template: >
        {{ trigger.from_state.attributes.temperature is defined
           and trigger.to_state.attributes.temperature is defined
           and trigger.from_state.attributes.temperature != trigger.to_state.attributes.temperature }}

  action:
    - service: notify.all_phones
      data:
        title: "ðŸŒ¡ï¸ Setpoint Changed"
        message: >
          {{ trigger.to_state.name }}
          {{ trigger.from_state.attributes.temperature }}Â°C â†’ {{ trigger.to_state.attributes.temperature }}Â°C
          at {{ now().strftime('%H:%M:%S') }}
        data:
          channel: "Audit"
          importance: high
          tag: "setpoint_{{ trigger.entity_id }}"

# =============================================================================
# WINDOW-HEATER SAFETY AUTOMATIONS
# Purpose: Turn off heaters when windows/doors open, resume when all closed
# =============================================================================

# -----------------------------------------------------------------------------
# DOOR OPEN FOR 2 MINUTES - TURN OFF ALL HEATERS
# Trigger: Balcony door or main door open for 2 minutes
# Action: Turn off all heaters, notify user
# Note: If door closes within 2 minutes, this automation does NOT fire
# FIX: Uses guard flag to prevent state overwrite and duplicate notifications
# -----------------------------------------------------------------------------
- id: door_open_turn_off_heaters
  alias: "Door Open 2min - Turn Off All Heaters"
  description: "When balcony door or main door stays open for 2 minutes, turn off all heaters"
  mode: single
  max_exceeded: silent

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "on"
      for:
        minutes: 2

  variables:
    door_name: >
      {% set names = {
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door',
        'binary_sensor.hallway_window_contact_sensor_main_door_contact': 'Main Door'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

    heaters_running: >
      {% set running = [] %}
      {% if state_attr('climate.study_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Study'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_inner', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Inner'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_outer', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Outer'] %}
      {% endif %}
      {% if state_attr('climate.bed_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Bedroom'] %}
      {% endif %}
      {{ running | join(', ') if running else 'None' }}

  condition:
    # Guard flag must be OFF (heaters not already turned off by another window/door)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    # At least one heater must be in 'heat' mode
    - condition: template
      value_template: >
        {{ states('climate.study_thermostat') == 'heat'
           or states('climate.living_thermostat_inner') == 'heat'
           or states('climate.living_thermostat_outer') == 'heat'
           or states('climate.bed_thermostat') == 'heat' }}

  action:
    # Set guard flag FIRST (prevents race conditions and duplicate notifications)
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.heaters_off_due_to_window

    # CO2 HANDOFF: If CO2 flag is ON, transfer ownership (skip state save)
    - if:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"
      then:
        # Clear CO2 flag (door/window takes priority)
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_co2
        # Skip state saving - CO2 already saved it
        # Skip turning off heaters - already off
        # Just notify about priority transfer
        - service: notify.all_phones
          data:
            title: "ðŸšª {{ door_name }} (CO2 Handoff)"
            message: "Door opened while CO2 was high. Door now controls heater resume."
            data:
              channel: "Info"
              tag: "window_heater_safety"
        - service: tts.google_translate_say
          data:
            entity_id:
              - media_player.kitchen_display
              - media_player.broken_display
              - media_player.master_bedroom_clock
            message: "{{ door_name }} open. Door control takes over from CO2."
            language: "en"
        - stop: "Transferred ownership from CO2 to door"

    # SAVE current heater states (now protected by guard)
    - service: "input_boolean.turn_{{ 'on' if states('climate.study_thermostat') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.study_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_inner') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.living_inner_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_outer') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.living_outer_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.bed_thermostat') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.bedroom_heater_was_on

    # SAVE current setpoints BEFORE turning off
    # (TRVZB firmware drops setpoint to frost protection when mode is set to off)
    - service: input_number.set_value
      target:
        entity_id: input_number.study_heater_saved_temp
      data:
        value: "{{ state_attr('climate.study_thermostat', 'temperature') | float(18) }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_inner_heater_saved_temp
      data:
        value: "{{ state_attr('climate.living_thermostat_inner', 'temperature') | float(18) }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_outer_heater_saved_temp
      data:
        value: "{{ state_attr('climate.living_thermostat_outer', 'temperature') | float(18) }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_heater_saved_temp
      data:
        value: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(18) }}"

    # Turn off all heaters
    - service: climate.set_hvac_mode
      target:
        entity_id:
          - climate.study_thermostat
          - climate.living_thermostat_inner
          - climate.living_thermostat_outer
          - climate.bed_thermostat
      data:
        hvac_mode: "off"

    - service: tts.google_translate_say
      data:
        entity_id:
          - media_player.kitchen_display
          - media_player.broken_display
          - media_player.master_bedroom_clock
        message: >-
          {{ door_name }} open 2 minutes.
          {%- if heaters_running != 'None' %} Pausing {{ heaters_running }}.
          {%- else %} No heaters active.
          {%- endif %}
        language: "en"

    - service: notify.all_phones
      data:
        title: "ðŸšª {{ door_name }}"
        message: >-
          Open 2 min.
          {%- if heaters_running != 'None' %} Paused: {{ heaters_running }}
          {%- else %} No heaters active
          {%- endif %}
        data:
          channel: "Critical"
          importance: max
          tag: "window_heater_safety"

# -----------------------------------------------------------------------------
# WINDOW OPEN FOR 30 SECONDS - TURN OFF ALL HEATERS
# Trigger: Any window open for 30 seconds
# Action: Turn off all heaters, notify user
# Note: If window closes within 30 seconds, this automation does NOT fire
# FIX: Uses guard flag to prevent state overwrite and duplicate notifications
# -----------------------------------------------------------------------------
- id: window_open_turn_off_heaters
  alias: "Window Open 30s - Turn Off All Heaters"
  description: "When any window stays open for 30 seconds, turn off all heaters"
  mode: single
  max_exceeded: silent

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
      to: "on"
      for:
        seconds: 30

  variables:
    window_name: >
      {% set names = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom Window',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom Window',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen Window',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large Window',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small Window',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

    heaters_running: >
      {% set running = [] %}
      {% if state_attr('climate.study_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Study'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_inner', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Inner'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_outer', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Outer'] %}
      {% endif %}
      {% if state_attr('climate.bed_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Bedroom'] %}
      {% endif %}
      {{ running | join(', ') if running else 'None' }}

  condition:
    # Guard flag must be OFF (heaters not already turned off by another window/door)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    # At least one heater must be in 'heat' mode
    - condition: template
      value_template: >
        {{ states('climate.study_thermostat') == 'heat'
           or states('climate.living_thermostat_inner') == 'heat'
           or states('climate.living_thermostat_outer') == 'heat'
           or states('climate.bed_thermostat') == 'heat' }}

  action:
    # Set guard flag FIRST (prevents race conditions and duplicate notifications)
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.heaters_off_due_to_window

    # CO2 HANDOFF: If CO2 flag is ON, transfer ownership (skip state save)
    - if:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"
      then:
        # Clear CO2 flag (window takes priority)
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_co2
        # Skip state saving - CO2 already saved it
        # Skip turning off heaters - already off
        # Just notify about priority transfer
        - service: notify.all_phones
          data:
            title: "ðŸªŸ {{ window_name }} (CO2 Handoff)"
            message: "Window opened while CO2 was high. Window now controls heater resume."
            data:
              channel: "Info"
              tag: "window_heater_safety"
        - service: tts.google_translate_say
          data:
            entity_id:
              - media_player.kitchen_display
              - media_player.broken_display
              - media_player.master_bedroom_clock
            message: "{{ window_name }} open. Window control takes over from CO2."
            language: "en"
        - stop: "Transferred ownership from CO2 to window"

    # SAVE current heater states (now protected by guard)
    - service: "input_boolean.turn_{{ 'on' if states('climate.study_thermostat') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.study_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_inner') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.living_inner_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_outer') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.living_outer_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.bed_thermostat') == 'heat' else 'off' }}"
      target:
        entity_id: input_boolean.bedroom_heater_was_on

    # SAVE current setpoints BEFORE turning off
    # (TRVZB firmware drops setpoint to frost protection when mode is set to off)
    - service: input_number.set_value
      target:
        entity_id: input_number.study_heater_saved_temp
      data:
        value: "{{ state_attr('climate.study_thermostat', 'temperature') | float(18) }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_inner_heater_saved_temp
      data:
        value: "{{ state_attr('climate.living_thermostat_inner', 'temperature') | float(18) }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_outer_heater_saved_temp
      data:
        value: "{{ state_attr('climate.living_thermostat_outer', 'temperature') | float(18) }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_heater_saved_temp
      data:
        value: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(18) }}"

    # Turn off all heaters
    - service: climate.set_hvac_mode
      target:
        entity_id:
          - climate.study_thermostat
          - climate.living_thermostat_inner
          - climate.living_thermostat_outer
          - climate.bed_thermostat
      data:
        hvac_mode: "off"

    - service: tts.google_translate_say
      data:
        entity_id:
          - media_player.kitchen_display
          - media_player.broken_display
          - media_player.master_bedroom_clock
        message: >-
          {{ window_name }} open 30 seconds.
          {%- if heaters_running != 'None' %} Pausing {{ heaters_running }}.
          {%- else %} No heaters active.
          {%- endif %}
        language: "en"

    - service: notify.all_phones
      data:
        title: "ðŸªŸ {{ window_name }}"
        message: >-
          Open 30s.
          {%- if heaters_running != 'None' %} Paused: {{ heaters_running }}
          {%- else %} No heaters active
          {%- endif %}
        data:
          channel: "Critical"
          importance: max
          tag: "window_heater_safety"

# -----------------------------------------------------------------------------
# ALL WINDOWS CLOSED - RESUME HEATING
# Trigger: ANY contact sensor closes
# Condition: ALL 8 sensors must be closed AND guard flag is ON
# Action: Restore heaters to saved state, clear guard flag
# FIX: Only runs if heaters were previously turned off by window automation
# -----------------------------------------------------------------------------
- id: all_windows_closed_resume_heaters
  alias: "All Windows Closed - Resume Heaters"
  description: "When all windows and doors are closed, turn heaters back on and notify"
  mode: single

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "off"

  condition:
    # Guard flag must be ON (heaters were turned off by window automation)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "on"
    # ALL windows/doors must be closed
    - condition: state
      entity_id: binary_sensor.bath_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.bed_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.kitchen_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_large_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_small_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_window_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
      state: "off"

  variables:
    heaters_restored: >
      {% set restored = [] %}
      {% if is_state('input_boolean.study_heater_was_on', 'on') %}
        {% set restored = restored + ['Study'] %}
      {% endif %}
      {% if is_state('input_boolean.living_inner_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Inner'] %}
      {% endif %}
      {% if is_state('input_boolean.living_outer_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Outer'] %}
      {% endif %}
      {% if is_state('input_boolean.bedroom_heater_was_on', 'on') %}
        {% set restored = restored + ['Bedroom'] %}
      {% endif %}
      {{ restored | join(', ') if restored else 'None' }}

  action:
    # CO2 HANDOFF: Check if CO2 is still high before restoring
    - if:
        - condition: numeric_state
          entity_id: sensor.hallway_co2_co2
          above: 1100
      then:
        # Transfer ownership to CO2 flag
        - service: input_boolean.turn_on
          target:
            entity_id: input_boolean.heaters_off_due_to_co2
        # Clear window flag
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_window
        # Notify (respect quiet hours)
        - if:
            - condition: template
              value_template: "{{ now().hour < 23 and now().hour >= 7 }}"
          then:
            - service: tts.google_translate_say
              data:
                entity_id:
                  - media_player.kitchen_display
                  - media_player.broken_display
                  - media_player.master_bedroom_clock
                message: "Windows closed, but CO2 is still {{ states('sensor.hallway_co2_co2') | int }}. Heaters staying off."
                language: "en"
        - service: notify.all_phones
          data:
            title: "ðŸªŸ Windows Closed, CO2 Still High"
            message: "CO2: {{ states('sensor.hallway_co2_co2') }} ppm. Heaters will resume when CO2 < 1100."
            data:
              channel: "Info"
              tag: "window_heater_safety"
        - stop: "CO2 still high - transferring to CO2 control"

    # Restore heaters to their saved states
    - service: climate.set_hvac_mode
      target:
        entity_id: climate.study_thermostat
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.study_heater_was_on', 'on') else 'off' }}"

    - service: climate.set_hvac_mode
      target:
        entity_id: climate.living_thermostat_inner
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.living_inner_heater_was_on', 'on') else 'off' }}"

    - service: climate.set_hvac_mode
      target:
        entity_id: climate.living_thermostat_outer
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.living_outer_heater_was_on', 'on') else 'off' }}"

    - service: climate.set_hvac_mode
      target:
        entity_id: climate.bed_thermostat
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.bedroom_heater_was_on', 'on') else 'off' }}"

    # Reset open_window flag on TRVs (TRVZB sets this when mode=off)
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Study] Thermostat/set"
        payload: '{"open_window": "OFF"}'
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Bed] Thermostat/set"
        payload: '{"open_window": "OFF"}'
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Living] Thermostat Inner/set"
        payload: '{"open_window": "OFF"}'
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Living] Thermostat Outer/set"
        payload: '{"open_window": "OFF"}'

    # Delay for TRV to process mode change and open_window reset
    # TRVZB needs time between mode change and setpoint change (verified: 1s may be too short)
    - delay:
        seconds: 3

    # Restore saved setpoints (TRVZB drops setpoint to frost protection when turned off)
    - service: climate.set_temperature
      target:
        entity_id: climate.study_thermostat
      data:
        temperature: "{{ states('input_number.study_heater_saved_temp') | float(18) }}"
    - service: climate.set_temperature
      target:
        entity_id: climate.living_thermostat_inner
      data:
        temperature: "{{ states('input_number.living_inner_heater_saved_temp') | float(18) }}"
    - service: climate.set_temperature
      target:
        entity_id: climate.living_thermostat_outer
      data:
        temperature: "{{ states('input_number.living_outer_heater_saved_temp') | float(18) }}"
    - service: climate.set_temperature
      target:
        entity_id: climate.bed_thermostat
      data:
        temperature: "{{ states('input_number.bedroom_heater_saved_temp') | float(18) }}"

    # Clear the guard flag (ready for next window event)
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.heaters_off_due_to_window

    - delay:
        seconds: 2

    - service: tts.google_translate_say
      data:
        entity_id:
          - media_player.kitchen_display
          - media_player.broken_display
          - media_player.master_bedroom_clock
        message: >-
          Windows closed.
          {%- if heaters_restored != 'None' %} Resuming {{ heaters_restored }}.
          {%- endif %}
        language: "en"

    - service: notify.all_phones
      data:
        title: "âœ… Windows Closed"
        message: >-
          {%- if heaters_restored != 'None' %}Resumed: {{ heaters_restored }}
          {%- else %}No heaters to resume
          {%- endif %}
        data:
          channel: "Info"
          importance: default
          tag: "window_heater_safety"

# -----------------------------------------------------------------------------
# MAIN DOOR OPEN TOO LONG - REPEAT ALERT
# Trigger: Main door open for more than 3 minutes
# Action: Repeat TTS + mobile alert every 5 minutes until closed
# -----------------------------------------------------------------------------
- id: main_door_open_too_long
  alias: "Main Door Open Too Long - Repeat Alert"
  description: "If main door is open more than 3 minutes, alert every 5 minutes until closed"
  mode: single

  trigger:
    - platform: state
      entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "on"
      for:
        minutes: 3

  action:
    - repeat:
        while:
          - condition: state
            entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
            state: "on"
        sequence:
          - service: tts.google_translate_say
            data:
              entity_id:
                - media_player.kitchen_display
                - media_player.broken_display
                - media_player.master_bedroom_clock
              message: >
                Attention! The main door has been open for more than 3 minutes.
                Please close the main door.
              language: "en"

          - service: notify.all_phones
            data:
              title: "ðŸšª Main Door Still Open!"
              message: "The main door has been open for more than 3 minutes. Please close it."
              data:
                channel: "Critical"
                importance: max
                tag: "main_door_open_alert"

          - delay:
              minutes: 5

# -----------------------------------------------------------------------------
# WINDOW OPEN COLD WEATHER ALERT
# Trigger: Any window/door open for 15 minutes when balcony temp < 18Â°C
# Action: TTS announcement on kitchen display every 2 minutes until closed
# Note: Independent of heater safety automations
# -----------------------------------------------------------------------------
- id: window_open_cold_weather_alert
  alias: "Window Open Cold Weather Alert"
  description: "Alert every 2 minutes when window open >15min and outdoor temp <18Â°C"
  mode: parallel
  max: 8

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "on"
      for:
        minutes: 15

  condition:
    - condition: numeric_state
      entity_id: sensor.balcony_temperature_humidity_temperature
      below: 18

  variables:
    window_name: >
      {% set names = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom Window',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom Window',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen Window',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large Window',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small Window',
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window',
        'binary_sensor.hallway_window_contact_sensor_main_door_contact': 'Main Door'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

  action:
    - repeat:
        while:
          - condition: template
            value_template: "{{ is_state(trigger.entity_id, 'on') }}"
          - condition: numeric_state
            entity_id: sensor.balcony_temperature_humidity_temperature
            below: 18
        sequence:
          - service: tts.google_translate_say
            data:
              entity_id: media_player.kitchen_display
              message: >
                Attention! {{ window_name }} has been open for a long time
                and it's {{ states('sensor.balcony_temperature_humidity_temperature') | round(0) }} degrees outside.
                Please close it to keep the apartment warm.
              language: "en"
          - delay:
              minutes: 2

# -----------------------------------------------------------------------------
# PREVENT HEATING IF WINDOW OPEN
# Trigger: Any thermostat enters "heating" state
# Condition: At least one window/door is open
# Action: Turn off that thermostat, warn user
# Note: This prevents heaters from starting while windows are open
# -----------------------------------------------------------------------------
- id: prevent_heating_if_window_open
  alias: "Prevent Heating If Window Open"
  description: "When any heater starts heating, check if windows are open. If yes, turn it off."
  mode: parallel
  max: 4

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: hvac_action
      to: "heating"

  condition:
    - condition: or
      conditions:
        - condition: state
          entity_id: binary_sensor.bath_window_contact_sensor_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.bed_window_contact_sensor_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.kitchen_window_contact_sensor_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.study_window_contact_sensor_large_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.study_window_contact_sensor_small_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.living_window_contact_sensor_window_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
          state: "on"

  variables:
    heater_name: >
      {% set names = {
        'climate.study_thermostat': 'Study',
        'climate.living_thermostat_inner': 'Living Inner',
        'climate.living_thermostat_outer': 'Living Outer',
        'climate.bed_thermostat': 'Bedroom'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

    # Map entity_id to helper IDs for state saving
    heater_id: >
      {% set ids = {
        'climate.study_thermostat': 'study',
        'climate.living_thermostat_inner': 'living_inner',
        'climate.living_thermostat_outer': 'living_outer',
        'climate.bed_thermostat': 'bedroom'
      } %}
      {{ ids.get(trigger.entity_id, 'unknown') }}

    bool_entity: "input_boolean.{{ heater_id }}_heater_was_on"
    number_entity: "input_number.{{ heater_id }}_heater_saved_temp"
    current_setpoint: "{{ state_attr(trigger.entity_id, 'temperature') | float(18) }}"

    open_windows: >
      {% set open = [] %}
      {% if is_state('binary_sensor.bath_window_contact_sensor_contact', 'on') %}
        {% set open = open + ['Bathroom'] %}
      {% endif %}
      {% if is_state('binary_sensor.bed_window_contact_sensor_contact', 'on') %}
        {% set open = open + ['Bedroom'] %}
      {% endif %}
      {% if is_state('binary_sensor.kitchen_window_contact_sensor_contact', 'on') %}
        {% set open = open + ['Kitchen'] %}
      {% endif %}
      {% if is_state('binary_sensor.study_window_contact_sensor_large_contact', 'on') %}
        {% set open = open + ['Study Large'] %}
      {% endif %}
      {% if is_state('binary_sensor.study_window_contact_sensor_small_contact', 'on') %}
        {% set open = open + ['Study Small'] %}
      {% endif %}
      {% if is_state('binary_sensor.living_window_contact_sensor_window_contact', 'on') %}
        {% set open = open + ['Living Window'] %}
      {% endif %}
      {% if is_state('binary_sensor.living_window_contact_sensor_balcony_door_contact', 'on') %}
        {% set open = open + ['Balcony Door'] %}
      {% endif %}
      {% if is_state('binary_sensor.hallway_window_contact_sensor_main_door_contact', 'on') %}
        {% set open = open + ['Main Door'] %}
      {% endif %}
      {{ open | join(', ') }}

  action:
    # -------------------------------------------------------------------------
    # FIX: Save THIS heater's state before turning off
    # NOTE: Do NOT set guard flag here - let window_open timer save ALL heaters
    # This prevents race condition where guard flag blocks window_open from saving
    # -------------------------------------------------------------------------
    - service: input_boolean.turn_on
      target:
        entity_id: "{{ bool_entity }}"

    - service: input_number.set_value
      target:
        entity_id: "{{ number_entity }}"
      data:
        value: "{{ current_setpoint }}"

    # Now turn off this specific heater
    - service: climate.set_hvac_mode
      target:
        entity_id: "{{ trigger.entity_id }}"
      data:
        hvac_mode: "off"

    - service: tts.google_translate_say
      data:
        entity_id:
          - media_player.kitchen_display
          - media_player.broken_display
          - media_player.master_bedroom_clock
        message: "{{ heater_name }} blocked. Close {{ open_windows }}."
        language: "en"

    - service: notify.all_phones
      data:
        title: "ðŸš« {{ heater_name }} Blocked"
        message: "Windows open: {{ open_windows }}"
        data:
          channel: "Critical"
          importance: high
          tag: "heater_blocked_windows"

# =============================================================================
# CO2-BASED HEATER CONTROL
# Purpose: Turn off heaters when CO2 is high (>1200 ppm) to avoid heating
#          air that will soon be vented. Window control takes priority.
# Thresholds: OFF at 1200 ppm, ON at 1100 ppm (100 ppm hysteresis)
# =============================================================================

# -----------------------------------------------------------------------------
# CO2 HIGH - TURN OFF ALL HEATERS
# Trigger: CO2 rises above 1200 ppm OR HA startup with CO2 > 1200
# Action: Save state (if not already saved), turn off heaters
# Priority: Window takes priority - do NOT save if window flag is ON
# -----------------------------------------------------------------------------
- id: co2_high_turn_off_heaters
  alias: "CO2 High - Turn Off All Heaters"
  description: "When CO2 exceeds 1200 ppm, turn off all heaters"
  mode: single
  max_exceeded: silent

  trigger:
    # Normal trigger: CO2 crosses threshold
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200
      id: threshold_crossed
    # Startup trigger: Check state on HA restart
    - platform: homeassistant
      event: start
      id: ha_startup

  condition:
    # For startup trigger, verify CO2 is actually high
    - condition: or
      conditions:
        - condition: trigger
          id: threshold_crossed
        - condition: and
          conditions:
            - condition: trigger
              id: ha_startup
            - condition: numeric_state
              entity_id: sensor.hallway_co2_co2
              above: 1200
    # CO2 flag must be OFF (not already handled)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"
    # At least one heater in 'heat' mode OR window flag is on
    - condition: or
      conditions:
        - condition: template
          value_template: >
            {{ states('climate.study_thermostat') == 'heat'
               or states('climate.living_thermostat_inner') == 'heat'
               or states('climate.living_thermostat_outer') == 'heat'
               or states('climate.bed_thermostat') == 'heat' }}
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_window
          state: "on"

  variables:
    window_owns_state: "{{ is_state('input_boolean.heaters_off_due_to_window', 'on') }}"
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"
    is_quiet_hours: "{{ now().hour >= 23 or now().hour < 7 }}"
    heaters_running: >
      {% set running = [] %}
      {% if state_attr('climate.study_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Study'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_inner', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Inner'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_outer', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Outer'] %}
      {% endif %}
      {% if state_attr('climate.bed_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Bedroom'] %}
      {% endif %}
      {{ running | join(', ') if running else 'None' }}

  action:
    # Set CO2 guard flag FIRST
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.heaters_off_due_to_co2

    # ONLY save state if window automation hasn't already saved it
    - if:
        - condition: template
          value_template: "{{ not window_owns_state }}"
      then:
        # SAVE current heater states
        - service: "input_boolean.turn_{{ 'on' if states('climate.study_thermostat') == 'heat' else 'off' }}"
          target:
            entity_id: input_boolean.study_heater_was_on
        - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_inner') == 'heat' else 'off' }}"
          target:
            entity_id: input_boolean.living_inner_heater_was_on
        - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_outer') == 'heat' else 'off' }}"
          target:
            entity_id: input_boolean.living_outer_heater_was_on
        - service: "input_boolean.turn_{{ 'on' if states('climate.bed_thermostat') == 'heat' else 'off' }}"
          target:
            entity_id: input_boolean.bedroom_heater_was_on

        # SAVE current setpoints
        - service: input_number.set_value
          target:
            entity_id: input_number.study_heater_saved_temp
          data:
            value: "{{ state_attr('climate.study_thermostat', 'temperature') | float(18) }}"
        - service: input_number.set_value
          target:
            entity_id: input_number.living_inner_heater_saved_temp
          data:
            value: "{{ state_attr('climate.living_thermostat_inner', 'temperature') | float(18) }}"
        - service: input_number.set_value
          target:
            entity_id: input_number.living_outer_heater_saved_temp
          data:
            value: "{{ state_attr('climate.living_thermostat_outer', 'temperature') | float(18) }}"
        - service: input_number.set_value
          target:
            entity_id: input_number.bedroom_heater_saved_temp
          data:
            value: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(18) }}"

        # Turn off all heaters
        - service: climate.set_hvac_mode
          target:
            entity_id:
              - climate.study_thermostat
              - climate.living_thermostat_inner
              - climate.living_thermostat_outer
              - climate.bed_thermostat
          data:
            hvac_mode: "off"

    # TTS Announcement (respect quiet hours)
    - if:
        - condition: template
          value_template: "{{ not is_quiet_hours }}"
      then:
        - service: tts.google_translate_say
          data:
            entity_id:
              - media_player.kitchen_display
              - media_player.broken_display
              - media_player.master_bedroom_clock
            message: >-
              CO2 is {{ co2_level }}. Heaters paused.
              {%- if heaters_running != 'None' %} Stopping {{ heaters_running }}.
              {%- endif %}
            language: "en"

    # Mobile notification (always)
    - service: notify.all_phones
      data:
        title: "ðŸŒ«ï¸ CO2 High - Heaters Off"
        message: >-
          CO2: {{ co2_level }} ppm.
          {%- if heaters_running != 'None' %} Paused: {{ heaters_running }}
          {%- else %} No heaters were active
          {%- endif %}
        data:
          channel: "Critical"
          importance: max
          tag: "co2_heater_safety"

# -----------------------------------------------------------------------------
# CO2 LOW - RESUME HEATERS
# Trigger: CO2 drops below 1100 ppm OR sensor unavailable for 30 min
# Condition: CO2 flag is ON AND window flag is OFF
# Safety: Timeout fallback if sensor fails
# -----------------------------------------------------------------------------
- id: co2_low_resume_heaters
  alias: "CO2 Low - Resume Heaters"
  description: "When CO2 drops below 1100 ppm and windows closed, restore heaters"
  mode: single

  trigger:
    # Normal trigger: CO2 drops below threshold
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      below: 1100
      id: threshold_crossed
    # Safety trigger: HA startup check
    - platform: homeassistant
      event: start
      id: ha_startup
    # Fallback: Sensor unavailable for 30 minutes
    - platform: state
      entity_id: sensor.hallway_co2_co2
      to: "unavailable"
      for:
        minutes: 30
      id: sensor_timeout

  condition:
    # CO2 flag must be ON
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "on"
    # Window flag must be OFF (window guard takes precedence)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    # Note: Window closed checks moved to action block to allow handoff to window guard
    # For startup/normal trigger, verify CO2 is actually low
    # For timeout trigger, allow anyway (sensor failed)
    - condition: or
      conditions:
        - condition: trigger
          id: sensor_timeout
        - condition: and
          conditions:
            - condition: or
              conditions:
                - condition: trigger
                  id: threshold_crossed
                - condition: trigger
                  id: ha_startup
            - condition: numeric_state
              entity_id: sensor.hallway_co2_co2
              below: 1100

  variables:
    is_timeout: "{{ trigger.id == 'sensor_timeout' }}"
    is_quiet_hours: "{{ now().hour >= 23 or now().hour < 7 }}"
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) if not is_timeout else 'unavailable' }}"
    heaters_restored: >
      {% set restored = [] %}
      {% if is_state('input_boolean.study_heater_was_on', 'on') %}
        {% set restored = restored + ['Study'] %}
      {% endif %}
      {% if is_state('input_boolean.living_inner_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Inner'] %}
      {% endif %}
      {% if is_state('input_boolean.living_outer_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Outer'] %}
      {% endif %}
      {% if is_state('input_boolean.bedroom_heater_was_on', 'on') %}
        {% set restored = restored + ['Bedroom'] %}
      {% endif %}
      {{ restored | join(', ') if restored else 'None' }}

  action:
    - choose:
        # Case 1: A window is open - transfer ownership to window guard
        # This fixes the bug where CO2 normalizes but dashboard still shows "High CO2"
        - conditions:
            - condition: or
              conditions:
                - condition: state
                  entity_id: binary_sensor.bath_window_contact_sensor_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.bed_window_contact_sensor_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.kitchen_window_contact_sensor_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.study_window_contact_sensor_large_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.study_window_contact_sensor_small_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.living_window_contact_sensor_window_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
                  state: "on"
          sequence:
            # Transfer ownership to window guard
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.heaters_off_due_to_window
            - service: input_boolean.turn_off
              target:
                entity_id: input_boolean.heaters_off_due_to_co2
            # TTS notification (respect quiet hours)
            - if:
                - condition: template
                  value_template: "{{ not is_quiet_hours }}"
              then:
                - service: tts.google_translate_say
                  data:
                    entity_id:
                      - media_player.kitchen_display
                      - media_player.broken_display
                      - media_player.master_bedroom_clock
                    message: "CO2 is now {{ co2_level }}. Air improved, but window still open. Heaters staying off."
                    language: "en"
            # Mobile notification
            - service: notify.all_phones
              data:
                title: "âœ… CO2 Normal (Window Open)"
                message: "CO2: {{ co2_level }} ppm. Window still open - heaters stay off until closed."
                data:
                  channel: "Info"
                  tag: "co2_heater_safety"

      # Default: All windows closed - resume heaters normally
      default:
        # Restore heaters
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.study_thermostat
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.study_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_inner
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.living_inner_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_outer
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.living_outer_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.bed_thermostat
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.bedroom_heater_was_on', 'on') else 'off' }}"

        # Reset open_window flag on TRVs
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Study] Thermostat/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Bed] Thermostat/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Living] Thermostat Inner/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Living] Thermostat Outer/set"
            payload: '{"open_window": "OFF"}'

        - delay:
            seconds: 3

        # Restore setpoints
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: "{{ states('input_number.study_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: "{{ states('input_number.living_inner_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: "{{ states('input_number.living_outer_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: "{{ states('input_number.bedroom_heater_saved_temp') | float(18) }}"

        # Clear CO2 flag
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_co2

        - delay:
            seconds: 2

        # TTS (respect quiet hours)
        - if:
            - condition: template
              value_template: "{{ not is_quiet_hours }}"
          then:
            - service: tts.google_translate_say
              data:
                entity_id:
                  - media_player.kitchen_display
                  - media_player.broken_display
                  - media_player.master_bedroom_clock
                message: >-
                  {% if is_timeout %}CO2 sensor timeout. Resuming heaters as safety fallback.
                  {% else %}CO2 now {{ co2_level }}. Air improved.
                  {%- if heaters_restored != 'None' %} Resuming {{ heaters_restored }}.
                  {%- endif %}
                  {% endif %}
                language: "en"

        # Mobile notification
        - service: notify.all_phones
          data:
            title: "{% if is_timeout %}âš ï¸ CO2 Sensor Timeout{% else %}âœ… CO2 Normal{% endif %}"
            message: >-
              {% if is_timeout %}Sensor unavailable 30min. Resuming heaters.
              {% else %}CO2: {{ co2_level }} ppm.
              {%- if heaters_restored != 'None' %} Resumed: {{ heaters_restored }}
              {%- else %} No heaters to resume
              {%- endif %}
              {% endif %}
            data:
              channel: "{% if is_timeout %}Critical{% else %}Info{% endif %}"
              importance: "{% if is_timeout %}max{% else %}default{% endif %}"
              tag: "co2_heater_safety"

# -----------------------------------------------------------------------------
# PREVENT HEATING IF CO2 HIGH
# Trigger: Any thermostat enters "heating" state
# Condition: CO2 > 1200
# Action: Turn off that specific heater immediately
# Purpose: Catch manual overrides or race conditions
# -----------------------------------------------------------------------------
- id: prevent_heating_if_co2_high
  alias: "Prevent Heating If CO2 High"
  description: "If any heater starts heating while CO2 is high, turn it off immediately"
  mode: parallel
  max: 4

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: hvac_action
      to: "heating"

  condition:
    - condition: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200

  variables:
    heater_name: >
      {% set names = {
        'climate.study_thermostat': 'Study',
        'climate.living_thermostat_inner': 'Living Inner',
        'climate.living_thermostat_outer': 'Living Outer',
        'climate.bed_thermostat': 'Bedroom'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"

  action:
    # Turn off the specific heater
    - service: climate.set_hvac_mode
      target:
        entity_id: "{{ trigger.entity_id }}"
      data:
        hvac_mode: "off"

    - service: notify.all_phones
      data:
        title: "ðŸš« {{ heater_name }} Blocked (CO2)"
        message: "Heater tried to start but CO2 is {{ co2_level }} ppm. Blocked."
        data:
          channel: "Critical"
          importance: max
          tag: "co2_heater_block"

# =============================================================================
# TTS NOTIFICATION AUDIT LOGGING
# Purpose: Publish all TTS notifications to MQTT for dashboard logging
# =============================================================================

# -----------------------------------------------------------------------------
# TTS EVENT MQTT PUBLISHER
# Trigger: Any call to tts.google_translate_say service
# Action: Publish event details to dashboard/tts topic
# Fields: timestamp, message, devices, availability status
# -----------------------------------------------------------------------------
- id: tts_event_mqtt_publisher
  alias: "TTS Event MQTT Publisher"
  description: "Publishes all TTS notifications to MQTT for dashboard logging"
  mode: parallel
  max: 10

  trigger:
    - platform: event
      event_type: call_service
      event_data:
        domain: tts
        service: google_translate_say

  variables:
    devices: >
      {% set data = trigger.event.data.service_data %}
      {% if data.entity_id is string %}
        {{ [data.entity_id] }}
      {% else %}
        {{ data.entity_id | default([]) }}
      {% endif %}
    message: "{{ trigger.event.data.service_data.message | default('No message') }}"

    device_status: >
      {% set status = [] %}
      {% for device in devices %}
        {% set name = device | replace('media_player.', '') %}
        {% set state = states(device) %}
        {% set available = state not in ['unavailable', 'unknown'] %}
        {% set status = status + [{'device': name, 'available': available, 'state': state}] %}
      {% endfor %}
      {{ status }}

    all_available: >
      {{ device_status | selectattr('available', 'eq', true) | list | length == device_status | length }}

    any_available: >
      {{ device_status | selectattr('available', 'eq', true) | list | length > 0 }}

  action:
    - service: mqtt.publish
      data:
        topic: "dashboard/tts"
        payload: >
          {{
            {
              "timestamp": now().isoformat(),
              "event": "tts_call",
              "message": message,
              "devices": device_status,
              "success": any_available,
              "all_available": all_available,
              "automation": trigger.event.context.parent_id | default('manual')
            } | tojson
          }}
        retain: false

# =============================================================================
# HEATER GUARD STATE MQTT PUBLISHER
# Purpose: Publish heater pause state to MQTT for dashboard banner display
# Topic: dashboard/heater-guard/combined (retained)
# =============================================================================

# -----------------------------------------------------------------------------
# HEATER GUARD COMBINED STATE PUBLISHER
# Trigger: Guard flags change OR window sensors change while guard active
# Action: Publish combined state with open windows list and CO2 level
# Note: Retained message so dashboard shows state on page load
# -----------------------------------------------------------------------------
- id: heater_guard_combined_publisher
  alias: "Heater Guard Combined State Publisher"
  description: "Publishes combined heater pause state with window/CO2 context to MQTT"
  mode: single
  max_exceeded: silent

  trigger:
    # Guard flag changes
    - platform: state
      entity_id:
        - input_boolean.heaters_off_due_to_window
        - input_boolean.heaters_off_due_to_co2
      id: guard_change
    # Window state changes (to update open window list in real-time)
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      id: window_change
    # CO2 sensor changes (to update CO2 level in real-time when CO2 guard active)
    - platform: state
      entity_id: sensor.hallway_co2_co2
      id: co2_change

  condition:
    # Only publish if at least one guard is active
    - condition: or
      conditions:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_window
          state: "on"
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"

  variables:
    window_guard: "{{ is_state('input_boolean.heaters_off_due_to_window', 'on') }}"
    co2_guard: "{{ is_state('input_boolean.heaters_off_due_to_co2', 'on') }}"
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"
    open_windows: >
      {% set ns = namespace(open=[]) %}
      {% set windows = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window',
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door',
        'binary_sensor.hallway_window_contact_sensor_main_door_contact': 'Main Door'
      } %}
      {% for entity, name in windows.items() %}
        {% if is_state(entity, 'on') %}
          {% set ns.open = ns.open + [name] %}
        {% endif %}
      {% endfor %}
      {{ ns.open }}

  action:
    - service: mqtt.publish
      data:
        topic: dashboard/heater-guard/combined
        payload: >
          {{
            {
              "active": true,
              "reason": 'window' if window_guard else 'co2',
              "window_guard": window_guard,
              "co2_guard": co2_guard,
              "co2_level": co2_level,
              "open_windows": open_windows,
              "timestamp": now().isoformat(),
              "changed_at": now().timestamp() | int
            } | tojson
          }}
        retain: true

# -----------------------------------------------------------------------------
# HEATER GUARD CLEAR ON RESUME
# Trigger: Either guard flag turns OFF
# Condition: BOTH flags must be OFF
# Action: Publish inactive state to clear the retained message
# -----------------------------------------------------------------------------
- id: heater_guard_clear_on_resume
  alias: "Heater Guard Clear on Resume"
  description: "Publishes inactive heater guard state when all guards are cleared"
  mode: single

  trigger:
    - platform: state
      entity_id:
        - input_boolean.heaters_off_due_to_window
        - input_boolean.heaters_off_due_to_co2
      to: "off"

  condition:
    # Both guards must be off
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"

  action:
    - service: mqtt.publish
      data:
        topic: dashboard/heater-guard/combined
        payload: >
          {{
            {
              "active": false,
              "reason": "none",
              "window_guard": false,
              "co2_guard": false,
              "co2_level": states('sensor.hallway_co2_co2') | int(0),
              "open_windows": [],
              "timestamp": now().isoformat(),
              "changed_at": now().timestamp() | int
            } | tojson
          }}
        retain: true

# -----------------------------------------------------------------------------
# WATCHDOG RECOVERY - PERIODIC RESUME CHECK
# Purpose: Safety net for heater-watchdog - catches cases where the event-driven
#          resume automation misses the window/door close event.
# Trigger: Every minute
# Condition: Guard flag is ON AND all windows/doors are closed
# Action: Trigger the existing resume automation
# -----------------------------------------------------------------------------
- id: watchdog_recovery_resume_check
  alias: "Watchdog Recovery - Periodic Resume Check"
  description: >
    Safety net that runs every minute. If heater guard flag (window OR CO2) is ON
    but all windows/doors are closed and CO2 is acceptable, triggers the appropriate
    resume automation. This catches edge cases where the event-driven resume missed.
  mode: single

  trigger:
    - platform: time_pattern
      minutes: "/1"

  condition:
    # EITHER guard flag must be ON (heaters were intentionally turned off)
    - condition: or
      conditions:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_window
          state: "on"
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"
    # AND all windows/doors must be closed
    - condition: state
      entity_id: binary_sensor.bath_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.bed_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.kitchen_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_large_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_small_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_window_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
      state: "off"

  action:
    # Check which guard is active and call the appropriate resume automation
    - choose:
        # Case 1: Window guard is active â†’ use window resume automation
        - conditions:
            - condition: state
              entity_id: input_boolean.heaters_off_due_to_window
              state: "on"
          sequence:
            - service: system_log.write
              data:
                message: "Watchdog Recovery: Window guard ON but all windows closed - triggering window resume"
                level: info
            - service: automation.trigger
              target:
                entity_id: automation.all_windows_closed_resume_heaters

        # Case 2: CO2 guard is active (and window guard is off) AND CO2 is acceptable
        - conditions:
            - condition: state
              entity_id: input_boolean.heaters_off_due_to_co2
              state: "on"
            - condition: state
              entity_id: input_boolean.heaters_off_due_to_window
              state: "off"
            - condition: numeric_state
              entity_id: sensor.hallway_co2_co2
              below: 1100
          sequence:
            - service: system_log.write
              data:
                message: "Watchdog Recovery: CO2 guard ON but CO2 now {{ states('sensor.hallway_co2_co2') }} ppm (< 1100) - triggering CO2 resume"
                level: info
            - service: automation.trigger
              target:
                entity_id: automation.co2_low_resume_heaters

      # Default: Log that conditions weren't met for resume
      default:
        - service: system_log.write
          data:
            message: >
              Watchdog Recovery: Guard active but resume conditions not met.
              Window guard: {{ states('input_boolean.heaters_off_due_to_window') }},
              CO2 guard: {{ states('input_boolean.heaters_off_due_to_co2') }},
              CO2 level: {{ states('sensor.hallway_co2_co2') }} ppm
            level: debug

# =============================================================================
# HEATER TEMPERATURE SAFETY LIMITS
# Purpose: Prevent excessive heating with hard caps
# Safety Rules:
#   1. ALL heaters: Max 22Â°C at all times
#   2. BEDROOM only: Max 17Â°C during night hours (23:00 - 06:00)
# =============================================================================

# -----------------------------------------------------------------------------
# HEATER SAFETY - 22Â°C MAXIMUM CAP
# Trigger: Any thermostat setpoint set above 22Â°C
# Action: Immediately cap to 22Â°C, send audit notification
# Why: Prevent excessive heating and energy waste
# Note: Runs in parallel to handle multiple heaters simultaneously
# -----------------------------------------------------------------------------
- id: heater_safety_max_22c_cap
  alias: "Heater Safety - 22Â°C Maximum Cap"
  description: "If any thermostat is set above 22Â°C, immediately cap it to 22Â°C"
  mode: parallel
  max: 4

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: temperature

  condition:
    # Only trigger if temperature is above 22Â°C
    - condition: template
      value_template: >
        {{ trigger.to_state.attributes.temperature is defined
           and trigger.to_state.attributes.temperature | float(0) > 22 }}

  variables:
    heater_name: >
      {% set names = {
        'climate.study_thermostat': 'Study',
        'climate.living_thermostat_inner': 'Living Inner',
        'climate.living_thermostat_outer': 'Living Outer',
        'climate.bed_thermostat': 'Bedroom'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}
    attempted_temp: "{{ trigger.to_state.attributes.temperature | float(0) }}"

  action:
    # Cap to 22Â°C
    - service: climate.set_temperature
      target:
        entity_id: "{{ trigger.entity_id }}"
      data:
        temperature: 22

    # Audit notification
    - service: notify.all_phones
      data:
        title: "ðŸš« {{ heater_name }} Capped to 22Â°C"
        message: >
          Attempted: {{ attempted_temp }}Â°C â†’ Capped to 22Â°C
          at {{ now().strftime('%H:%M:%S') }}
        data:
          channel: "Safety"
          importance: high
          tag: "heater_safety_cap"

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - START (23:00)
# Trigger: Time reaches 23:00
# Action: Save current setpoint, cap to 17Â°C if above
# Edge cases:
#   - Bedroom off at 23:00 â†’ Save 17Â°C (safe default), no cap needed
#   - Bedroom already <= 17Â°C â†’ Save current, no cap needed
#   - Window/CO2 guard active â†’ Still save and cap (heater will restore when guard clears)
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_start
  alias: "Bedroom Night Mode - Start (23:00)"
  description: "At 23:00, save bedroom setpoint and cap to 17Â°C"
  mode: single

  trigger:
    - platform: time
      at: "23:00:00"

  condition:
    # Night mode must not already be active (shouldn't happen, but safety check)
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "off"

  variables:
    current_setpoint: >
      {{ state_attr('climate.bed_thermostat', 'temperature') | float(17) }}
    heater_mode: "{{ states('climate.bed_thermostat') }}"
    needs_capping: "{{ current_setpoint > 17 and heater_mode == 'heat' }}"

  action:
    # Set night mode flag FIRST
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Save current setpoint (even if off - saves what it was set to)
    # If heater is off, save 17 as safe default for morning restore
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_pre_night_setpoint
      data:
        value: >
          {% if heater_mode == 'off' %}
            17
          {% else %}
            {{ current_setpoint }}
          {% endif %}

    # Cap to 17Â°C if currently above and heater is on
    - if:
        - condition: template
          value_template: "{{ needs_capping }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 17

        # Notification only when actually capped
        - service: notify.all_phones
          data:
            title: "ðŸŒ™ Bedroom Night Mode"
            message: >
              Capped {{ current_setpoint }}Â°C â†’ 17Â°C for sleep.
              Will restore at 06:00.
            data:
              channel: "Info"
              importance: default
              tag: "bedroom_night_mode"
      else:
        # Silent start if no capping needed
        - service: notify.all_phones
          data:
            title: "ðŸŒ™ Bedroom Night Mode"
            message: >
              {% if heater_mode == 'off' %}
                Bedroom heater is off. Night mode monitoring active.
              {% else %}
                Already at {{ current_setpoint }}Â°C (â‰¤17Â°C). No change needed.
              {% endif %}
            data:
              channel: "Info"
              importance: low
              tag: "bedroom_night_mode"

    # Publish state to MQTT for dashboard (after either branch)
    - service: mqtt.publish
      data:
        topic: "dashboard/bedroom-night-mode"
        retain: true
        payload: '{"active": true, "override_active": false, "override_expires": null}'

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - ENFORCEMENT
# Trigger: Bedroom setpoint changes during night hours (23:00-06:00)
# Condition: Night mode flag is ON AND setpoint > 17Â°C
# Action: Cap back to 17Â°C
# Why: Prevents manual override from bypassing night mode
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_enforcement
  alias: "Bedroom Night Mode - Enforcement"
  description: "During night mode, cap bedroom to 17Â°C if changed to above"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.bed_thermostat
      attribute: temperature

  condition:
    # Night mode must be active
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "on"
    # Heater must be in heat mode
    - condition: state
      entity_id: climate.bed_thermostat
      state: "heat"
    # Setpoint must be above 17Â°C
    - condition: template
      value_template: >
        {{ trigger.to_state.attributes.temperature is defined
           and trigger.to_state.attributes.temperature | float(0) > 17 }}

  variables:
    attempted_temp: "{{ trigger.to_state.attributes.temperature | float(0) }}"

  action:
    # Cap back to 17Â°C
    - service: climate.set_temperature
      target:
        entity_id: climate.bed_thermostat
      data:
        temperature: 17

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸŒ™ Bedroom Night Cap"
        message: >
          Attempted {{ attempted_temp }}Â°C during night mode.
          Capped to 17Â°C (until 06:00).
        data:
          channel: "Safety"
          importance: high
          tag: "bedroom_night_enforcement"

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - END (06:00)
# Trigger: Time reaches 06:00
# Action: Restore saved setpoint from before night mode
# Edge cases:
#   - Heater was off at 23:00 â†’ Restores to 17Â°C (safe default)
#   - Heater is currently off â†’ Restore setpoint anyway (for when turned on)
#   - Window guard active â†’ Still restore (will be overwritten by guard restore if needed)
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_end
  alias: "Bedroom Night Mode - End (06:00)"
  description: "At 06:00, restore bedroom setpoint from before night mode"
  mode: single

  trigger:
    - platform: time
      at: "06:00:00"

  condition:
    # Night mode must be active
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "on"

  variables:
    saved_setpoint: "{{ states('input_number.bedroom_pre_night_setpoint') | float(17) }}"
    heater_mode: "{{ states('climate.bed_thermostat') }}"

  action:
    # Clear night mode flag FIRST
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Restore setpoint (only if heater is in heat mode)
    - if:
        - condition: template
          value_template: "{{ heater_mode == 'heat' }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: "{{ saved_setpoint }}"

    # Notification
    - service: notify.all_phones
      data:
        title: "â˜€ï¸ Bedroom Night Mode Ended"
        message: >
          {% if heater_mode == 'heat' %}
            Restored to {{ saved_setpoint }}Â°C
          {% else %}
            Heater is off. Saved setpoint {{ saved_setpoint }}Â°C ready when turned on.
          {% endif %}
        data:
          channel: "Info"
          importance: default
          tag: "bedroom_night_mode"

    # Publish state to MQTT for dashboard (night mode ended)
    - service: mqtt.publish
      data:
        topic: "dashboard/bedroom-night-mode"
        retain: true
        payload: '{"active": false, "override_active": false, "override_expires": null}'

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - HA STARTUP HANDLER
# Trigger: Home Assistant starts during night hours (23:00-06:00)
# Condition: Night mode flag is OFF (wasn't properly set before restart)
# Action: Activate night mode, cap if needed
# Why: Handles HA restart during night hours
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_startup_check
  alias: "Bedroom Night Mode - HA Startup Check"
  description: "If HA restarts during night hours, ensure night mode is active"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  condition:
    # Must be during night hours (23:00-05:59)
    - condition: time
      after: "23:00:00"
      before: "06:00:00"
    # Night mode must not already be active
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "off"

  variables:
    current_setpoint: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(17) }}"
    heater_mode: "{{ states('climate.bed_thermostat') }}"

  action:
    # Set night mode flag
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Save current setpoint (best effort - may not be pre-night value)
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_pre_night_setpoint
      data:
        value: "{{ current_setpoint if heater_mode == 'heat' else 17 }}"

    # Cap if needed
    - if:
        - condition: template
          value_template: "{{ current_setpoint > 17 and heater_mode == 'heat' }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 17

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸŒ™ Night Mode Activated (Restart)"
        message: >
          HA restarted during night hours. Bedroom night mode activated.
          {% if current_setpoint > 17 and heater_mode == 'heat' %}
            Capped {{ current_setpoint }}Â°C â†’ 17Â°C.
          {% endif %}
        data:
          channel: "Info"
          importance: default
          tag: "bedroom_night_mode"

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - OVERRIDE EXPIRES
# Trigger: Time matches input_datetime.bedroom_night_override_end
# Condition: Override is active (night mode flag is OFF) AND still in night hours
# Action: Re-enable 17Â°C cap, publish to MQTT
# Why: Auto-restore night mode after 90-minute dashboard override
# -----------------------------------------------------------------------------
- id: bedroom_night_override_expires
  alias: "Bedroom Night Override - Expires"
  description: "Re-enable 17Â°C cap when dashboard override timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.bedroom_night_override_end

  condition:
    # Only if override is actually active (night mode is off)
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "off"
    # Only during night hours
    - condition: time
      after: "23:00:00"
      before: "06:00:00"

  action:
    # Re-enable night mode
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Cap bedroom back to 17Â°C if above
    - if:
        - condition: template
          value_template: >
            {{ state_attr('climate.bed_thermostat', 'temperature') | float(0) > 17 }}
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 17

    # Clear expiry datetime (reset to epoch)
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.bedroom_night_override_end
      data:
        datetime: "1970-01-01 00:00:00"

    # Publish state to MQTT for dashboard
    - service: mqtt.publish
      data:
        topic: "dashboard/bedroom-night-mode"
        retain: true
        payload: '{"active": true, "override_active": false, "override_expires": null}'

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸŒ™ Night Mode Restored"
        message: "Override expired. 17Â°C cap re-enabled."
        data:
          channel: "Info"
          importance: default
          tag: "bedroom_night_override"

# -----------------------------------------------------------------------------
# HEATER SAFETY - 22Â°C CAP ON HA STARTUP
# Trigger: Home Assistant starts
# Action: Check all thermostats, cap any above 22Â°C
# Why: Catches thermostats that were set above 22Â°C before automation existed
# -----------------------------------------------------------------------------
- id: heater_safety_22c_startup_check
  alias: "Heater Safety - 22Â°C Cap on HA Startup"
  description: "On HA startup, check all thermostats and cap any above 22Â°C"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  variables:
    study_temp: "{{ state_attr('climate.study_thermostat', 'temperature') | float(0) }}"
    living_inner_temp: "{{ state_attr('climate.living_thermostat_inner', 'temperature') | float(0) }}"
    living_outer_temp: "{{ state_attr('climate.living_thermostat_outer', 'temperature') | float(0) }}"
    bed_temp: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(0) }}"
    any_above_22: "{{ study_temp > 22 or living_inner_temp > 22 or living_outer_temp > 22 or bed_temp > 22 }}"

  condition:
    # Only run if at least one thermostat is above 22Â°C
    - condition: template
      value_template: "{{ any_above_22 }}"

  action:
    # Cap each thermostat if above 22Â°C
    - if:
        - condition: template
          value_template: "{{ study_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: 22

    - if:
        - condition: template
          value_template: "{{ living_inner_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: 22

    - if:
        - condition: template
          value_template: "{{ living_outer_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: 22

    - if:
        - condition: template
          value_template: "{{ bed_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 22

    # Single notification with all capped heaters
    - service: notify.all_phones
      data:
        title: "ðŸš« 22Â°C Cap Enforced (Startup)"
        message: >
          HA startup check capped:
          {%- set capped = [] %}
          {%- if study_temp > 22 %}{% set capped = capped + ['Study ' ~ study_temp|int ~ 'Â°C'] %}{% endif %}
          {%- if living_inner_temp > 22 %}{% set capped = capped + ['Living Inner ' ~ living_inner_temp|int ~ 'Â°C'] %}{% endif %}
          {%- if living_outer_temp > 22 %}{% set capped = capped + ['Living Outer ' ~ living_outer_temp|int ~ 'Â°C'] %}{% endif %}
          {%- if bed_temp > 22 %}{% set capped = capped + ['Bedroom ' ~ bed_temp|int ~ 'Â°C'] %}{% endif %}
          {{ capped | join(', ') }} â†’ 22Â°C
        data:
          channel: "Safety"
          importance: high
          tag: "heater_safety_startup"

# =============================================================================
# CIRCADIAN LIGHTING AUTOMATIONS
# Purpose: Automatic brightness and color temperature scheduling for IKEA lights
# Lights: light.study_ikea_light, light.living_ikea_light
# Color Temp Range: 320 mired (neutral) to 454 mired (warmest)
# Brightness Range: 20% (night) to 100% (day)
#
# Schedule:
#   Night (22:00-06:00): 20% brightness, 454 mired (2200K warmest)
#   Sunrise (06:00-07:30): Gradual 20%â†’100%, 454â†’320 mired
#   Day (07:30-18:00): 100% brightness, 320 mired (3125K neutral)
#   Sunset (18:00-22:00): Gradual 100%â†’20%, 320â†’454 mired
#
# Override Detection: Uses debounce flag to detect manual changes (IKEA remotes
# use direct Zigbee binding, bypassing HA context). Any brightness/color change
# when automation_active=off triggers 30-minute override.
# =============================================================================

# -----------------------------------------------------------------------------
# CIRCADIAN SCHEDULE UPDATE
# Trigger: Every 10 minutes
# Action: Apply scheduled brightness and color temp to ON lights (not overridden)
# Note: Sets debounce flag to prevent false override detection
# -----------------------------------------------------------------------------
- id: circadian_schedule_update
  alias: "Circadian - Schedule Update"
  description: "Updates light brightness and color temp every 10 minutes"
  mode: single
  max_exceeded: silent

  trigger:
    - platform: time_pattern
      minutes: "/10"

  condition:
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"

  action:
    # Set debounce flag BEFORE changing lights
    - service: input_boolean.turn_on
      entity_id: input_boolean.circadian_automation_active

    # Read scheduled values from template sensors
    - variables:
        brightness_pct: "{{ states('sensor.circadian_brightness') | int }}"
        color_temp_kelvin: "{{ states('sensor.circadian_color_temp') | int }}"
        brightness_value: "{{ (brightness_pct / 100 * 254) | round(0) }}"

    # Study light (if on and not overridden)
    - if:
        - condition: state
          entity_id: light.study_ikea_light
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_study_override
          state: "off"
      then:
        - service: light.turn_on
          entity_id: light.study_ikea_light
          data:
            brightness: "{{ brightness_value }}"
            color_temp_kelvin: "{{ color_temp_kelvin }}"
            transition: 30

    # Living light (if on and not overridden)
    - if:
        - condition: state
          entity_id: light.living_ikea_light
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_living_override
          state: "off"
      then:
        - service: light.turn_on
          entity_id: light.living_ikea_light
          data:
            brightness: "{{ brightness_value }}"
            color_temp_kelvin: "{{ color_temp_kelvin }}"
            transition: 30

    # Clear debounce flag after 5 seconds (allows time for light state to update)
    - delay:
        seconds: 5
    - service: input_boolean.turn_off
      entity_id: input_boolean.circadian_automation_active

# -----------------------------------------------------------------------------
# CIRCADIAN POWER-ON HANDLER
# Trigger: Light turns on
# Action: Set to warmest color temp (2200K) with scheduled brightness
# Note: Power-on always uses warmest color for gentle start
# -----------------------------------------------------------------------------
- id: circadian_power_on
  alias: "Circadian - Light Power On"
  description: "When light turns on, set to warm color temp with scheduled brightness"
  mode: parallel
  max: 2

  trigger:
    - platform: state
      entity_id:
        - light.study_ikea_light
        - light.living_ikea_light
      from: "off"
      to: "on"

  condition:
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"

  variables:
    room: "{{ 'study' if trigger.entity_id == 'light.study_ikea_light' else 'living' }}"
    override_flag: "input_boolean.circadian_{{ room }}_override"
    light_name: "{{ 'Study' if room == 'study' else 'Living' }}"
    brightness_pct: "{{ states('sensor.circadian_brightness') | int }}"
    brightness_value: "{{ (brightness_pct / 100 * 254) | round(0) }}"
    phase: "{{ states('sensor.circadian_phase') }}"

  action:
    # Skip if overridden
    - condition: template
      value_template: "{{ is_state(override_flag, 'off') }}"

    # Set debounce flag
    - service: input_boolean.turn_on
      entity_id: input_boolean.circadian_automation_active

    # Small delay for light to initialize
    - delay:
        milliseconds: 300

    # Apply: warmest color temp (2200K) + scheduled brightness
    - service: light.turn_on
      target:
        entity_id: "{{ trigger.entity_id }}"
      data:
        brightness: "{{ brightness_value }}"
        color_temp_kelvin: 2200
        transition: 2

    # Clear debounce after 5 seconds
    - delay:
        seconds: 5
    - service: input_boolean.turn_off
      entity_id: input_boolean.circadian_automation_active

# -----------------------------------------------------------------------------
# CIRCADIAN OVERRIDE DETECTION
# Trigger: Light brightness or color_temp changes
# Condition: Automation is NOT actively changing lights (debounce check)
# Action: Set 30-minute override timer
# Note: Detects remote presses via timing, not context (remotes bypass HA context)
# -----------------------------------------------------------------------------
- id: circadian_override_detect
  alias: "Circadian - Override Detection"
  description: "Detects manual light changes and sets 30-minute override"
  mode: parallel
  max: 2

  trigger:
    - platform: state
      entity_id: light.study_ikea_light
      attribute: brightness
    - platform: state
      entity_id: light.study_ikea_light
      attribute: color_temp
    - platform: state
      entity_id: light.living_ikea_light
      attribute: brightness
    - platform: state
      entity_id: light.living_ikea_light
      attribute: color_temp

  condition:
    # Light must be on
    - condition: template
      value_template: "{{ trigger.to_state.state == 'on' }}"
    # Circadian must be enabled
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"
    # Automation must NOT be actively changing lights (debounce check)
    - condition: state
      entity_id: input_boolean.circadian_automation_active
      state: "off"

  variables:
    room: "{{ 'study' if 'study' in trigger.entity_id else 'living' }}"
    override_flag: "input_boolean.circadian_{{ room }}_override"
    expiry_entity: "input_datetime.circadian_{{ room }}_override_expires"
    light_name: "{{ 'Study' if room == 'study' else 'Living' }}"
    # Format expiration time as strings (avoid strftime on variable)
    expiry_datetime: "{{ (now() + timedelta(minutes=30)).strftime('%Y-%m-%d %H:%M:%S') }}"
    expiry_time: "{{ (now() + timedelta(minutes=30)).strftime('%H:%M') }}"

  action:
    # Set override flag
    - service: input_boolean.turn_on
      target:
        entity_id: "{{ override_flag }}"

    # Set expiration time
    - service: input_datetime.set_datetime
      target:
        entity_id: "{{ expiry_entity }}"
      data:
        datetime: "{{ expiry_datetime }}"

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸ’¡ {{ light_name }} Override"
        message: "Manual adjustment detected. Schedule resumes {{ expiry_time }}."
        data:
          channel: "Lights"
          importance: low
          tag: "circadian_override_{{ room }}"

# -----------------------------------------------------------------------------
# CIRCADIAN OVERRIDE EXPIRY CHECK
# Trigger: Every minute
# Condition: At least one override is active
# Action: Clear expired overrides and restore scheduled settings
# -----------------------------------------------------------------------------
- id: circadian_override_expiry
  alias: "Circadian - Override Expiry Check"
  description: "Checks for expired overrides every minute and restores schedule"
  mode: single

  trigger:
    - platform: time_pattern
      minutes: "/1"

  condition:
    # At least one override must be active
    - condition: or
      conditions:
        - condition: state
          entity_id: input_boolean.circadian_study_override
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_living_override
          state: "on"

  variables:
    brightness_pct: "{{ states('sensor.circadian_brightness') | int }}"
    color_temp_kelvin: "{{ states('sensor.circadian_color_temp') | int }}"
    brightness_value: "{{ (brightness_pct / 100 * 254) | round(0) }}"

  action:
    # Check Study override expiry
    - if:
        - condition: state
          entity_id: input_boolean.circadian_study_override
          state: "on"
        - condition: template
          value_template: >
            {{ as_timestamp(states('input_datetime.circadian_study_override_expires'))
               < as_timestamp(now()) }}
      then:
        # Clear override flag
        - service: input_boolean.turn_off
          entity_id: input_boolean.circadian_study_override

        # Restore settings if light is on
        - if:
            - condition: state
              entity_id: light.study_ikea_light
              state: "on"
          then:
            - service: input_boolean.turn_on
              entity_id: input_boolean.circadian_automation_active
            - service: light.turn_on
              entity_id: light.study_ikea_light
              data:
                brightness: "{{ brightness_value }}"
                color_temp_kelvin: "{{ color_temp_kelvin }}"
                transition: 60
            - delay:
                seconds: 5
            - service: input_boolean.turn_off
              entity_id: input_boolean.circadian_automation_active

        # Notification
        - service: notify.all_phones
          data:
            title: "ðŸ’¡ Study Light"
            message: "Override ended. Circadian schedule restored ({{ brightness_pct }}%)."
            data:
              channel: "Lights"
              importance: low
              tag: "circadian_override_study"

    # Check Living override expiry
    - if:
        - condition: state
          entity_id: input_boolean.circadian_living_override
          state: "on"
        - condition: template
          value_template: >
            {{ as_timestamp(states('input_datetime.circadian_living_override_expires'))
               < as_timestamp(now()) }}
      then:
        # Clear override flag
        - service: input_boolean.turn_off
          entity_id: input_boolean.circadian_living_override

        # Restore settings if light is on
        - if:
            - condition: state
              entity_id: light.living_ikea_light
              state: "on"
          then:
            - service: input_boolean.turn_on
              entity_id: input_boolean.circadian_automation_active
            - service: light.turn_on
              entity_id: light.living_ikea_light
              data:
                brightness: "{{ brightness_value }}"
                color_temp_kelvin: "{{ color_temp_kelvin }}"
                transition: 60
            - delay:
                seconds: 5
            - service: input_boolean.turn_off
              entity_id: input_boolean.circadian_automation_active

        # Notification
        - service: notify.all_phones
          data:
            title: "ðŸ’¡ Living Light"
            message: "Override ended. Circadian schedule restored ({{ brightness_pct }}%)."
            data:
              channel: "Lights"
              importance: low
              tag: "circadian_override_living"

# -----------------------------------------------------------------------------
# CIRCADIAN PHASE NOTIFICATION
# Trigger: Phase changes (Nightâ†’Sunriseâ†’Dayâ†’Sunsetâ†’Night)
# Condition: Circadian enabled and at least one light is on
# Action: Send notification about the phase transition
# -----------------------------------------------------------------------------
- id: circadian_phase_notification
  alias: "Circadian - Phase Change Notification"
  description: "Notifies when circadian phase changes"
  mode: single

  trigger:
    - platform: state
      entity_id: sensor.circadian_phase

  condition:
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"
    # At least one light must be on
    - condition: or
      conditions:
        - condition: state
          entity_id: light.study_ikea_light
          state: "on"
        - condition: state
          entity_id: light.living_ikea_light
          state: "on"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸŒ… Circadian Lighting"
        message: >
          {% set phase = states('sensor.circadian_phase') %}
          {% if phase == 'Sunrise' %}
            Sunrise mode: Gradually brightening to 100%
          {% elif phase == 'Day' %}
            Day mode: Full brightness (100%)
          {% elif phase == 'Sunset' %}
            Sunset mode: Gradually dimming for sleep
          {% elif phase == 'Night' %}
            Night mode: Minimal light (20%)
          {% endif %}
        data:
          channel: "Lights"
          importance: low
          tag: "circadian_phase"

# -----------------------------------------------------------------------------
# CIRCADIAN HA STARTUP INIT
# Trigger: Home Assistant starts
# Action: Enable circadian if unknown, clear stale automation_active flag
# -----------------------------------------------------------------------------
- id: circadian_ha_startup
  alias: "Circadian - HA Startup Init"
  description: "Initializes circadian lighting state on Home Assistant startup"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  action:
    # Always enable circadian on startup (user can disable manually if needed)
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.circadian_enabled

    # Clear automation_active flag (might be stale from crash)
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.circadian_automation_active

    # Clear any stale overrides from before restart
    - service: input_boolean.turn_off
      target:
        entity_id:
          - input_boolean.circadian_study_override
          - input_boolean.circadian_living_override

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸ’¡ Circadian Initialized"
        message: "Lighting schedule active. Phase: {{ states('sensor.circadian_phase') }}."
        data:
          channel: "Info"
          importance: low
          tag: "circadian_startup"

# -----------------------------------------------------------------------------
# CIRCADIAN MQTT CONTROL (Dashboard Integration)
# Trigger: MQTT command from web dashboard
# Action: Toggle circadian enabled or clear override flags
# Purpose: Allows dashboard to control circadian without HA REST API token
# Commands:
#   {"action": "toggle"} - Toggle circadian_enabled
#   {"action": "enable"} - Enable circadian
#   {"action": "disable"} - Disable circadian
#   {"action": "clear_override", "room": "study"} - Clear study override
#   {"action": "clear_override", "room": "living"} - Clear living override
#   {"action": "apply_circadian", "room": "study"} - Apply schedule to study light
#   {"action": "apply_circadian", "room": "living"} - Apply schedule to living light
# -----------------------------------------------------------------------------
- id: circadian_mqtt_control
  alias: "Circadian - MQTT Dashboard Control"
  description: "Handles circadian control commands from web dashboard via MQTT"
  mode: parallel
  max: 4

  trigger:
    - platform: mqtt
      topic: "homeassistant/circadian/command"

  action:
    - choose:
        # Toggle circadian enabled
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'toggle' }}"
          sequence:
            - service: input_boolean.toggle
              target:
                entity_id: input_boolean.circadian_enabled

        # Enable circadian
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'enable' }}"
          sequence:
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.circadian_enabled

        # Disable circadian
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'disable' }}"
          sequence:
            - service: input_boolean.turn_off
              target:
                entity_id: input_boolean.circadian_enabled

        # Clear override for a specific room
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'clear_override' }}"
          sequence:
            - service: input_boolean.turn_off
              target:
                entity_id: "input_boolean.circadian_{{ trigger.payload_json.room }}_override"

        # Apply circadian schedule to a specific light
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'apply_circadian' }}"
          sequence:
            - variables:
                room: "{{ trigger.payload_json.room }}"
                light_entity: "{{ 'light.study_ikea_light' if room == 'study' else 'light.living_ikea_light' }}"
                brightness_value: "{{ (states('sensor.circadian_brightness') | int / 100 * 254) | round(0) }}"
                color_temp_kelvin: "{{ states('sensor.circadian_color_temp') | int }}"
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.circadian_automation_active
            - service: light.turn_on
              target:
                entity_id: "{{ light_entity }}"
              data:
                brightness: "{{ brightness_value }}"
                color_temp_kelvin: "{{ color_temp_kelvin }}"
                transition: 2
            # Clear override flag since user explicitly requested schedule
            - service: input_boolean.turn_off
              target:
                entity_id: "input_boolean.circadian_{{ room }}_override"
            - delay:
                seconds: 5
            - service: input_boolean.turn_off
              target:
                entity_id: input_boolean.circadian_automation_active

# -----------------------------------------------------------------------------
# CIRCADIAN - MQTT STATE PUBLISHER
# Purpose: Publishes circadian state to MQTT for dashboard consumption
# Triggers on ANY circadian entity state change
# Topic: homeassistant/circadian/state (JSON payload)
# -----------------------------------------------------------------------------
- id: circadian_mqtt_state_publisher
  alias: "Circadian - MQTT State Publisher"
  description: "Publishes circadian state to MQTT whenever any entity changes"
  mode: queued
  max: 5

  trigger:
    # Trigger on any circadian-related entity change
    - platform: state
      entity_id:
        - sensor.circadian_phase
        - sensor.circadian_brightness
        - sensor.circadian_color_temp
        - input_boolean.circadian_enabled
        - input_boolean.circadian_study_override
        - input_boolean.circadian_living_override
        - input_datetime.circadian_study_override_expires
        - input_datetime.circadian_living_override_expires

  action:
    - service: mqtt.publish
      data:
        topic: "homeassistant/circadian/state"
        retain: true
        payload: >
          {
            "phase": "{{ states('sensor.circadian_phase') }}",
            "brightness": {{ states('sensor.circadian_brightness') | int(100) }},
            "colorTemp": {{ states('sensor.circadian_color_temp') | int(3125) }},
            "enabled": {{ is_state('input_boolean.circadian_enabled', 'on') | lower }},
            "overrides": {
              "study": {
                "active": {{ is_state('input_boolean.circadian_study_override', 'on') | lower }},
                "expires": "{{ states('input_datetime.circadian_study_override_expires') }}"
              },
              "living": {
                "active": {{ is_state('input_boolean.circadian_living_override', 'on') | lower }},
                "expires": "{{ states('input_datetime.circadian_living_override_expires') }}"
              }
            },
            "timestamp": "{{ now().isoformat() }}"
          }

# =============================================================================
# SENSOR OFFLINE MONITORING
# Purpose: Alert when contact sensors go offline (affects heater safety system)
# Problem: When sensors are "unavailable", heater resume automation can't work
#          because it requires all sensors to be state="off" (not "unavailable")
# Solution: Alert the user so they can manually trigger sensors to rejoin
# =============================================================================

# -----------------------------------------------------------------------------
# CONTACT SENSOR OFFLINE - IMMEDIATE ALERT
# Trigger: Any contact sensor goes unavailable for 5+ minutes
# Action: Send mobile notification with sensor name and recovery instructions
# -----------------------------------------------------------------------------
- id: contact_sensor_offline_alert
  alias: "Contact Sensor Offline Alert"
  description: "Alert when any contact sensor becomes unavailable"
  mode: parallel
  max: 8

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "unavailable"
      for: "00:05:00"  # Wait 5 min to confirm not temporary

  variables:
    sensor_names:
      binary_sensor.bath_window_contact_sensor_contact: "Bathroom Window"
      binary_sensor.bed_window_contact_sensor_contact: "Bedroom Window"
      binary_sensor.kitchen_window_contact_sensor_contact: "Kitchen Window"
      binary_sensor.study_window_contact_sensor_large_contact: "Study Large Window"
      binary_sensor.study_window_contact_sensor_small_contact: "Study Small Window"
      binary_sensor.living_window_contact_sensor_window_contact: "Living Window"
      binary_sensor.living_window_contact_sensor_balcony_door_contact: "Balcony Door"
      binary_sensor.hallway_window_contact_sensor_main_door_contact: "Main Door"
    sensor_name: "{{ sensor_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ“µ SENSOR OFFLINE"
        message: >
          {{ sensor_name }} sensor is offline.
          Heaters may not resume automatically.
          Try opening/closing the window to wake it.
        data:
          channel: "Alerts"
          importance: high
          tag: "sensor_offline_{{ trigger.entity_id }}"
    - service: system_log.write
      data:
        message: "ALERT: {{ sensor_name }} contact sensor went offline"
        level: warning

# -----------------------------------------------------------------------------
# CONTACT SENSOR OFFLINE - REPEAT ALERT EVERY 4 HOURS
# Trigger: Every 4 hours (time pattern)
# Condition: At least one contact sensor is unavailable
# Action: Send reminder notification listing all offline sensors
# -----------------------------------------------------------------------------
- id: contact_sensor_offline_repeat
  alias: "Contact Sensor Offline - Repeat Alert"
  description: "Repeat offline alert every 4 hours"
  mode: single

  trigger:
    - platform: time_pattern
      hours: "/4"

  action:
    - variables:
        sensor_names:
          binary_sensor.bath_window_contact_sensor_contact: "Bathroom"
          binary_sensor.bed_window_contact_sensor_contact: "Bedroom"
          binary_sensor.kitchen_window_contact_sensor_contact: "Kitchen"
          binary_sensor.study_window_contact_sensor_large_contact: "Study Large"
          binary_sensor.study_window_contact_sensor_small_contact: "Study Small"
          binary_sensor.living_window_contact_sensor_window_contact: "Living"
          binary_sensor.living_window_contact_sensor_balcony_door_contact: "Balcony Door"
          binary_sensor.hallway_window_contact_sensor_main_door_contact: "Main Door"
        offline_list: >
          {% set ns = namespace(sensors=[]) %}
          {% for entity, name in sensor_names.items() %}
            {% if states(entity) == 'unavailable' %}
              {% set ns.sensors = ns.sensors + [name] %}
            {% endif %}
          {% endfor %}
          {{ ns.sensors }}
        offline_count: "{{ offline_list | length }}"
    - condition: template
      value_template: "{{ offline_count | int > 0 }}"
    - service: notify.all_phones
      data:
        title: "ðŸ“µ {{ offline_count }} SENSOR(S) STILL OFFLINE"
        message: >
          {{ offline_list | join(', ') }} sensor(s) offline.
          Heaters won't auto-resume until fixed.
          Open/close window or check battery.
        data:
          channel: "Alerts"
          importance: high
          tag: "sensor_offline_repeat"

# -----------------------------------------------------------------------------
# CONTACT SENSOR BACK ONLINE - CLEAR ALERT
# Trigger: Any contact sensor transitions FROM unavailable to any other state
# Action: Send recovery notification and clear the offline alert
# -----------------------------------------------------------------------------
- id: contact_sensor_back_online
  alias: "Contact Sensor Back Online"
  description: "Clear alert when sensor comes back online"
  mode: parallel
  max: 8

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      from: "unavailable"

  variables:
    sensor_names:
      binary_sensor.bath_window_contact_sensor_contact: "Bathroom Window"
      binary_sensor.bed_window_contact_sensor_contact: "Bedroom Window"
      binary_sensor.kitchen_window_contact_sensor_contact: "Kitchen Window"
      binary_sensor.study_window_contact_sensor_large_contact: "Study Large Window"
      binary_sensor.study_window_contact_sensor_small_contact: "Study Small Window"
      binary_sensor.living_window_contact_sensor_window_contact: "Living Window"
      binary_sensor.living_window_contact_sensor_balcony_door_contact: "Balcony Door"
      binary_sensor.hallway_window_contact_sensor_main_door_contact: "Main Door"
    sensor_name: "{{ sensor_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    - service: notify.all_phones
      data:
        title: "âœ… SENSOR ONLINE"
        message: "{{ sensor_name }} sensor is back online"
        data:
          channel: "Alerts"
          tag: "sensor_offline_{{ trigger.entity_id }}"
    - service: system_log.write
      data:
        message: "RECOVERED: {{ sensor_name }} contact sensor is back online"
        level: info

# =============================================================================
# ZIGBEE NETWORK MONITORING ALERTS
# Purpose: Monitor Zigbee network health during device recovery
# Created: 2026-01-05 (after network reformation incident)
# =============================================================================

# -----------------------------------------------------------------------------
# ZIGBEE DEVICE JOINED ALERT
# Trigger: Any device successfully completes interview (joins network)
# Action: Mobile notification to both phones
# Purpose: Monitor device recovery after network reformation
# -----------------------------------------------------------------------------
- id: zigbee_device_joined_alert
  alias: "Zigbee Device Joined Alert"
  description: "Notifies when any Zigbee device successfully joins the network"
  mode: parallel
  max: 10

  trigger:
    - platform: mqtt
      topic: "zigbee2mqtt/bridge/event"

  condition:
    - condition: template
      value_template: >
        {{ trigger.payload_json.type == 'device_interview' and
           trigger.payload_json.data.status == 'successful' }}

  action:
    - service: notify.all_phones
      data:
        title: "ðŸŽ‰ Zigbee Device Joined!"
        message: >
          {{ trigger.payload_json.data.friendly_name }} has joined the network
          ({{ trigger.payload_json.data.ieee_address }})
        data:
          channel: "Zigbee"
          importance: high
          tag: "zigbee_join_{{ trigger.payload_json.data.ieee_address }}"
    - service: system_log.write
      data:
        message: >
          ZIGBEE JOIN: {{ trigger.payload_json.data.friendly_name }}
          ({{ trigger.payload_json.data.ieee_address }}) joined successfully
        level: info

# -----------------------------------------------------------------------------
# ZIGBEE ROUTER OFFLINE ALERT
# Trigger: Any router device goes offline (unavailable)
# Devices: Smart Plugs, IKEA Lights, CO2 Sensor, Light Switch
# Action: Mobile notification with device name
# Cooldown: 5 minutes per device (prevents spam during network issues)
# -----------------------------------------------------------------------------
- id: zigbee_router_offline_alert
  alias: "Zigbee Router Offline Alert"
  description: "Notifies when any Zigbee router device goes offline"
  mode: parallel
  max: 10

  trigger:
    # Smart Plugs
    - platform: state
      entity_id: switch.smart_plug_1
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: switch.smart_plug_2
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: switch.smart_plug_3
      to: "unavailable"
      for:
        minutes: 2
    # IKEA Lights
    - platform: state
      entity_id: light.study_ikea_light
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: light.living_ikea_light
      to: "unavailable"
      for:
        minutes: 2
    # CO2 Sensor (router device)
    - platform: state
      entity_id: sensor.hallway_co2_co2
      to: "unavailable"
      for:
        minutes: 2
    # Light Switch
    - platform: state
      entity_id: switch.study_light_switch
      to: "unavailable"
      for:
        minutes: 2

  variables:
    device_names:
      switch.smart_plug_1: "Smart Plug [1]"
      switch.smart_plug_2: "Smart Plug [2]"
      switch.smart_plug_3: "Smart Plug [3]"
      light.study_ikea_light: "[Study] IKEA Light"
      light.living_ikea_light: "[Living] IKEA Light"
      sensor.hallway_co2_co2: "[Hallway] CO2 Sensor"
      switch.study_light_switch: "[Study] Light Switch"
    device_name: "{{ device_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    - service: notify.all_phones
      data:
        title: "âš ï¸ Zigbee Router OFFLINE"
        message: >
          {{ device_name }} is offline! This may affect mesh network.
          Check if device is powered on.
        data:
          channel: "Critical"
          importance: max
          tag: "router_offline_{{ trigger.entity_id }}"
          vibrationPattern: "100, 500, 100, 500"
    - service: system_log.write
      data:
        message: "ROUTER OFFLINE: {{ device_name }} ({{ trigger.entity_id }}) went unavailable"
        level: warning

# -----------------------------------------------------------------------------
# ZIGBEE ROUTER BACK ONLINE ALERT
# Trigger: Any router device comes back online
# Action: Mobile notification (clears offline alert)
# -----------------------------------------------------------------------------
- id: zigbee_router_online_alert
  alias: "Zigbee Router Back Online Alert"
  description: "Notifies when a Zigbee router device comes back online"
  mode: parallel
  max: 10

  trigger:
    # Smart Plugs
    - platform: state
      entity_id: switch.smart_plug_1
      from: "unavailable"
    - platform: state
      entity_id: switch.smart_plug_2
      from: "unavailable"
    - platform: state
      entity_id: switch.smart_plug_3
      from: "unavailable"
    # IKEA Lights
    - platform: state
      entity_id: light.study_ikea_light
      from: "unavailable"
    - platform: state
      entity_id: light.living_ikea_light
      from: "unavailable"
    # CO2 Sensor
    - platform: state
      entity_id: sensor.hallway_co2_co2
      from: "unavailable"
    # Light Switch
    - platform: state
      entity_id: switch.study_light_switch
      from: "unavailable"

  variables:
    device_names:
      switch.smart_plug_1: "Smart Plug [1]"
      switch.smart_plug_2: "Smart Plug [2]"
      switch.smart_plug_3: "Smart Plug [3]"
      light.study_ikea_light: "[Study] IKEA Light"
      light.living_ikea_light: "[Living] IKEA Light"
      sensor.hallway_co2_co2: "[Hallway] CO2 Sensor"
      switch.study_light_switch: "[Study] Light Switch"
    device_name: "{{ device_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    - service: notify.all_phones
      data:
        title: "âœ… Zigbee Router ONLINE"
        message: "{{ device_name }} is back online!"
        data:
          channel: "Zigbee"
          importance: high
          tag: "router_offline_{{ trigger.entity_id }}"
    - service: system_log.write
      data:
        message: "ROUTER ONLINE: {{ device_name }} ({{ trigger.entity_id }}) is back"
        level: info
