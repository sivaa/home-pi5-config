# =============================================================================
# HOME ASSISTANT AUTOMATIONS
# Purpose: Event-driven actions for smart home
# =============================================================================

# -----------------------------------------------------------------------------
# MAILBOX MOTION ALERT
# Trigger: Motion detected at mailbox (PIR sensor)
# Action: TTS announcement on KITCHEN DISPLAY only + mobile notification
# Quiet Hours: 23:00 - 07:00 (no announcements)
# Cooldown: 30 seconds (prevents spam from continuous motion)
# -----------------------------------------------------------------------------
- id: mailbox_motion_alert
  alias: "Mailbox Motion Alert"
  description: "Announces when motion is detected at the mailbox"
  mode: single

  trigger:
    - platform: state
      entity_id: binary_sensor.mailbox_motion_sensor_occupancy
      to: "on"

  condition:
    # Quiet hours: no announcements between 23:00 and 07:00
    - condition: time
      after: "07:00:00"
      before: "23:00:00"
    # 30-second cooldown to prevent spam
    - condition: template
      value_template: >
        {{ (now() - state_attr('automation.mailbox_motion_alert', 'last_triggered')).total_seconds() > 30
           if state_attr('automation.mailbox_motion_alert', 'last_triggered') is not none
           else true }}

  action:
    # TTS announcement with fallback cascade (kitchen â†’ broken+bedroom â†’ phone)
    - service: script.smart_tts_announce
      data:
        message: "Mailbox opened"
        title: "ðŸ“¬ Mailbox"
    # Always send mobile notification (in addition to TTS - for when away from home)
    - service: notify.all_phones
      data:
        title: "ðŸ“¬ Mailbox"
        message: "Motion detected at mailbox"
        data:
          channel: "Alerts"
          importance: high

# -----------------------------------------------------------------------------
# CO2 LEVEL ALERT
# Trigger: CO2 level rises above 1200 ppm, OR every 30 min while high, OR on HA startup
# Action: TTS announcement to ventilate
# Cooldown: 30 minutes (prevents repeated announcements)
# Quiet Hours: 07:00-23:00 only
# -----------------------------------------------------------------------------
- id: co2_high_alert
  alias: "CO2 High Level Alert"
  description: "Announces when CO2 levels are too high and ventilation is needed"
  mode: single

  trigger:
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200
    # Also trigger on HA startup to catch already-high levels
    - platform: homeassistant
      event: start
    # Periodic check every 30 minutes while CO2 stays high
    - platform: time_pattern
      minutes: "/30"

  condition:
    # Verify CO2 is actually above threshold (needed for startup trigger)
    - condition: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200
    # Only announce during waking hours (7 AM to 11 PM)
    - condition: time
      after: "07:00:00"
      before: "23:00:00"
    # 30-minute cooldown to match periodic trigger
    - condition: template
      value_template: >
        {{ (now() - state_attr('automation.co2_high_level_alert', 'last_triggered')).total_seconds() > 1800
           if state_attr('automation.co2_high_level_alert', 'last_triggered') is not none
           else true }}

  action:
    # Smart TTS with retry logic - waits up to 5 min if Kitchen Display unavailable
    - service: script.smart_tts_co2_alert
      data:
        message: >
          Nithya, please ventilate. CO2 level is above {{ (states('sensor.hallway_co2_co2') | int // 100) * 100 }}.
        co2_threshold: 1200
    - service: notify.all_phones
      data:
        title: "âš ï¸ CO2 High"
        message: "CO2 above {{ states('sensor.hallway_co2_co2') }} ppm - please ventilate"
        data:
          channel: "Alerts"
          importance: high

# -----------------------------------------------------------------------------
# CO2 CRITICAL ALERT
# Trigger: Every 10 minutes, checks if CO2 > 1600 ppm
# Action: Urgent TTS announcement + mobile notification
# Quiet Hours: 07:00-23:00 only (same as high alert)
# -----------------------------------------------------------------------------
- id: co2_critical_alert
  alias: "CO2 Critical Level Alert"
  description: "Checks every 10 minutes and announces if CO2 is dangerously high"
  mode: single

  trigger:
    # Check every 10 minutes
    - platform: time_pattern
      minutes: "/10"
    # Also trigger immediately when crossing threshold
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1600

  condition:
    # Only announce if CO2 is above critical level
    - condition: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1600
    # Quiet hours: only announce during waking hours (7 AM to 11 PM)
    - condition: time
      after: "07:00:00"
      before: "23:00:00"

  action:
    # Smart TTS with retry logic - waits up to 5 min if Kitchen Display unavailable
    - service: script.smart_tts_co2_alert
      data:
        message: >
          Warning! CO2 level is critical at {{ states('sensor.hallway_co2_co2') | int }}. Please open windows immediately!
        co2_threshold: 1600
    - service: notify.all_phones
      data:
        title: "ðŸš¨ CO2 CRITICAL"
        message: "CO2 at {{ states('sensor.hallway_co2_co2') }} ppm - OPEN WINDOWS NOW!"
        data:
          channel: "Critical"
          importance: max
          vibrationPattern: "100, 1000, 100, 1000, 100"

# -----------------------------------------------------------------------------
# CO2 EPISODE START TRACKER
# Trigger: CO2 crosses above 1200 ppm
# Action: Record episode start time (if not already tracking)
# Note: Uses sentinel value "1970-01-01 00:00:00" to indicate "not tracking"
# -----------------------------------------------------------------------------
- id: co2_episode_start
  alias: "CO2 Episode Start Tracker"
  description: "Records when CO2 first crosses 1200 ppm; also records window open time if window is already open"
  mode: single

  trigger:
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200

  condition:
    # Only set if not already tracking (sentinel = timestamp < 86400, i.e. before 1970-01-02)
    - condition: template
      value_template: >
        {{ states('input_datetime.co2_high_started') in ['unknown', 'unavailable', '']
           or as_timestamp(states('input_datetime.co2_high_started')) | default(0) < 86400 }}

  action:
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.co2_high_started
      data:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

    # If any window is already open, record that time too
    - if:
        - condition: or
          conditions:
            - condition: state
              entity_id: binary_sensor.bath_window_contact_sensor_contact
              state: "on"
            - condition: state
              entity_id: binary_sensor.bed_window_contact_sensor_contact
              state: "on"
            - condition: state
              entity_id: binary_sensor.kitchen_window_contact_sensor_contact
              state: "on"
            - condition: state
              entity_id: binary_sensor.study_window_contact_sensor_large_contact
              state: "on"
            - condition: state
              entity_id: binary_sensor.study_window_contact_sensor_small_contact
              state: "on"
            - condition: state
              entity_id: binary_sensor.living_window_contact_sensor_window_contact
              state: "on"
      then:
        - service: input_datetime.set_datetime
          target:
            entity_id: input_datetime.co2_window_opened
          data:
            datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

# -----------------------------------------------------------------------------
# CO2 EPISODE - WINDOW OPENED
# Trigger: Any window opens
# Condition: CO2 episode is active AND window time not yet recorded
# Action: Record when first window opened during this episode
# -----------------------------------------------------------------------------
- id: co2_episode_window_opened
  alias: "CO2 Episode - Window Opened"
  description: "Records when first window opens during a CO2 episode"
  mode: single

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
      to: "on"

  condition:
    # Episode is active (co2_high_started is set, not sentinel - timestamp > 86400)
    - condition: template
      value_template: >
        {{ as_timestamp(states('input_datetime.co2_high_started')) | default(0) > 86400 }}
    # Window time not yet recorded (is sentinel - timestamp < 86400)
    - condition: template
      value_template: >
        {{ as_timestamp(states('input_datetime.co2_window_opened')) | default(0) < 86400 }}

  action:
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.co2_window_opened
      data:
        datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

# -----------------------------------------------------------------------------
# CO2 GOOD LEVEL NOTIFICATION
# Trigger: CO2 level drops below 500 ppm (good air quality)
# Action: Thank Nithya with episode/ventilation time metrics, then reset episode tracking
# Cooldown: 30 minutes (prevents repeated notifications if CO2 bounces)
# -----------------------------------------------------------------------------
- id: co2_good_level
  alias: "CO2 Good Level Notification"
  description: "Announces when air quality is good after ventilation"
  mode: single

  trigger:
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      below: 500

  condition:
    # Only announce during waking hours (7 AM to 11 PM)
    - condition: time
      after: "07:00:00"
      before: "23:00:00"
    # 30-minute cooldown
    - condition: template
      value_template: >
        {{ (now() - state_attr('automation.co2_good_level_notification', 'last_triggered')).total_seconds() > 1800
           if state_attr('automation.co2_good_level_notification', 'last_triggered') is not none
           else true }}
    # Only announce if there's an active CO2 episode (episode tracker is set, not sentinel)
    # Sentinel = timestamp < 86400 (before 1970-01-02)
    - condition: template
      value_template: >
        {{ as_timestamp(states('input_datetime.co2_high_started')) | default(0) > 86400 }}

  action:
    # Use smart TTS with speaker availability check and mobile fallback
    - service: script.smart_tts_announce
      data:
        message: >
          {# Sentinel = timestamp < 86400 (before 1970-01-02, i.e. day 0 of Unix time = "not tracking") #}
          {% set sentinel = 86400 %}
          {% set now_ts = as_timestamp(now()) %}

          {# ===== METRIC 1: Episode time (CO2 > 1200 â†’ < 500) ===== #}
          {% set episode_start_ts = as_timestamp(states('input_datetime.co2_high_started')) | default(0) %}
          {% if episode_start_ts > sentinel %}
            {% set episode_minutes = [0, ((now_ts - episode_start_ts) / 60) | round(0) | int] | max %}
          {% else %}
            {% set episode_minutes = 0 %}
          {% endif %}

          {# ===== METRIC 2: Ventilation time (window opened during episode â†’ < 500) ===== #}
          {% set window_ts = as_timestamp(states('input_datetime.co2_window_opened')) | default(0) %}
          {% if window_ts > sentinel %}
            {% set ventilation_minutes = [0, ((now_ts - window_ts) / 60) | round(0) | int] | max %}
          {% else %}
            {% set ventilation_minutes = 0 %}
          {% endif %}

          {# ===== Build message ===== #}
          {% if episode_minutes > 0 and ventilation_minutes > 0 %}
            Thanks Nithya! Air quality is good now. CO2 was high for {{ episode_minutes }} minute{{ 's' if episode_minutes != 1 else '' }}, ventilated in {{ ventilation_minutes }} minute{{ 's' if ventilation_minutes != 1 else '' }}. You can close the windows.
          {% elif episode_minutes > 0 %}
            Thanks Nithya! Air quality is good now. CO2 normalized in {{ episode_minutes }} minute{{ 's' if episode_minutes != 1 else '' }}. You can close the windows.
          {% else %}
            Thanks Nithya! Air quality is good now. You can close the windows.
          {% endif %}
        title: "âœ… Air Quality Good"
    # Always send mobile notification (in addition to TTS)
    - service: notify.all_phones
      data:
        title: "âœ… Air Quality Good"
        message: "CO2 now {{ states('sensor.hallway_co2_co2') }} ppm - windows can be closed"
        data:
          channel: "Info"
          importance: default
    # Reset episode tracking timestamps to sentinel (cleanup for next episode)
    - service: input_datetime.set_datetime
      target:
        entity_id:
          - input_datetime.co2_high_started
          - input_datetime.co2_window_opened
      data:
        datetime: "1970-01-01 00:00:00"

# -----------------------------------------------------------------------------
# CO2 EPISODE CLEANUP ON STARTUP
# Trigger: Home Assistant starts
# Condition: CO2 is already good (< 500 ppm) AND episode tracking is active
# Action: Reset episode timestamps to sentinel (cleanup stale state)
# Why: If HA restarts mid-episode and CO2 normalized during downtime,
#      the "good level" trigger won't fire (needs crossing, not just being below)
# -----------------------------------------------------------------------------
- id: co2_episode_cleanup_on_start
  alias: "CO2 Episode Cleanup on Startup"
  description: "Resets stale CO2 episode tracking if air is already good on HA start"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  condition:
    # CO2 is already good
    - condition: numeric_state
      entity_id: sensor.hallway_co2_co2
      below: 500
    # Episode tracking is active (not sentinel)
    - condition: template
      value_template: >
        {{ as_timestamp(states('input_datetime.co2_high_started')) | default(0) > 86400 }}

  action:
    - service: input_datetime.set_datetime
      target:
        entity_id:
          - input_datetime.co2_high_started
          - input_datetime.co2_window_opened
      data:
        datetime: "1970-01-01 00:00:00"
    - service: system_log.write
      data:
        message: "CO2 Episode Cleanup: Reset stale episode tracking on startup (CO2 already good)"
        level: info

# -----------------------------------------------------------------------------
# WINDOW OPEN TOO LONG (TEMPERATURE-AWARE)
# Trigger: Any window/balcony door open for 5min (freezing) or 10min (normal)
# Condition: Temperature-based (<=0C = freezing = 5min, >0C = 10min)
# Action: TTS + mobile notification, repeat every 1 minute until closed
# Sensors: All 7 windows + balcony door (main door has separate 3-min alert)
# Backup: Cold weather alert (15min, <18C) catches edge cases
# -----------------------------------------------------------------------------
- id: window_open_too_long
  alias: "Window Open Too Long (Temperature-Aware)"
  description: "5min alert if <=0C (freezing), 10min if >0C. Covers all windows + balcony door."
  mode: parallel
  max: 7

  trigger:
    # FREEZING trigger: 5 minutes when temp <= 0C
    - id: "freezing"
      platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
      to: "on"
      for:
        minutes: 5

    # STANDARD trigger: 10 minutes when temp > 0C
    - id: "standard"
      platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
      to: "on"
      for:
        minutes: 10

  condition:
    # Temperature check: freezing trigger needs temp <= 0, standard needs temp > 0
    # Use -999 default so unavailable sensor = assume freezing (safer)
    - condition: template
      value_template: >
        {% set temp = states('sensor.balcony_temperature_humidity_temperature') | float(-999) %}
        {% if trigger.id == 'freezing' %}
          {{ temp <= 0 }}
        {% else %}
          {{ temp > 0 }}
        {% endif %}

  variables:
    window_name: >
      {% set names = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom Window',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom Window',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen Window',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large Window',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small Window',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window',
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}
    is_freezing: "{{ trigger.id == 'freezing' }}"

  action:
    - repeat:
        while:
          - condition: template
            value_template: "{{ is_state(trigger.entity_id, 'on') }}"
        sequence:
          # Use smart TTS script with retry, mobile fallback, and obsolescence check
          - service: script.smart_tts_window_alert
            data:
              message: >
                {% set minutes = ((now() - states[trigger.entity_id].last_changed).total_seconds() / 60) | round(0) | int %}
                {% set temp = states('sensor.balcony_temperature_humidity_temperature') | round(0) | int %}
                {{ window_name }} has been open for {{ minutes }} minutes.
                {% if is_freezing %}It's {{ temp }} degrees outside - freezing!{% endif %}
              window_entity: "{{ trigger.entity_id }}"
          # Mobile notification
          - service: notify.all_phones
            data:
              title: >
                {% if is_freezing %}ðŸ¥¶{% else %}ðŸªŸ{% endif %} {{ window_name }}
              message: >
                {% set minutes = ((now() - states[trigger.entity_id].last_changed).total_seconds() / 60) | round(0) | int %}
                {% set temp = states('sensor.balcony_temperature_humidity_temperature') | round(0) | int %}
                Open for {{ minutes }} min{% if is_freezing %} - {{ temp }}Â° freezing!{% endif %}
              data:
                channel: "{% if is_freezing %}Critical{% else %}Alerts{% endif %}"
                importance: "{% if is_freezing %}max{% else %}high{% endif %}"
                tag: "window_{{ trigger.entity_id | replace('.', '_') }}"
          - delay:
              minutes: 1

# =============================================================================
# HEATER NOTIFICATIONS
# Purpose: Notify when heaters start/stop heating
# =============================================================================

# -----------------------------------------------------------------------------
# STUDY HEATER - STARTED
# -----------------------------------------------------------------------------
- id: study_heater_started
  alias: "Study Heater Started"
  description: "Notifies when study heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.study_thermostat
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Study Heater ON"
        message: "Target: {{ state_attr('climate.study_thermostat', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_study"

# -----------------------------------------------------------------------------
# STUDY HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: study_heater_stopped
  alias: "Study Heater Stopped"
  description: "Notifies when study heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.study_thermostat
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Study Heater OFF"
        message: "Current: {{ state_attr('climate.study_thermostat', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_study"

# -----------------------------------------------------------------------------
# LIVING INNER HEATER - STARTED
# -----------------------------------------------------------------------------
- id: living_inner_heater_started
  alias: "Living Inner Heater Started"
  description: "Notifies when living inner heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_inner
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Living Inner Heater ON"
        message: "Target: {{ state_attr('climate.living_thermostat_inner', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_inner"

# -----------------------------------------------------------------------------
# LIVING INNER HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: living_inner_heater_stopped
  alias: "Living Inner Heater Stopped"
  description: "Notifies when living inner heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_inner
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Living Inner Heater OFF"
        message: "Current: {{ state_attr('climate.living_thermostat_inner', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_inner"

# -----------------------------------------------------------------------------
# LIVING OUTER HEATER - STARTED
# -----------------------------------------------------------------------------
- id: living_outer_heater_started
  alias: "Living Outer Heater Started"
  description: "Notifies when living outer heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_outer
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Living Outer Heater ON"
        message: "Target: {{ state_attr('climate.living_thermostat_outer', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_outer"

# -----------------------------------------------------------------------------
# LIVING OUTER HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: living_outer_heater_stopped
  alias: "Living Outer Heater Stopped"
  description: "Notifies when living outer heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.living_thermostat_outer
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Living Outer Heater OFF"
        message: "Current: {{ state_attr('climate.living_thermostat_outer', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_living_outer"

# -----------------------------------------------------------------------------
# BEDROOM HEATER - STARTED
# -----------------------------------------------------------------------------
- id: bed_heater_started
  alias: "Bedroom Heater Started"
  description: "Notifies when bedroom heater starts heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.bed_thermostat
      attribute: hvac_action
      to: "heating"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ”¥ Bedroom Heater ON"
        message: "Target: {{ state_attr('climate.bed_thermostat', 'temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_bedroom"

# -----------------------------------------------------------------------------
# BEDROOM HEATER - STOPPED
# -----------------------------------------------------------------------------
- id: bed_heater_stopped
  alias: "Bedroom Heater Stopped"
  description: "Notifies when bedroom heater stops heating"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.bed_thermostat
      attribute: hvac_action
      from: "heating"
      to: "idle"

  action:
    - service: notify.all_phones
      data:
        title: "â„ï¸ Bedroom Heater OFF"
        message: "Current: {{ state_attr('climate.bed_thermostat', 'current_temperature') }}Â°C"
        data:
          channel: "Heater"
          importance: default
          tag: "heater_bedroom"

# =============================================================================
# THERMOSTAT AUDIT LOGGING
# Purpose: Track ALL setpoint changes for debugging and accountability
# =============================================================================

# -----------------------------------------------------------------------------
# THERMOSTAT SETPOINT CHANGE AUDIT
# Trigger: ANY change to setpoint temperature on ANY thermostat
# Action: Mobile notification with old/new values and timestamp
# Why: To catch rogue temperature changes from unknown sources
# -----------------------------------------------------------------------------
- id: thermostat_setpoint_changed_audit
  alias: "Thermostat Setpoint Changed (Audit)"
  description: "Sends notification when any thermostat setpoint changes - for audit tracking"
  mode: parallel

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: temperature

  condition:
    # Only trigger if temperature actually changed (not just state refresh)
    - condition: template
      value_template: >
        {{ trigger.from_state.attributes.temperature is defined
           and trigger.to_state.attributes.temperature is defined
           and trigger.from_state.attributes.temperature != trigger.to_state.attributes.temperature }}

  action:
    - service: notify.all_phones
      data:
        title: "ðŸŒ¡ï¸ Setpoint Changed"
        message: >
          {{ trigger.to_state.name }}
          {{ trigger.from_state.attributes.temperature }}Â°C â†’ {{ trigger.to_state.attributes.temperature }}Â°C
          at {{ now().strftime('%H:%M:%S') }}
        data:
          channel: "Audit"
          importance: high
          tag: "setpoint_{{ trigger.entity_id }}"

# =============================================================================
# WINDOW-HEATER SAFETY AUTOMATIONS
# Purpose: Turn off heaters when windows/doors open, resume when all closed
# =============================================================================

# -----------------------------------------------------------------------------
# DOOR OPEN FOR 2 MINUTES - TURN OFF ALL HEATERS
# Trigger: Balcony door or main door open for 2 minutes
# Action: Turn off all heaters, notify user
# Note: If door closes within 2 minutes, this automation does NOT fire
# FIX: Uses guard flag to prevent state overwrite and duplicate notifications
#
# QUIET HOURS: Intentionally IGNORED.
# Reason: Safety alert - if door is open at 3am with heaters running,
#         user should be woken to prevent energy waste and freezing house.
#         (Confirmed 2026-01-10: User wants night alerts for safety events)
# -----------------------------------------------------------------------------
- id: door_open_turn_off_heaters
  alias: "Door Open 2min - Turn Off All Heaters"
  description: "When balcony door or main door stays open for 2 minutes, turn off all heaters"
  mode: single
  max_exceeded: silent

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "on"
      for:
        minutes: 2

  variables:
    door_name: >
      {% set names = {
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door',
        'binary_sensor.hallway_window_contact_sensor_main_door_contact': 'Main Door'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

    heaters_running: >
      {% set running = [] %}
      {% if state_attr('climate.study_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Study'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_inner', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Inner'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_outer', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Outer'] %}
      {% endif %}
      {% if state_attr('climate.bed_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Bedroom'] %}
      {% endif %}
      {{ running | join(', ') if running else 'None' }}

  condition:
    # Guard flag must be OFF (heaters not already turned off by another window/door)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    # At least one heater must be in 'heat' mode
    - condition: template
      value_template: >
        {{ states('climate.study_thermostat') == 'heat'
           or states('climate.living_thermostat_inner') == 'heat'
           or states('climate.living_thermostat_outer') == 'heat'
           or states('climate.bed_thermostat') == 'heat' }}

  action:
    # Set guard flag FIRST (prevents race conditions and duplicate notifications)
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.heaters_off_due_to_window

    # CO2 HANDOFF: If CO2 flag is ON, transfer ownership (skip state save)
    - if:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"
      then:
        # Clear CO2 flag (door/window takes priority)
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_co2
        # Skip state saving - CO2 already saved it
        # Skip turning off heaters - already off
        # Just notify about priority transfer
        - service: notify.all_phones
          data:
            title: "ðŸšª {{ door_name }} (CO2 Handoff)"
            message: "Door opened while CO2 was high. Door now controls heater resume."
            data:
              channel: "Info"
              tag: "window_heater_safety"
        - service: script.smart_tts_announce
          data:
            message: "{{ door_name }} open. Door control takes over from CO2."
            title: "ðŸšª CO2 Handoff"
        - stop: "Transferred ownership from CO2 to door"

    # SAVE current heater states (now protected by guard)
    # RACE CONDITION FIX v2 (2026-01-12): Use TIMESTAMP-BASED detection
    # If mode='off' but changed within last 60 seconds, treat as transient error â†’ save as ON
    # This catches the case where MQTT error flips state to OFF before this automation runs
    - service: "input_boolean.turn_{{ 'on' if states('climate.study_thermostat') == 'heat' or (states('climate.study_thermostat') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.study_thermostat.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.study_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_inner') == 'heat' or (states('climate.living_thermostat_inner') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_inner.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.living_inner_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_outer') == 'heat' or (states('climate.living_thermostat_outer') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_outer.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.living_outer_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.bed_thermostat') == 'heat' or (states('climate.bed_thermostat') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.bed_thermostat.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.bedroom_heater_was_on

    # SAVE current setpoints BEFORE turning off
    # (TRVZB firmware drops setpoint to frost protection when mode is set to off)
    # RACE CONDITION FIX: Use max(current_setpoint, 18) to prevent saving 7Â°C frost protection
    - service: input_number.set_value
      target:
        entity_id: input_number.study_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.study_thermostat', 'temperature') | float(18), 18] | max }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_inner_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.living_thermostat_inner', 'temperature') | float(18), 18] | max }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_outer_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.living_thermostat_outer', 'temperature') | float(18), 18] | max }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.bed_thermostat', 'temperature') | float(18), 18] | max }}"

    # Turn off all heaters
    - service: climate.set_hvac_mode
      target:
        entity_id:
          - climate.study_thermostat
          - climate.living_thermostat_inner
          - climate.living_thermostat_outer
          - climate.bed_thermostat
      data:
        hvac_mode: "off"

    - service: script.smart_tts_announce
      data:
        message: >-
          {{ door_name }} open 2 minutes.
          {%- if heaters_running != 'None' %} Pausing {{ heaters_running }}.
          {%- else %} No heaters active.
          {%- endif %}
        title: "ðŸšª {{ door_name }}"

    - service: notify.all_phones
      data:
        title: "ðŸšª {{ door_name }}"
        message: >-
          Open 2 min.
          {%- if heaters_running != 'None' %} Paused: {{ heaters_running }}
          {%- else %} No heaters active
          {%- endif %}
        data:
          channel: "Critical"
          importance: max
          tag: "window_heater_safety"

# -----------------------------------------------------------------------------
# WINDOW OPEN FOR 30 SECONDS - TURN OFF ALL HEATERS
# Trigger: Any window open for 30 seconds
# Action: Turn off all heaters, notify user
# Note: If window closes within 30 seconds, this automation does NOT fire
# FIX: Uses guard flag to prevent state overwrite and duplicate notifications
#
# QUIET HOURS: Intentionally IGNORED.
# Reason: Safety alert - if window is open at 3am with heaters running,
#         user should be woken to prevent energy waste and freezing house.
#         (Confirmed 2026-01-10: User wants night alerts for safety events)
# -----------------------------------------------------------------------------
- id: window_open_turn_off_heaters
  alias: "Window Open 30s - Turn Off All Heaters"
  description: "When any window stays open for 30 seconds, turn off all heaters"
  mode: single
  max_exceeded: silent

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
      to: "on"
      for:
        seconds: 30

  variables:
    window_name: >
      {% set names = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom Window',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom Window',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen Window',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large Window',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small Window',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

    heaters_running: >
      {% set running = [] %}
      {% if state_attr('climate.study_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Study'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_inner', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Inner'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_outer', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Outer'] %}
      {% endif %}
      {% if state_attr('climate.bed_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Bedroom'] %}
      {% endif %}
      {{ running | join(', ') if running else 'None' }}

  condition:
    # Guard flag must be OFF (heaters not already turned off by another window/door)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    # At least one heater must be in 'heat' mode
    - condition: template
      value_template: >
        {{ states('climate.study_thermostat') == 'heat'
           or states('climate.living_thermostat_inner') == 'heat'
           or states('climate.living_thermostat_outer') == 'heat'
           or states('climate.bed_thermostat') == 'heat' }}

  action:
    # Set guard flag FIRST (prevents race conditions and duplicate notifications)
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.heaters_off_due_to_window

    # CO2 HANDOFF: If CO2 flag is ON, transfer ownership (skip state save)
    - if:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"
      then:
        # Clear CO2 flag (window takes priority)
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_co2
        # Skip state saving - CO2 already saved it
        # Skip turning off heaters - already off
        # Just notify about priority transfer
        - service: notify.all_phones
          data:
            title: "ðŸªŸ {{ window_name }} (CO2 Handoff)"
            message: "Window opened while CO2 was high. Window now controls heater resume."
            data:
              channel: "Info"
              tag: "window_heater_safety"
        - service: script.smart_tts_announce
          data:
            message: "{{ window_name }} open. Window control takes over from CO2."
            title: "ðŸªŸ CO2 Handoff"
        - stop: "Transferred ownership from CO2 to window"

    # SAVE current heater states (now protected by guard)
    # RACE CONDITION FIX v2 (2026-01-12): Use TIMESTAMP-BASED detection
    # If mode='off' but changed within last 60 seconds, treat as transient error â†’ save as ON
    # This catches the case where MQTT error flips state to OFF before this automation runs
    - service: "input_boolean.turn_{{ 'on' if states('climate.study_thermostat') == 'heat' or (states('climate.study_thermostat') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.study_thermostat.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.study_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_inner') == 'heat' or (states('climate.living_thermostat_inner') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_inner.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.living_inner_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_outer') == 'heat' or (states('climate.living_thermostat_outer') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_outer.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.living_outer_heater_was_on
    - service: "input_boolean.turn_{{ 'on' if states('climate.bed_thermostat') == 'heat' or (states('climate.bed_thermostat') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.bed_thermostat.last_changed)) < 60) else 'off' }}"
      target:
        entity_id: input_boolean.bedroom_heater_was_on

    # SAVE current setpoints BEFORE turning off
    # (TRVZB firmware drops setpoint to frost protection when mode is set to off)
    # RACE CONDITION FIX: Use max(current_setpoint, 18) to prevent saving 7Â°C frost protection
    - service: input_number.set_value
      target:
        entity_id: input_number.study_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.study_thermostat', 'temperature') | float(18), 18] | max }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_inner_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.living_thermostat_inner', 'temperature') | float(18), 18] | max }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.living_outer_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.living_thermostat_outer', 'temperature') | float(18), 18] | max }}"
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_heater_saved_temp
      data:
        value: "{{ [state_attr('climate.bed_thermostat', 'temperature') | float(18), 18] | max }}"

    # Turn off all heaters
    - service: climate.set_hvac_mode
      target:
        entity_id:
          - climate.study_thermostat
          - climate.living_thermostat_inner
          - climate.living_thermostat_outer
          - climate.bed_thermostat
      data:
        hvac_mode: "off"

    - service: script.smart_tts_announce
      data:
        message: >-
          {{ window_name }} open 30 seconds.
          {%- if heaters_running != 'None' %} Pausing {{ heaters_running }}.
          {%- else %} No heaters active.
          {%- endif %}
        title: "ðŸªŸ {{ window_name }}"

    - service: notify.all_phones
      data:
        title: "ðŸªŸ {{ window_name }}"
        message: >-
          Open 30s.
          {%- if heaters_running != 'None' %} Paused: {{ heaters_running }}
          {%- else %} No heaters active
          {%- endif %}
        data:
          channel: "Critical"
          importance: max
          tag: "window_heater_safety"

# -----------------------------------------------------------------------------
# ALL WINDOWS CLOSED - RESUME HEATING
# Trigger: ANY contact sensor closes
# Condition: ALL 8 sensors must be closed AND guard flag is ON
# Action: Restore heaters to saved state, clear guard flag
# FIX: Only runs if heaters were previously turned off by window automation
#
# QUIET HOURS: Intentionally IGNORED for normal resume path.
# Reason: Informational alert that heaters are resuming - user wants to know
#         even at night that the safety situation is resolved.
#         Note: CO2-handoff branch DOES respect quiet hours (line ~1044).
#         (Confirmed 2026-01-10: User wants night alerts for heater state changes)
# -----------------------------------------------------------------------------
- id: all_windows_closed_resume_heaters
  alias: "All Windows Closed - Resume Heaters"
  description: "When all windows and doors are closed, turn heaters back on and notify"
  mode: single

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "off"

  condition:
    # Guard flag must be ON (heaters were turned off by window automation)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "on"
    # ALL windows/doors must be closed
    - condition: state
      entity_id: binary_sensor.bath_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.bed_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.kitchen_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_large_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_small_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_window_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
      state: "off"

  variables:
    heaters_restored: >
      {% set restored = [] %}
      {% if is_state('input_boolean.study_heater_was_on', 'on') %}
        {% set restored = restored + ['Study'] %}
      {% endif %}
      {% if is_state('input_boolean.living_inner_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Inner'] %}
      {% endif %}
      {% if is_state('input_boolean.living_outer_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Outer'] %}
      {% endif %}
      {% if is_state('input_boolean.bedroom_heater_was_on', 'on') %}
        {% set restored = restored + ['Bedroom'] %}
      {% endif %}
      {{ restored | join(', ') if restored else 'None' }}

  action:
    # CO2 HANDOFF: Check if CO2 is still high before restoring
    - if:
        - condition: numeric_state
          entity_id: sensor.hallway_co2_co2
          above: 1100
      then:
        # Transfer ownership to CO2 flag
        - service: input_boolean.turn_on
          target:
            entity_id: input_boolean.heaters_off_due_to_co2
        # Clear window flag
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_window
        # Notify (respect quiet hours)
        - if:
            - condition: template
              value_template: "{{ now().hour < 23 and now().hour >= 7 }}"
          then:
            - service: script.smart_tts_announce
              data:
                message: "Windows closed, but CO2 is still {{ states('sensor.hallway_co2_co2') | int }}. Heaters staying off."
                title: "ðŸªŸ Windows Closed, CO2 High"
        - service: notify.all_phones
          data:
            title: "ðŸªŸ Windows Closed, CO2 Still High"
            message: "CO2: {{ states('sensor.hallway_co2_co2') }} ppm. Heaters will resume when CO2 < 1100."
            data:
              channel: "Info"
              tag: "window_heater_safety"
        - stop: "CO2 still high - transferring to CO2 control"

    # Restore heaters to their saved states
    - service: climate.set_hvac_mode
      target:
        entity_id: climate.study_thermostat
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.study_heater_was_on', 'on') else 'off' }}"

    - service: climate.set_hvac_mode
      target:
        entity_id: climate.living_thermostat_inner
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.living_inner_heater_was_on', 'on') else 'off' }}"

    - service: climate.set_hvac_mode
      target:
        entity_id: climate.living_thermostat_outer
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.living_outer_heater_was_on', 'on') else 'off' }}"

    - service: climate.set_hvac_mode
      target:
        entity_id: climate.bed_thermostat
      data:
        hvac_mode: "{{ 'heat' if is_state('input_boolean.bedroom_heater_was_on', 'on') else 'off' }}"

    # Reset open_window flag on TRVs (TRVZB sets this when mode=off)
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Study] Thermostat/set"
        payload: '{"open_window": "OFF"}'
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Bed] Thermostat/set"
        payload: '{"open_window": "OFF"}'
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Living] Thermostat Inner/set"
        payload: '{"open_window": "OFF"}'
    - service: mqtt.publish
      data:
        topic: "zigbee2mqtt/[Living] Thermostat Outer/set"
        payload: '{"open_window": "OFF"}'

    # Delay for TRV to process mode change and open_window reset
    # TRVZB needs time between mode change and setpoint change (verified: 1s may be too short)
    - delay:
        seconds: 3

    # Restore saved setpoints (TRVZB drops setpoint to frost protection when turned off)
    - service: climate.set_temperature
      target:
        entity_id: climate.study_thermostat
      data:
        temperature: "{{ states('input_number.study_heater_saved_temp') | float(18) }}"
    - service: climate.set_temperature
      target:
        entity_id: climate.living_thermostat_inner
      data:
        temperature: "{{ states('input_number.living_inner_heater_saved_temp') | float(18) }}"
    - service: climate.set_temperature
      target:
        entity_id: climate.living_thermostat_outer
      data:
        temperature: "{{ states('input_number.living_outer_heater_saved_temp') | float(18) }}"
    - service: climate.set_temperature
      target:
        entity_id: climate.bed_thermostat
      data:
        temperature: "{{ states('input_number.bedroom_heater_saved_temp') | float(18) }}"

    # Clear the guard flag (ready for next window event)
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.heaters_off_due_to_window

    - delay:
        seconds: 2

    - service: script.smart_tts_announce
      data:
        message: >-
          Windows closed.
          {%- if heaters_restored != 'None' %} Resuming {{ heaters_restored }}.
          {%- endif %}
        title: "âœ… Windows Closed"

    - service: notify.all_phones
      data:
        title: "âœ… Windows Closed"
        message: >-
          {%- if heaters_restored != 'None' %}Resumed: {{ heaters_restored }}
          {%- else %}No heaters to resume
          {%- endif %}
        data:
          channel: "Info"
          importance: default
          tag: "window_heater_safety"

# -----------------------------------------------------------------------------
# MAIN DOOR OPEN TOO LONG - REPEAT ALERT
# Trigger: Main door open for more than 3 minutes
# Action: Repeat TTS + mobile alert every 5 minutes until closed
#
# QUIET HOURS: Intentionally IGNORED.
# Reason: Security alert - main door left open at 3am is a security concern.
#         User should be woken immediately.
#         (Confirmed 2026-01-10: User wants night alerts for security events)
# -----------------------------------------------------------------------------
- id: main_door_open_too_long
  alias: "Main Door Open Too Long - Repeat Alert"
  description: "If main door is open more than 3 minutes, alert every 5 minutes until closed"
  mode: single

  trigger:
    - platform: state
      entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "on"
      for:
        minutes: 3

  action:
    - repeat:
        while:
          - condition: state
            entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
            state: "on"
        sequence:
          - service: script.smart_tts_announce
            data:
              message: >
                Attention! The main door has been open for more than 3 minutes.
                Please close the main door.
              title: "ðŸšª Main Door Still Open"

          - service: notify.all_phones
            data:
              title: "ðŸšª Main Door Still Open!"
              message: "The main door has been open for more than 3 minutes. Please close it."
              data:
                channel: "Critical"
                importance: max
                tag: "main_door_open_alert"

          - delay:
              minutes: 5

# -----------------------------------------------------------------------------
# WINDOW OPEN COLD WEATHER ALERT
# Trigger: Any window/door open for 15 minutes when balcony temp < 18Â°C
# Action: TTS announcement on kitchen display every 2 minutes until closed
# Note: Independent of heater safety automations
#
# QUIET HOURS: Intentionally IGNORED.
# Reason: Comfort/safety alert - window open in cold weather causes heat loss.
#         User should be woken at night to close window and stay warm.
#         (Confirmed 2026-01-10: User wants night alerts for cold weather events)
# -----------------------------------------------------------------------------
- id: window_open_cold_weather_alert
  alias: "Window Open Cold Weather Alert"
  description: "Alert every 2 minutes when window open >15min and outdoor temp <18Â°C"
  mode: parallel
  max: 8

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "on"
      for:
        minutes: 15

  condition:
    - condition: numeric_state
      entity_id: sensor.balcony_temperature_humidity_temperature
      below: 18

  variables:
    window_name: >
      {% set names = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom Window',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom Window',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen Window',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large Window',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small Window',
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window',
        'binary_sensor.hallway_window_contact_sensor_main_door_contact': 'Main Door'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

  action:
    - repeat:
        while:
          - condition: template
            value_template: "{{ is_state(trigger.entity_id, 'on') }}"
          - condition: numeric_state
            entity_id: sensor.balcony_temperature_humidity_temperature
            below: 18
        sequence:
          - service: script.smart_tts_announce
            data:
              message: >
                Attention! {{ window_name }} has been open for a long time
                and it's {{ states('sensor.balcony_temperature_humidity_temperature') | round(0) }} degrees outside.
                Please close it to keep the apartment warm.
              title: "ðŸªŸ Window Open Cold"
          - delay:
              minutes: 2

# -----------------------------------------------------------------------------
# PREVENT HEATING IF WINDOW OPEN
# Trigger: Any thermostat enters "heating" state
# Condition: At least one window/door is open
# Action: Turn off that thermostat, warn user
# Note: This prevents heaters from starting while windows are open
# -----------------------------------------------------------------------------
- id: prevent_heating_if_window_open
  alias: "Prevent Heating If Window Open"
  description: "When any heater starts heating, check if windows are open. If yes, turn it off."
  mode: parallel
  max: 4

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: hvac_action
      to: "heating"

  condition:
    - condition: or
      conditions:
        - condition: state
          entity_id: binary_sensor.bath_window_contact_sensor_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.bed_window_contact_sensor_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.kitchen_window_contact_sensor_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.study_window_contact_sensor_large_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.study_window_contact_sensor_small_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.living_window_contact_sensor_window_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
          state: "on"
        - condition: state
          entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
          state: "on"

  variables:
    heater_name: >
      {% set names = {
        'climate.study_thermostat': 'Study',
        'climate.living_thermostat_inner': 'Living Inner',
        'climate.living_thermostat_outer': 'Living Outer',
        'climate.bed_thermostat': 'Bedroom'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

    # Map entity_id to helper IDs for state saving
    heater_id: >
      {% set ids = {
        'climate.study_thermostat': 'study',
        'climate.living_thermostat_inner': 'living_inner',
        'climate.living_thermostat_outer': 'living_outer',
        'climate.bed_thermostat': 'bedroom'
      } %}
      {{ ids.get(trigger.entity_id, 'unknown') }}

    bool_entity: "input_boolean.{{ heater_id }}_heater_was_on"
    number_entity: "input_number.{{ heater_id }}_heater_saved_temp"
    current_setpoint: "{{ state_attr(trigger.entity_id, 'temperature') | float(18) }}"

    open_windows: >
      {% set open = [] %}
      {% if is_state('binary_sensor.bath_window_contact_sensor_contact', 'on') %}
        {% set open = open + ['Bathroom'] %}
      {% endif %}
      {% if is_state('binary_sensor.bed_window_contact_sensor_contact', 'on') %}
        {% set open = open + ['Bedroom'] %}
      {% endif %}
      {% if is_state('binary_sensor.kitchen_window_contact_sensor_contact', 'on') %}
        {% set open = open + ['Kitchen'] %}
      {% endif %}
      {% if is_state('binary_sensor.study_window_contact_sensor_large_contact', 'on') %}
        {% set open = open + ['Study Large'] %}
      {% endif %}
      {% if is_state('binary_sensor.study_window_contact_sensor_small_contact', 'on') %}
        {% set open = open + ['Study Small'] %}
      {% endif %}
      {% if is_state('binary_sensor.living_window_contact_sensor_window_contact', 'on') %}
        {% set open = open + ['Living Window'] %}
      {% endif %}
      {% if is_state('binary_sensor.living_window_contact_sensor_balcony_door_contact', 'on') %}
        {% set open = open + ['Balcony Door'] %}
      {% endif %}
      {% if is_state('binary_sensor.hallway_window_contact_sensor_main_door_contact', 'on') %}
        {% set open = open + ['Main Door'] %}
      {% endif %}
      {{ open | join(', ') }}

  action:
    # -------------------------------------------------------------------------
    # FIX: Save THIS heater's state before turning off
    # NOTE: Do NOT set guard flag here - let window_open timer save ALL heaters
    # This prevents race condition where guard flag blocks window_open from saving
    # -------------------------------------------------------------------------
    - service: input_boolean.turn_on
      target:
        entity_id: "{{ bool_entity }}"

    - service: input_number.set_value
      target:
        entity_id: "{{ number_entity }}"
      data:
        value: "{{ current_setpoint }}"

    # Now turn off this specific heater
    - service: climate.set_hvac_mode
      target:
        entity_id: "{{ trigger.entity_id }}"
      data:
        hvac_mode: "off"

    - service: script.smart_tts_announce
      data:
        message: "{{ heater_name }} blocked. Close {{ open_windows }}."
        title: "ðŸš« {{ heater_name }} Blocked"

    - service: notify.all_phones
      data:
        title: "ðŸš« {{ heater_name }} Blocked"
        message: "Windows open: {{ open_windows }}"
        data:
          channel: "Critical"
          importance: high
          tag: "heater_blocked_windows"

# =============================================================================
# CO2-BASED HEATER CONTROL
# Purpose: Turn off heaters when CO2 is high (>1200 ppm) to avoid heating
#          air that will soon be vented. Window control takes priority.
# Thresholds: OFF at 1200 ppm, ON at 1100 ppm (100 ppm hysteresis)
# =============================================================================

# -----------------------------------------------------------------------------
# CO2 HIGH - TURN OFF ALL HEATERS
# Trigger: CO2 rises above 1200 ppm OR HA startup with CO2 > 1200
# Action: Save state (if not already saved), turn off heaters
# Priority: Window takes priority - do NOT save if window flag is ON
# -----------------------------------------------------------------------------
- id: co2_high_turn_off_heaters
  alias: "CO2 High - Turn Off All Heaters"
  description: "When CO2 exceeds 1200 ppm, turn off all heaters"
  mode: single
  max_exceeded: silent

  trigger:
    # Normal trigger: CO2 crosses threshold
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200
      id: threshold_crossed
    # Startup trigger: Check state on HA restart
    - platform: homeassistant
      event: start
      id: ha_startup

  condition:
    # For startup trigger, verify CO2 is actually high
    - condition: or
      conditions:
        - condition: trigger
          id: threshold_crossed
        - condition: and
          conditions:
            - condition: trigger
              id: ha_startup
            - condition: numeric_state
              entity_id: sensor.hallway_co2_co2
              above: 1200
    # CO2 flag must be OFF (not already handled)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"
    # CO2 override must NOT be active (user chose to ignore CO2 temporarily)
    - condition: state
      entity_id: input_boolean.co2_override_active
      state: "off"
    # At least one heater in 'heat' mode OR window flag is on
    - condition: or
      conditions:
        - condition: template
          value_template: >
            {{ states('climate.study_thermostat') == 'heat'
               or states('climate.living_thermostat_inner') == 'heat'
               or states('climate.living_thermostat_outer') == 'heat'
               or states('climate.bed_thermostat') == 'heat' }}
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_window
          state: "on"

  variables:
    window_owns_state: "{{ is_state('input_boolean.heaters_off_due_to_window', 'on') }}"
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"
    is_quiet_hours: "{{ now().hour >= 23 or now().hour < 7 }}"
    heaters_running: >
      {% set running = [] %}
      {% if state_attr('climate.study_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Study'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_inner', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Inner'] %}
      {% endif %}
      {% if state_attr('climate.living_thermostat_outer', 'hvac_action') == 'heating' %}
        {% set running = running + ['Living Outer'] %}
      {% endif %}
      {% if state_attr('climate.bed_thermostat', 'hvac_action') == 'heating' %}
        {% set running = running + ['Bedroom'] %}
      {% endif %}
      {{ running | join(', ') if running else 'None' }}

  action:
    # Set CO2 guard flag FIRST
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.heaters_off_due_to_co2

    # ONLY save state if window automation hasn't already saved it
    - if:
        - condition: template
          value_template: "{{ not window_owns_state }}"
      then:
        # SAVE current heater states
        # RACE CONDITION FIX v2 (2026-01-12): Use TIMESTAMP-BASED detection
        # If mode='off' but changed within last 60 seconds, treat as transient error â†’ save as ON
        # This catches the case where MQTT error flips state to OFF before this automation runs
        - service: "input_boolean.turn_{{ 'on' if states('climate.study_thermostat') == 'heat' or (states('climate.study_thermostat') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.study_thermostat.last_changed)) < 60) else 'off' }}"
          target:
            entity_id: input_boolean.study_heater_was_on
        - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_inner') == 'heat' or (states('climate.living_thermostat_inner') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_inner.last_changed)) < 60) else 'off' }}"
          target:
            entity_id: input_boolean.living_inner_heater_was_on
        - service: "input_boolean.turn_{{ 'on' if states('climate.living_thermostat_outer') == 'heat' or (states('climate.living_thermostat_outer') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_outer.last_changed)) < 60) else 'off' }}"
          target:
            entity_id: input_boolean.living_outer_heater_was_on
        - service: "input_boolean.turn_{{ 'on' if states('climate.bed_thermostat') == 'heat' or (states('climate.bed_thermostat') == 'off' and (as_timestamp(now()) - as_timestamp(states.climate.bed_thermostat.last_changed)) < 60) else 'off' }}"
          target:
            entity_id: input_boolean.bedroom_heater_was_on

        # SAVE current setpoints
        # RACE CONDITION FIX: Use max(current_setpoint, 18) to prevent saving 7Â°C frost protection
        - service: input_number.set_value
          target:
            entity_id: input_number.study_heater_saved_temp
          data:
            value: "{{ [state_attr('climate.study_thermostat', 'temperature') | float(18), 18] | max }}"
        - service: input_number.set_value
          target:
            entity_id: input_number.living_inner_heater_saved_temp
          data:
            value: "{{ [state_attr('climate.living_thermostat_inner', 'temperature') | float(18), 18] | max }}"
        - service: input_number.set_value
          target:
            entity_id: input_number.living_outer_heater_saved_temp
          data:
            value: "{{ [state_attr('climate.living_thermostat_outer', 'temperature') | float(18), 18] | max }}"
        - service: input_number.set_value
          target:
            entity_id: input_number.bedroom_heater_saved_temp
          data:
            value: "{{ [state_attr('climate.bed_thermostat', 'temperature') | float(18), 18] | max }}"

        # Turn off all heaters
        - service: climate.set_hvac_mode
          target:
            entity_id:
              - climate.study_thermostat
              - climate.living_thermostat_inner
              - climate.living_thermostat_outer
              - climate.bed_thermostat
          data:
            hvac_mode: "off"

    # TTS Announcement (respect quiet hours, uses fallback cascade)
    - if:
        - condition: template
          value_template: "{{ not is_quiet_hours }}"
      then:
        - service: script.smart_tts_announce
          data:
            message: >-
              CO2 is {{ co2_level }}. Heaters paused.
              {%- if heaters_running != 'None' %} Stopping {{ heaters_running }}.
              {%- endif %}
            title: "ðŸŒ«ï¸ CO2 High"

    # Mobile notification (always)
    - service: notify.all_phones
      data:
        title: "ðŸŒ«ï¸ CO2 High - Heaters Off"
        message: >-
          CO2: {{ co2_level }} ppm.
          {%- if heaters_running != 'None' %} Paused: {{ heaters_running }}
          {%- else %} No heaters were active
          {%- endif %}
        data:
          channel: "Critical"
          importance: max
          tag: "co2_heater_safety"

# -----------------------------------------------------------------------------
# CO2 LOW - RESUME HEATERS
# Trigger: CO2 drops below 1100 ppm OR sensor unavailable for 30 min
# Condition: CO2 flag is ON AND window flag is OFF
# Safety: Timeout fallback if sensor fails
# -----------------------------------------------------------------------------
- id: co2_low_resume_heaters
  alias: "CO2 Low - Resume Heaters"
  description: "When CO2 drops below 1100 ppm and windows closed, restore heaters"
  mode: single

  trigger:
    # Normal trigger: CO2 drops below threshold
    - platform: numeric_state
      entity_id: sensor.hallway_co2_co2
      below: 1100
      id: threshold_crossed
    # Safety trigger: HA startup check
    - platform: homeassistant
      event: start
      id: ha_startup
    # Fallback: Sensor unavailable for 30 minutes
    - platform: state
      entity_id: sensor.hallway_co2_co2
      to: "unavailable"
      for:
        minutes: 30
      id: sensor_timeout

  condition:
    # CO2 flag must be ON
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "on"
    # Window flag must be OFF (window guard takes precedence)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    # Note: Window closed checks moved to action block to allow handoff to window guard
    # For startup/normal trigger, verify CO2 is actually low
    # For timeout trigger, allow anyway (sensor failed)
    - condition: or
      conditions:
        - condition: trigger
          id: sensor_timeout
        - condition: and
          conditions:
            - condition: or
              conditions:
                - condition: trigger
                  id: threshold_crossed
                - condition: trigger
                  id: ha_startup
            - condition: numeric_state
              entity_id: sensor.hallway_co2_co2
              below: 1100

  variables:
    is_timeout: "{{ trigger.id == 'sensor_timeout' }}"
    is_quiet_hours: "{{ now().hour >= 23 or now().hour < 7 }}"
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) if not is_timeout else 'unavailable' }}"
    heaters_restored: >
      {% set restored = [] %}
      {% if is_state('input_boolean.study_heater_was_on', 'on') %}
        {% set restored = restored + ['Study'] %}
      {% endif %}
      {% if is_state('input_boolean.living_inner_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Inner'] %}
      {% endif %}
      {% if is_state('input_boolean.living_outer_heater_was_on', 'on') %}
        {% set restored = restored + ['Living Outer'] %}
      {% endif %}
      {% if is_state('input_boolean.bedroom_heater_was_on', 'on') %}
        {% set restored = restored + ['Bedroom'] %}
      {% endif %}
      {{ restored | join(', ') if restored else 'None' }}

  action:
    - choose:
        # Case 1: A window is open - transfer ownership to window guard
        # This fixes the bug where CO2 normalizes but dashboard still shows "High CO2"
        - conditions:
            - condition: or
              conditions:
                - condition: state
                  entity_id: binary_sensor.bath_window_contact_sensor_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.bed_window_contact_sensor_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.kitchen_window_contact_sensor_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.study_window_contact_sensor_large_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.study_window_contact_sensor_small_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.living_window_contact_sensor_window_contact
                  state: "on"
                - condition: state
                  entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
                  state: "on"
          sequence:
            # Transfer ownership to window guard
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.heaters_off_due_to_window
            - service: input_boolean.turn_off
              target:
                entity_id: input_boolean.heaters_off_due_to_co2
            # TTS notification (respect quiet hours, uses fallback cascade)
            - if:
                - condition: template
                  value_template: "{{ not is_quiet_hours }}"
              then:
                - service: script.smart_tts_announce
                  data:
                    message: "CO2 is now {{ co2_level }}. Air improved, but window still open. Heaters staying off."
                    title: "âœ… CO2 Normal"
            # Mobile notification
            - service: notify.all_phones
              data:
                title: "âœ… CO2 Normal (Window Open)"
                message: "CO2: {{ co2_level }} ppm. Window still open - heaters stay off until closed."
                data:
                  channel: "Info"
                  tag: "co2_heater_safety"

      # Default: All windows closed - resume heaters normally
      default:
        # Restore heaters
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.study_thermostat
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.study_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_inner
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.living_inner_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_outer
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.living_outer_heater_was_on', 'on') else 'off' }}"
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.bed_thermostat
          data:
            hvac_mode: "{{ 'heat' if is_state('input_boolean.bedroom_heater_was_on', 'on') else 'off' }}"

        # Reset open_window flag on TRVs
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Study] Thermostat/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Bed] Thermostat/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Living] Thermostat Inner/set"
            payload: '{"open_window": "OFF"}'
        - service: mqtt.publish
          data:
            topic: "zigbee2mqtt/[Living] Thermostat Outer/set"
            payload: '{"open_window": "OFF"}'

        - delay:
            seconds: 3

        # Restore setpoints
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: "{{ states('input_number.study_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: "{{ states('input_number.living_inner_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: "{{ states('input_number.living_outer_heater_saved_temp') | float(18) }}"
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: "{{ states('input_number.bedroom_heater_saved_temp') | float(18) }}"

        # Clear CO2 flag
        - service: input_boolean.turn_off
          target:
            entity_id: input_boolean.heaters_off_due_to_co2

        - delay:
            seconds: 2

        # TTS (respect quiet hours, uses fallback cascade)
        - if:
            - condition: template
              value_template: "{{ not is_quiet_hours }}"
          then:
            - service: script.smart_tts_announce
              data:
                message: >-
                  {% if is_timeout %}CO2 sensor timeout. Resuming heaters as safety fallback.
                  {%- if heaters_restored != 'None' %} Resuming {{ heaters_restored }}.{%- endif %}
                  {% else %}CO2 now {{ co2_level }}. Air improved.
                  {%- if heaters_restored != 'None' %} Resuming {{ heaters_restored }}.
                  {%- endif %}
                  {% endif %}
                title: "{% if is_timeout %}âš ï¸ CO2 Timeout{% else %}âœ… CO2 Normal{% endif %}"

        # Mobile notification
        - service: notify.all_phones
          data:
            title: "{% if is_timeout %}âš ï¸ CO2 Sensor Timeout{% else %}âœ… CO2 Normal{% endif %}"
            message: >-
              {% if is_timeout %}Sensor unavailable 30min. Resuming heaters.
              {% else %}CO2: {{ co2_level }} ppm.
              {%- if heaters_restored != 'None' %} Resumed: {{ heaters_restored }}
              {%- else %} No heaters to resume
              {%- endif %}
              {% endif %}
            data:
              channel: "{% if is_timeout %}Critical{% else %}Info{% endif %}"
              importance: "{% if is_timeout %}max{% else %}default{% endif %}"
              tag: "co2_heater_safety"

# -----------------------------------------------------------------------------
# PREVENT HEATING IF CO2 HIGH
# Trigger: Any thermostat enters "heating" state
# Condition: CO2 > 1200
# Action: Turn off that specific heater immediately
# Purpose: Catch manual overrides or race conditions
# -----------------------------------------------------------------------------
- id: prevent_heating_if_co2_high
  alias: "Prevent Heating If CO2 High"
  description: "If any heater starts heating while CO2 is high, turn it off immediately"
  mode: parallel
  max: 4

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: hvac_action
      to: "heating"

  condition:
    - condition: numeric_state
      entity_id: sensor.hallway_co2_co2
      above: 1200
    # CO2 override must NOT be active (user chose to ignore CO2 temporarily)
    - condition: state
      entity_id: input_boolean.co2_override_active
      state: "off"

  variables:
    heater_name: >
      {% set names = {
        'climate.study_thermostat': 'Study',
        'climate.living_thermostat_inner': 'Living Inner',
        'climate.living_thermostat_outer': 'Living Outer',
        'climate.bed_thermostat': 'Bedroom'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"

  action:
    # Turn off the specific heater
    - service: climate.set_hvac_mode
      target:
        entity_id: "{{ trigger.entity_id }}"
      data:
        hvac_mode: "off"

    - service: notify.all_phones
      data:
        title: "ðŸš« {{ heater_name }} Blocked (CO2)"
        message: "Heater tried to start but CO2 is {{ co2_level }} ppm. Blocked."
        data:
          channel: "Critical"
          importance: max
          tag: "co2_heater_block"

# =============================================================================
# TTS NOTIFICATION AUDIT LOGGING
# Purpose: Publish all TTS notifications to MQTT for dashboard logging
# =============================================================================

# -----------------------------------------------------------------------------
# TTS EVENT MQTT PUBLISHER
# Trigger: Any call to tts.google_translate_say service
# Action: Publish event details to dashboard/tts topic
# Fields: timestamp, message, devices, availability status
# -----------------------------------------------------------------------------
- id: tts_event_mqtt_publisher
  alias: "TTS Event MQTT Publisher"
  description: "Publishes all TTS notifications to MQTT for dashboard logging"
  mode: parallel
  max: 10

  trigger:
    - platform: event
      event_type: call_service
      event_data:
        domain: tts
        service: google_translate_say

  variables:
    devices: >
      {% set data = trigger.event.data.service_data %}
      {% if data.entity_id is string %}
        {{ [data.entity_id] }}
      {% else %}
        {{ data.entity_id | default([]) }}
      {% endif %}
    message: "{{ trigger.event.data.service_data.message | default('No message') }}"

    device_status: >
      {% set status = [] %}
      {% for device in devices %}
        {% set name = device | replace('media_player.', '') %}
        {% set state = states(device) %}
        {% set available = state not in ['unavailable', 'unknown'] %}
        {% set status = status + [{'device': name, 'available': available, 'state': state}] %}
      {% endfor %}
      {{ status }}

    all_available: >
      {{ device_status | selectattr('available', 'eq', true) | list | length == device_status | length }}

    any_available: >
      {{ device_status | selectattr('available', 'eq', true) | list | length > 0 }}

  action:
    - service: mqtt.publish
      data:
        topic: "dashboard/tts"
        payload: >
          {{
            {
              "timestamp": now().isoformat(),
              "event": "tts_call",
              "message": message,
              "devices": device_status,
              "success": any_available,
              "all_available": all_available,
              "automation": trigger.event.context.parent_id | default('manual')
            } | tojson
          }}
        retain: false

# =============================================================================
# MOBILE NOTIFICATION MQTT PUBLISHER
# Purpose: Log all mobile notifications to MQTT for dashboard history view
# Topic: dashboard/notify (non-retained)
# Note: Captures all notify.all_phones calls for timeline display
# =============================================================================
- id: mobile_notification_mqtt_publisher
  alias: "Mobile Notification MQTT Publisher"
  description: "Publishes all mobile notifications to MQTT for dashboard logging"
  mode: parallel
  max: 10

  trigger:
    - platform: event
      event_type: call_service
      event_data:
        domain: notify
        service: all_phones

  variables:
    service_data: "{{ trigger.event.data.service_data }}"
    title: "{{ service_data.title | default('Notification') }}"
    message: "{{ service_data.message | default('') }}"
    channel: "{{ service_data.data.channel | default('Default') if service_data.data is defined else 'Default' }}"
    importance: "{{ service_data.data.importance | default('default') if service_data.data is defined else 'default' }}"
    tag: "{{ service_data.data.tag | default('') if service_data.data is defined else '' }}"

  action:
    - service: mqtt.publish
      data:
        topic: "dashboard/notify"
        payload: >
          {{
            {
              "timestamp": now().isoformat(),
              "type": "mobile",
              "title": title,
              "message": message,
              "channel": channel,
              "importance": importance,
              "tag": tag,
              "automation": trigger.event.context.parent_id | default('manual')
            } | tojson
          }}
        retain: false

# =============================================================================
# HEATER GUARD STATE MQTT PUBLISHER
# Purpose: Publish heater pause state to MQTT for dashboard banner display
# Topic: dashboard/heater-guard/combined (retained)
# =============================================================================

# -----------------------------------------------------------------------------
# HEATER GUARD COMBINED STATE PUBLISHER
# Trigger: Guard flags change OR window sensors change while guard active
# Action: Publish combined state with open windows list and CO2 level
# Note: Retained message so dashboard shows state on page load
# -----------------------------------------------------------------------------
- id: heater_guard_combined_publisher
  alias: "Heater Guard Combined State Publisher"
  description: "Publishes combined heater pause state with window/CO2 context to MQTT"
  mode: single
  max_exceeded: silent

  trigger:
    # Guard flag changes
    - platform: state
      entity_id:
        - input_boolean.heaters_off_due_to_window
        - input_boolean.heaters_off_due_to_co2
      id: guard_change
    # Window state changes (to update open window list in real-time)
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      id: window_change
    # CO2 sensor changes (to update CO2 level in real-time when CO2 guard active)
    - platform: state
      entity_id: sensor.hallway_co2_co2
      id: co2_change

  condition:
    # Only publish if at least one guard is active
    - condition: or
      conditions:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_window
          state: "on"
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"

  variables:
    window_guard: "{{ is_state('input_boolean.heaters_off_due_to_window', 'on') }}"
    co2_guard: "{{ is_state('input_boolean.heaters_off_due_to_co2', 'on') }}"
    co2_level: "{{ states('sensor.hallway_co2_co2') | int(0) }}"
    open_windows: >
      {% set ns = namespace(open=[]) %}
      {% set windows = {
        'binary_sensor.bath_window_contact_sensor_contact': 'Bathroom',
        'binary_sensor.bed_window_contact_sensor_contact': 'Bedroom',
        'binary_sensor.kitchen_window_contact_sensor_contact': 'Kitchen',
        'binary_sensor.study_window_contact_sensor_large_contact': 'Study Large',
        'binary_sensor.study_window_contact_sensor_small_contact': 'Study Small',
        'binary_sensor.living_window_contact_sensor_window_contact': 'Living Window',
        'binary_sensor.living_window_contact_sensor_balcony_door_contact': 'Balcony Door',
        'binary_sensor.hallway_window_contact_sensor_main_door_contact': 'Main Door'
      } %}
      {% for entity, name in windows.items() %}
        {% if is_state(entity, 'on') %}
          {% set ns.open = ns.open + [name] %}
        {% endif %}
      {% endfor %}
      {{ ns.open }}

  action:
    - service: mqtt.publish
      data:
        topic: dashboard/heater-guard/combined
        payload: >
          {{
            {
              "active": true,
              "reason": 'window' if window_guard else 'co2',
              "window_guard": window_guard,
              "co2_guard": co2_guard,
              "co2_level": co2_level,
              "open_windows": open_windows,
              "timestamp": now().isoformat(),
              "changed_at": now().timestamp() | int
            } | tojson
          }}
        retain: true

# -----------------------------------------------------------------------------
# HEATER GUARD CLEAR ON RESUME
# Trigger: Either guard flag turns OFF
# Condition: BOTH flags must be OFF
# Action: Publish inactive state to clear the retained message
# -----------------------------------------------------------------------------
- id: heater_guard_clear_on_resume
  alias: "Heater Guard Clear on Resume"
  description: "Publishes inactive heater guard state when all guards are cleared"
  mode: single

  trigger:
    - platform: state
      entity_id:
        - input_boolean.heaters_off_due_to_window
        - input_boolean.heaters_off_due_to_co2
      to: "off"

  condition:
    # Both guards must be off
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"

  action:
    - service: mqtt.publish
      data:
        topic: dashboard/heater-guard/combined
        payload: >
          {{
            {
              "active": false,
              "reason": "none",
              "window_guard": false,
              "co2_guard": false,
              "co2_level": states('sensor.hallway_co2_co2') | int(0),
              "open_windows": [],
              "timestamp": now().isoformat(),
              "changed_at": now().timestamp() | int
            } | tojson
          }}
        retain: true

# -----------------------------------------------------------------------------
# WATCHDOG RECOVERY - PERIODIC RESUME CHECK
# Purpose: Safety net for heater-watchdog - catches cases where the event-driven
#          resume automation misses the window/door close event.
# Trigger: Every minute
# Condition: Guard flag is ON AND all windows/doors are closed
# Action: Trigger the existing resume automation
# -----------------------------------------------------------------------------
- id: watchdog_recovery_resume_check
  alias: "Watchdog Recovery - Periodic Resume Check"
  description: >
    Safety net that runs every minute. If heater guard flag (window OR CO2) is ON
    but all windows/doors are closed and CO2 is acceptable, triggers the appropriate
    resume automation. This catches edge cases where the event-driven resume missed.
  mode: single

  trigger:
    - platform: time_pattern
      minutes: "/1"

  condition:
    # EITHER guard flag must be ON (heaters were intentionally turned off)
    - condition: or
      conditions:
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_window
          state: "on"
        - condition: state
          entity_id: input_boolean.heaters_off_due_to_co2
          state: "on"
    # AND all windows/doors must be closed
    - condition: state
      entity_id: binary_sensor.bath_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.bed_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.kitchen_window_contact_sensor_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_large_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.study_window_contact_sensor_small_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_window_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.living_window_contact_sensor_balcony_door_contact
      state: "off"
    - condition: state
      entity_id: binary_sensor.hallway_window_contact_sensor_main_door_contact
      state: "off"

  action:
    # Check which guard is active and call the appropriate resume automation
    - choose:
        # Case 1: Window guard is active â†’ use window resume automation
        - conditions:
            - condition: state
              entity_id: input_boolean.heaters_off_due_to_window
              state: "on"
          sequence:
            - service: system_log.write
              data:
                message: "Watchdog Recovery: Window guard ON but all windows closed - triggering window resume"
                level: info
            - service: automation.trigger
              target:
                entity_id: automation.all_windows_closed_resume_heaters

        # Case 2: CO2 guard is active (and window guard is off) AND CO2 is acceptable
        - conditions:
            - condition: state
              entity_id: input_boolean.heaters_off_due_to_co2
              state: "on"
            - condition: state
              entity_id: input_boolean.heaters_off_due_to_window
              state: "off"
            - condition: numeric_state
              entity_id: sensor.hallway_co2_co2
              below: 1100
          sequence:
            - service: system_log.write
              data:
                message: "Watchdog Recovery: CO2 guard ON but CO2 now {{ states('sensor.hallway_co2_co2') }} ppm (< 1100) - triggering CO2 resume"
                level: info
            - service: automation.trigger
              target:
                entity_id: automation.co2_low_resume_heaters

      # Default: Log that conditions weren't met for resume
      default:
        - service: system_log.write
          data:
            message: >
              Watchdog Recovery: Guard active but resume conditions not met.
              Window guard: {{ states('input_boolean.heaters_off_due_to_window') }},
              CO2 guard: {{ states('input_boolean.heaters_off_due_to_co2') }},
              CO2 level: {{ states('sensor.hallway_co2_co2') }} ppm
            level: debug

# =============================================================================
# HEATER TEMPERATURE SAFETY LIMITS
# Purpose: Prevent excessive heating with hard caps
# Safety Rules:
#   1. ALL heaters: Max 22Â°C at all times
#   2. BEDROOM only: Max 17Â°C during night hours (23:00 - 06:00)
# =============================================================================

# -----------------------------------------------------------------------------
# HEATER SAFETY - DYNAMIC TEMPERATURE CAP (22Â°C normal, 25Â°C boost)
# Trigger: Any thermostat setpoint changes
# Action: Cap to 22Â°C normally, or 25Â°C during dashboard boost mode
# Why: Prevent excessive heating while allowing boost feature flexibility
# Note: Checks input_datetime.{thermostat_id}_boost_end to determine boost state
# Important: Variables are evaluated AFTER condition, so all logic is in action
# -----------------------------------------------------------------------------
- id: heater_safety_max_22c_cap
  alias: "Heater Safety - Temperature Cap (22Â°C normal, 25Â°C boost)"
  description: "Cap thermostats to 22Â°C normally, or 25Â°C during dashboard boost"
  mode: parallel
  max: 4

  trigger:
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: temperature

  # No condition here - all logic is in action section because variables
  # are only available after condition passes

  variables:
    # Map climate entity to thermostat_id for boost lookup
    thermostat_id: >
      {% set mapping = {
        'climate.study_thermostat': 'study',
        'climate.living_thermostat_inner': 'living_inner',
        'climate.living_thermostat_outer': 'living_outer',
        'climate.bed_thermostat': 'bedroom'
      } %}
      {{ mapping.get(trigger.entity_id, '') }}

    # Check if per-thermostat boost is active (input_datetime is in the future)
    boost_end_entity: "input_datetime.{{ thermostat_id }}_boost_end"
    per_thermostat_boost_active: >
      {{ thermostat_id != ''
         and states(boost_end_entity) not in ['unknown', 'unavailable']
         and as_timestamp(states(boost_end_entity)) > as_timestamp(now()) }}

    # Check if GLOBAL boost mode is active (applies to all thermostats)
    global_boost_active: >
      {{ states('input_datetime.global_boost_end') not in ['unknown', 'unavailable']
         and as_timestamp(states('input_datetime.global_boost_end')) > as_timestamp(now()) }}

    # Boost is active if EITHER per-thermostat OR global boost mode is on
    boost_active: "{{ per_thermostat_boost_active or global_boost_active }}"

    # Dynamic cap: 25Â°C if any boost active, 22Â°C otherwise
    max_temp: "{{ 25 if boost_active else 22 }}"

    # Current temperature from trigger
    current_temp: "{{ trigger.to_state.attributes.temperature | float(0) }}"

    # For logging/notification
    heater_name: >
      {% set names = {
        'climate.study_thermostat': 'Study',
        'climate.living_thermostat_inner': 'Living Inner',
        'climate.living_thermostat_outer': 'Living Outer',
        'climate.bed_thermostat': 'Bedroom'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}

  action:
    # Only cap if temperature exceeds the dynamic max
    - if:
        - condition: template
          value_template: >
            {{ trigger.to_state.attributes.temperature is defined
               and current_temp > max_temp | int }}
      then:
        # Cap to dynamic max (22 or 25)
        - service: climate.set_temperature
          target:
            entity_id: "{{ trigger.entity_id }}"
          data:
            temperature: "{{ max_temp }}"

        # Audit notification
        - service: notify.all_phones
          data:
            title: "ðŸš« {{ heater_name }} Capped to {{ max_temp }}Â°C"
            message: >
              Attempted: {{ current_temp }}Â°C â†’ Capped to {{ max_temp }}Â°C
              {% if boost_active %}(Boost mode - higher cap allowed){% endif %}
              at {{ now().strftime('%H:%M:%S') }}
            data:
              channel: "Safety"
              importance: high
              tag: "heater_safety_cap"

# -----------------------------------------------------------------------------
# TEMPERATURE-REACHED ENERGY CAP
# Room temp reaches 21Â°C â†’ lower THAT room's setpoint to 19Â°C
# (numeric_state above: 20.99 â€” strict >, so first reading >= 21.0 fires)
# Dual trigger: numeric_state (crossing) + state (setpoint re-raise catch)
#
# Safeguards:
#   Loop prevention: setpoint > 19 (our set_temperature(19) re-fires, but 19 > 19 = false)
#   No-change filter: Trigger B skips entity refreshes where setpoint didn't change
#                     (same pattern as thermostat_setpoint_changed_audit)
#   Guard grace period: 30s cooldown after window/CO2 guard clears, so
#                       resume-then-immediately-cap doesn't confuse users
# See: configs/homeassistant/CLAUDE.md "Temperature-Reached Energy Cap"
# -----------------------------------------------------------------------------
- id: temperature_reached_energy_cap
  alias: "Temperature Reached - Energy Cap (21Â°C room â†’ 19Â°C setpoint)"
  description: >
    When a room's actual temperature reaches 21Â°C and the setpoint is above 19Â°C,
    automatically lower ONLY THAT ROOM's setpoint to 19Â°C to save energy.
    Uses dual triggers for complete coverage with loop prevention.
  mode: parallel
  max: 4

  trigger:
    # Trigger A: room temp reaches 21Â°C (above: 20.99 so first reading >= 21.0 fires)
    #   Why 20.99 not 21? HA numeric_state is strict >, and thermostats report
    #   at variable precision (0.1Â°C seen). above: 20.99 fires at 21.0+ without
    #   creating a dead zone where trigger fires at 20.6 but condition blocks.
    - platform: numeric_state
      entity_id: climate.study_thermostat
      attribute: current_temperature
      above: 20.99
      id: room_temp
    - platform: numeric_state
      entity_id: climate.living_thermostat_inner
      attribute: current_temperature
      above: 20.99
      id: room_temp
    - platform: numeric_state
      entity_id: climate.living_thermostat_outer
      attribute: current_temperature
      above: 20.99
      id: room_temp
    - platform: numeric_state
      entity_id: climate.bed_thermostat
      attribute: current_temperature
      above: 20.99
      id: room_temp

    # Trigger B: setpoint changes while room already >=21Â°C (re-raise catch)
    - platform: state
      entity_id:
        - climate.study_thermostat
        - climate.living_thermostat_inner
        - climate.living_thermostat_outer
        - climate.bed_thermostat
      attribute: temperature
      id: setpoint_change

  variables:
    energy_cap_setpoint: 19
    room_temp_threshold: 21
    heater_name: >
      {% set names = {
        'climate.study_thermostat': 'Study',
        'climate.living_thermostat_inner': 'Living Inner',
        'climate.living_thermostat_outer': 'Living Outer',
        'climate.bed_thermostat': 'Bedroom'
      } %}
      {{ names.get(trigger.entity_id, trigger.entity_id) }}
    current_setpoint: "{{ state_attr(trigger.entity_id, 'temperature') | float(0) }}"
    room_temp: "{{ state_attr(trigger.entity_id, 'current_temperature') | float(0) }}"

  action:
    - if:
        - condition: template
          value_template: >
            {{ current_setpoint > energy_cap_setpoint
               and room_temp >= room_temp_threshold
               and states(trigger.entity_id) == 'heat'
               and not is_state('input_boolean.heaters_off_due_to_window', 'on')
               and not is_state('input_boolean.heaters_off_due_to_co2', 'on')
               and (trigger.id == 'room_temp'
                    or (trigger.from_state.attributes.temperature is defined
                        and trigger.to_state.attributes.temperature is defined
                        and trigger.from_state.attributes.temperature != trigger.to_state.attributes.temperature))
               and (as_timestamp(now()) - (as_timestamp(states.input_boolean.heaters_off_due_to_window.last_changed) | default(as_timestamp(now())))) > 30
               and (as_timestamp(now()) - (as_timestamp(states.input_boolean.heaters_off_due_to_co2.last_changed) | default(as_timestamp(now())))) > 30 }}
      then:
        - service: climate.set_temperature
          target:
            entity_id: "{{ trigger.entity_id }}"
          data:
            temperature: "{{ energy_cap_setpoint }}"

        - service: notify.all_phones
          data:
            title: "âš¡ {{ heater_name }} Energy Cap"
            message: >
              Room reached {{ room_temp | int }}Â°C.
              Setpoint lowered: {{ current_setpoint | int }}Â°C â†’ {{ energy_cap_setpoint }}Â°C
              to save energy. Raise manually if needed.
            data:
              channel: "Energy"
              importance: default
              tag: "energy_cap_{{ heater_name | lower | replace(' ', '_') }}"

        # TTS (quiet hours 23:00-07:00)
        - if:
            - condition: template
              value_template: "{{ now().hour >= 7 and now().hour < 23 }}"
          then:
            - service: script.smart_tts_announce
              data:
                message: >
                  {{ heater_name }} room is warm at {{ room_temp | int }} degrees.
                  Lowering to {{ energy_cap_setpoint }} to save energy.
                title: "âš¡ Energy Cap"

# -----------------------------------------------------------------------------
# TEMPERATURE-REACHED ENERGY CAP - STARTUP CHECK
# Purpose: On HA startup, check if any room is already warm with high setpoint
# Why: numeric_state triggers only fire on CROSSING. If HA restarts while
#      room is already >21Â°C, the crossing event was missed.
# Pattern: Same as heater_safety_22c_startup_check
# -----------------------------------------------------------------------------
- id: temperature_reached_energy_cap_startup
  alias: "Temperature Reached Energy Cap - Startup Check"
  description: "On HA startup, apply energy cap to any warm rooms with high setpoints"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  action:
    - delay:
        seconds: 30

    - variables:
        energy_cap_setpoint: 19
        room_temp_threshold: 21
        guards_active: >
          {{ is_state('input_boolean.heaters_off_due_to_window', 'on')
             or is_state('input_boolean.heaters_off_due_to_co2', 'on')
             or (as_timestamp(now()) - (as_timestamp(states.input_boolean.heaters_off_due_to_window.last_changed) | default(as_timestamp(now())))) < 30
             or (as_timestamp(now()) - (as_timestamp(states.input_boolean.heaters_off_due_to_co2.last_changed) | default(as_timestamp(now())))) < 30 }}
        study_needs_cap: >
          {{ states('climate.study_thermostat') == 'heat'
             and (state_attr('climate.study_thermostat', 'current_temperature') | float(0)) >= room_temp_threshold
             and (state_attr('climate.study_thermostat', 'temperature') | float(0)) > energy_cap_setpoint }}
        living_inner_needs_cap: >
          {{ states('climate.living_thermostat_inner') == 'heat'
             and (state_attr('climate.living_thermostat_inner', 'current_temperature') | float(0)) >= room_temp_threshold
             and (state_attr('climate.living_thermostat_inner', 'temperature') | float(0)) > energy_cap_setpoint }}
        living_outer_needs_cap: >
          {{ states('climate.living_thermostat_outer') == 'heat'
             and (state_attr('climate.living_thermostat_outer', 'current_temperature') | float(0)) >= room_temp_threshold
             and (state_attr('climate.living_thermostat_outer', 'temperature') | float(0)) > energy_cap_setpoint }}
        bedroom_needs_cap: >
          {{ states('climate.bed_thermostat') == 'heat'
             and (state_attr('climate.bed_thermostat', 'current_temperature') | float(0)) >= room_temp_threshold
             and (state_attr('climate.bed_thermostat', 'temperature') | float(0)) > energy_cap_setpoint }}
        any_needs_cap: >
          {{ not guards_active
             and (study_needs_cap or living_inner_needs_cap
                  or living_outer_needs_cap or bedroom_needs_cap) }}

    - condition: template
      value_template: "{{ any_needs_cap }}"

    - if:
        - condition: template
          value_template: "{{ study_needs_cap }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: "{{ energy_cap_setpoint }}"

    - if:
        - condition: template
          value_template: "{{ living_inner_needs_cap }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: "{{ energy_cap_setpoint }}"

    - if:
        - condition: template
          value_template: "{{ living_outer_needs_cap }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: "{{ energy_cap_setpoint }}"

    - if:
        - condition: template
          value_template: "{{ bedroom_needs_cap }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: "{{ energy_cap_setpoint }}"

    - service: notify.all_phones
      data:
        title: "âš¡ Energy Cap (Startup)"
        message: >
          HA startup energy cap applied:
          {%- set capped = [] %}
          {%- if study_needs_cap %}{% set capped = capped + ['Study'] %}{% endif %}
          {%- if living_inner_needs_cap %}{% set capped = capped + ['Living Inner'] %}{% endif %}
          {%- if living_outer_needs_cap %}{% set capped = capped + ['Living Outer'] %}{% endif %}
          {%- if bedroom_needs_cap %}{% set capped = capped + ['Bedroom'] %}{% endif %}
          {{ capped | join(', ') }} â†’ setpoint lowered to {{ energy_cap_setpoint }}Â°C
          (rooms already above {{ room_temp_threshold }}Â°C)
        data:
          channel: "Energy"
          importance: default
          tag: "energy_cap_startup"

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - START (23:00)
# Trigger: Time reaches 23:00
# Action: Save current setpoint, cap to 17Â°C if above
# Edge cases:
#   - Bedroom off at 23:00 â†’ Save 17Â°C (safe default), no cap needed
#   - Bedroom already <= 17Â°C â†’ Save current, no cap needed
#   - Window/CO2 guard active â†’ Still save and cap (heater will restore when guard clears)
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_start
  alias: "Bedroom Night Mode - Start (23:00)"
  description: "At 23:00, save bedroom setpoint and cap to 17Â°C"
  mode: single

  trigger:
    - platform: time
      at: "23:00:00"

  condition:
    # Night mode must not already be active (shouldn't happen, but safety check)
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "off"

  variables:
    current_setpoint: >
      {{ state_attr('climate.bed_thermostat', 'temperature') | float(17) }}
    heater_mode: "{{ states('climate.bed_thermostat') }}"
    needs_capping: "{{ current_setpoint > 17 and heater_mode == 'heat' }}"

  action:
    # Set night mode flag FIRST
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Save current setpoint (even if off - saves what it was set to)
    # If heater is off, save 17 as safe default for morning restore
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_pre_night_setpoint
      data:
        value: >
          {% if heater_mode == 'off' %}
            17
          {% else %}
            {{ current_setpoint }}
          {% endif %}

    # Cap to 17Â°C if currently above and heater is on
    - if:
        - condition: template
          value_template: "{{ needs_capping }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 17

        # Notification only when actually capped
        - service: notify.all_phones
          data:
            title: "ðŸŒ™ Bedroom Night Mode"
            message: >
              Capped {{ current_setpoint }}Â°C â†’ 17Â°C for sleep.
              Will restore at 06:00.
            data:
              channel: "Info"
              importance: default
              tag: "bedroom_night_mode"
      else:
        # Silent start if no capping needed
        - service: notify.all_phones
          data:
            title: "ðŸŒ™ Bedroom Night Mode"
            message: >
              {% if heater_mode == 'off' %}
                Bedroom heater is off. Night mode monitoring active.
              {% else %}
                Already at {{ current_setpoint }}Â°C (â‰¤17Â°C). No change needed.
              {% endif %}
            data:
              channel: "Info"
              importance: low
              tag: "bedroom_night_mode"

    # Publish state to MQTT for dashboard (after either branch)
    - service: mqtt.publish
      data:
        topic: "dashboard/bedroom-night-mode"
        retain: true
        payload: '{"active": true, "override_active": false, "override_expires": null}'

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - ENFORCEMENT
# Trigger: Bedroom setpoint changes during night hours (23:00-06:00)
# Condition: Night mode flag is ON AND setpoint > 17Â°C
# Action: Cap back to 17Â°C
# Why: Prevents manual override from bypassing night mode
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_enforcement
  alias: "Bedroom Night Mode - Enforcement"
  description: "During night mode, cap bedroom to 17Â°C if changed to above"
  mode: single

  trigger:
    - platform: state
      entity_id: climate.bed_thermostat
      attribute: temperature

  condition:
    # Night mode must be active
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "on"
    # Heater must be in heat mode
    - condition: state
      entity_id: climate.bed_thermostat
      state: "heat"
    # Setpoint must be above 17Â°C
    - condition: template
      value_template: >
        {{ trigger.to_state.attributes.temperature is defined
           and trigger.to_state.attributes.temperature | float(0) > 17 }}

  variables:
    attempted_temp: "{{ trigger.to_state.attributes.temperature | float(0) }}"

  action:
    # Cap back to 17Â°C
    - service: climate.set_temperature
      target:
        entity_id: climate.bed_thermostat
      data:
        temperature: 17

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸŒ™ Bedroom Night Cap"
        message: >
          Attempted {{ attempted_temp }}Â°C during night mode.
          Capped to 17Â°C (until 06:00).
        data:
          channel: "Safety"
          importance: high
          tag: "bedroom_night_enforcement"

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - END (06:00)
# Trigger: Time reaches 06:00
# Action: Restore saved setpoint from before night mode
# Edge cases:
#   - Heater was off at 23:00 â†’ Restores to 17Â°C (safe default)
#   - Heater is currently off â†’ Restore setpoint anyway (for when turned on)
#   - Window guard active â†’ Still restore (will be overwritten by guard restore if needed)
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_end
  alias: "Bedroom Night Mode - End (06:00)"
  description: "At 06:00, restore bedroom setpoint from before night mode"
  mode: single

  trigger:
    - platform: time
      at: "06:00:00"

  condition:
    # Night mode must be active
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "on"

  variables:
    saved_setpoint: "{{ states('input_number.bedroom_pre_night_setpoint') | float(17) }}"
    heater_mode: "{{ states('climate.bed_thermostat') }}"

  action:
    # Clear night mode flag FIRST
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Restore setpoint (only if heater is in heat mode)
    - if:
        - condition: template
          value_template: "{{ heater_mode == 'heat' }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: "{{ saved_setpoint }}"

    # Notification
    - service: notify.all_phones
      data:
        title: "â˜€ï¸ Bedroom Night Mode Ended"
        message: >
          {% if heater_mode == 'heat' %}
            Restored to {{ saved_setpoint }}Â°C
          {% else %}
            Heater is off. Saved setpoint {{ saved_setpoint }}Â°C ready when turned on.
          {% endif %}
        data:
          channel: "Info"
          importance: default
          tag: "bedroom_night_mode"

    # Publish state to MQTT for dashboard (night mode ended)
    - service: mqtt.publish
      data:
        topic: "dashboard/bedroom-night-mode"
        retain: true
        payload: '{"active": false, "override_active": false, "override_expires": null}'

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - HA STARTUP HANDLER
# Trigger: Home Assistant starts during night hours (23:00-06:00)
# Condition: Night mode flag is OFF (wasn't properly set before restart)
# Action: Activate night mode, cap if needed
# Why: Handles HA restart during night hours
# -----------------------------------------------------------------------------
- id: bedroom_night_mode_startup_check
  alias: "Bedroom Night Mode - HA Startup Check"
  description: "If HA restarts during night hours, ensure night mode is active"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  condition:
    # Must be during night hours (23:00-05:59)
    - condition: time
      after: "23:00:00"
      before: "06:00:00"
    # Night mode must not already be active
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "off"

  variables:
    current_setpoint: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(17) }}"
    heater_mode: "{{ states('climate.bed_thermostat') }}"

  action:
    # Set night mode flag
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Save current setpoint (best effort - may not be pre-night value)
    - service: input_number.set_value
      target:
        entity_id: input_number.bedroom_pre_night_setpoint
      data:
        value: "{{ current_setpoint if heater_mode == 'heat' else 17 }}"

    # Cap if needed
    - if:
        - condition: template
          value_template: "{{ current_setpoint > 17 and heater_mode == 'heat' }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 17

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸŒ™ Night Mode Activated (Restart)"
        message: >
          HA restarted during night hours. Bedroom night mode activated.
          {% if current_setpoint > 17 and heater_mode == 'heat' %}
            Capped {{ current_setpoint }}Â°C â†’ 17Â°C.
          {% endif %}
        data:
          channel: "Info"
          importance: default
          tag: "bedroom_night_mode"

# -----------------------------------------------------------------------------
# BEDROOM NIGHT MODE - OVERRIDE EXPIRES
# Trigger: Time matches input_datetime.bedroom_night_override_end
# Condition: Override is active (night mode flag is OFF) AND still in night hours
# Action: Re-enable 17Â°C cap, publish to MQTT
# Why: Auto-restore night mode after 90-minute dashboard override
# -----------------------------------------------------------------------------
- id: bedroom_night_override_expires
  alias: "Bedroom Night Override - Expires"
  description: "Re-enable 17Â°C cap when dashboard override timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.bedroom_night_override_end

  condition:
    # Only if override is actually active (night mode is off)
    - condition: state
      entity_id: input_boolean.bedroom_night_mode_active
      state: "off"
    # Only during night hours
    - condition: time
      after: "23:00:00"
      before: "06:00:00"

  action:
    # Re-enable night mode
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.bedroom_night_mode_active

    # Cap bedroom back to 17Â°C if above
    - if:
        - condition: template
          value_template: >
            {{ state_attr('climate.bed_thermostat', 'temperature') | float(0) > 17 }}
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 17

    # Clear expiry datetime (reset to epoch)
    - service: input_datetime.set_datetime
      target:
        entity_id: input_datetime.bedroom_night_override_end
      data:
        datetime: "1970-01-01 00:00:00"

    # Publish state to MQTT for dashboard
    - service: mqtt.publish
      data:
        topic: "dashboard/bedroom-night-mode"
        retain: true
        payload: '{"active": true, "override_active": false, "override_expires": null}'

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸŒ™ Night Mode Restored"
        message: "Override expired. 17Â°C cap re-enabled."
        data:
          channel: "Info"
          importance: default
          tag: "bedroom_night_override"

# -----------------------------------------------------------------------------
# HEATER SAFETY - 22Â°C CAP ON HA STARTUP
# Trigger: Home Assistant starts
# Action: Check all thermostats, cap any above 22Â°C
# Why: Catches thermostats that were set above 22Â°C before automation existed
# -----------------------------------------------------------------------------
- id: heater_safety_22c_startup_check
  alias: "Heater Safety - 22Â°C Cap on HA Startup"
  description: "On HA startup, check all thermostats and cap any above 22Â°C"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  variables:
    study_temp: "{{ state_attr('climate.study_thermostat', 'temperature') | float(0) }}"
    living_inner_temp: "{{ state_attr('climate.living_thermostat_inner', 'temperature') | float(0) }}"
    living_outer_temp: "{{ state_attr('climate.living_thermostat_outer', 'temperature') | float(0) }}"
    bed_temp: "{{ state_attr('climate.bed_thermostat', 'temperature') | float(0) }}"
    any_above_22: "{{ study_temp > 22 or living_inner_temp > 22 or living_outer_temp > 22 or bed_temp > 22 }}"

  condition:
    # Only run if at least one thermostat is above 22Â°C
    - condition: template
      value_template: "{{ any_above_22 }}"

  action:
    # Cap each thermostat if above 22Â°C
    - if:
        - condition: template
          value_template: "{{ study_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: 22

    - if:
        - condition: template
          value_template: "{{ living_inner_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: 22

    - if:
        - condition: template
          value_template: "{{ living_outer_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: 22

    - if:
        - condition: template
          value_template: "{{ bed_temp > 22 }}"
      then:
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 22

    # Single notification with all capped heaters
    - service: notify.all_phones
      data:
        title: "ðŸš« 22Â°C Cap Enforced (Startup)"
        message: >
          HA startup check capped:
          {%- set capped = [] %}
          {%- if study_temp > 22 %}{% set capped = capped + ['Study ' ~ study_temp|int ~ 'Â°C'] %}{% endif %}
          {%- if living_inner_temp > 22 %}{% set capped = capped + ['Living Inner ' ~ living_inner_temp|int ~ 'Â°C'] %}{% endif %}
          {%- if living_outer_temp > 22 %}{% set capped = capped + ['Living Outer ' ~ living_outer_temp|int ~ 'Â°C'] %}{% endif %}
          {%- if bed_temp > 22 %}{% set capped = capped + ['Bedroom ' ~ bed_temp|int ~ 'Â°C'] %}{% endif %}
          {{ capped | join(', ') }} â†’ 22Â°C
        data:
          channel: "Safety"
          importance: high
          tag: "heater_safety_startup"

# =============================================================================
# CIRCADIAN LIGHTING AUTOMATIONS
# Purpose: Automatic brightness and color temperature scheduling for IKEA lights
# Lights: light.study_ikea_light, light.living_ikea_light
# Color Temp Range: 320 mired (neutral) to 454 mired (warmest)
# Brightness Range: 1% (night) to 100% (day)
#
# Schedule:
#   Night (22:00-06:00): 1% brightness, 454 mired (2200K warmest)
#   Sunrise (06:00-07:30): Gradual 1%â†’100%, 454â†’320 mired
#   Day (07:30-18:00): 100% brightness, 320 mired (3125K neutral)
#   Sunset (18:00-22:00): Gradual 100%â†’1%, 320â†’454 mired
#
# Update Frequency: Every 1 minute for ultra-smooth transitions (~0.4%/min)
#
# Golden Rule: Phase-aware dimming/brightening
#   - Sunrise phase: ALLOW brightening (light turned on at night can brighten)
#   - Other phases: Only dim/warm, never brighten/cool
#
# Override Detection: Uses debounce flag to detect manual changes (IKEA remotes
# use direct Zigbee binding, bypassing HA context). Any brightness/color change
# â‰¥5 units when automation_active=off triggers 30-minute override.
# =============================================================================

# -----------------------------------------------------------------------------
# CIRCADIAN SCHEDULE UPDATE
# Trigger: Every 1 minute (ultra-smooth transitions)
# Action: Apply scheduled brightness and color temp to ON lights (not overridden)
# Note: Sets debounce flag to prevent false override detection
# Golden Rule: During Sunrise, allow brightening; otherwise only dim/warm
# -----------------------------------------------------------------------------
- id: circadian_schedule_update
  alias: "Circadian - Schedule Update"
  description: "Updates light brightness and color temp every minute"
  mode: single
  max_exceeded: silent

  trigger:
    - platform: time_pattern
      minutes: "/1"

  condition:
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"

  action:
    # Set debounce flag BEFORE changing lights
    - service: input_boolean.turn_on
      entity_id: input_boolean.circadian_automation_active

    # Read scheduled values from template sensors (with safe defaults if unavailable)
    - variables:
        brightness_pct: "{{ states('sensor.circadian_brightness') | int(100) }}"
        color_temp_kelvin: "{{ states('sensor.circadian_color_temp') | int(3125) }}"
        brightness_value: "{{ (brightness_pct / 100 * 255) | round(0) }}"
        phase: "{{ states('sensor.circadian_phase') }}"

    # Study light (if on and not overridden)
    # GOLDEN RULE (Phase-Aware):
    #   - Sunrise: Allow brightening (light turned on at night can brighten with schedule)
    #   - Other phases: Only dim/warm, never brighten/cool
    - if:
        - condition: state
          entity_id: light.study_ikea_light
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_study_override
          state: "off"
      then:
        - variables:
            # Read current light state
            current_brightness: "{{ state_attr('light.study_ikea_light', 'brightness') | default(255) | int }}"
            current_color_temp: "{{ state_attr('light.study_ikea_light', 'color_temp_kelvin') | default(4000) | int }}"
            # GOLDEN RULE: Phase-aware brightness
            # During Sunrise: use scheduled values (allow brightening)
            # Other phases: take minimum (only dim)
            final_brightness: >
              {% if phase == 'Sunrise' %}
                {{ brightness_value | int }}
              {% else %}
                {{ [brightness_value | int, current_brightness] | min }}
              {% endif %}
            # Color temp always uses min (warmer = lower K, always safe to warm up)
            final_color_temp: "{{ [color_temp_kelvin | int, current_color_temp] | min }}"
            # Check if we should apply changes
            should_apply: >
              {% if phase == 'Sunrise' %}
                {{ brightness_value | int != current_brightness or color_temp_kelvin | int != current_color_temp }}
              {% else %}
                {{ final_brightness < current_brightness or final_color_temp < current_color_temp }}
              {% endif %}
        # Apply if there's a meaningful change
        - if:
            - condition: template
              value_template: "{{ should_apply }}"
          then:
            - service: light.turn_on
              entity_id: light.study_ikea_light
              data:
                brightness: "{{ final_brightness }}"
                color_temp_kelvin: "{{ final_color_temp }}"
                transition: 30

    # Living light (if on and not overridden)
    # GOLDEN RULE (Phase-Aware):
    #   - Sunrise: Allow brightening (light turned on at night can brighten with schedule)
    #   - Other phases: Only dim/warm, never brighten/cool
    - if:
        - condition: state
          entity_id: light.living_ikea_light
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_living_override
          state: "off"
      then:
        - variables:
            # Read current light state
            current_brightness: "{{ state_attr('light.living_ikea_light', 'brightness') | default(255) | int }}"
            current_color_temp: "{{ state_attr('light.living_ikea_light', 'color_temp_kelvin') | default(4000) | int }}"
            # GOLDEN RULE: Phase-aware brightness
            # During Sunrise: use scheduled values (allow brightening)
            # Other phases: take minimum (only dim)
            final_brightness: >
              {% if phase == 'Sunrise' %}
                {{ brightness_value | int }}
              {% else %}
                {{ [brightness_value | int, current_brightness] | min }}
              {% endif %}
            # Color temp always uses min (warmer = lower K, always safe to warm up)
            final_color_temp: "{{ [color_temp_kelvin | int, current_color_temp] | min }}"
            # Check if we should apply changes
            should_apply: >
              {% if phase == 'Sunrise' %}
                {{ brightness_value | int != current_brightness or color_temp_kelvin | int != current_color_temp }}
              {% else %}
                {{ final_brightness < current_brightness or final_color_temp < current_color_temp }}
              {% endif %}
        # Apply if there's a meaningful change
        - if:
            - condition: template
              value_template: "{{ should_apply }}"
          then:
            - service: light.turn_on
              entity_id: light.living_ikea_light
              data:
                brightness: "{{ final_brightness }}"
                color_temp_kelvin: "{{ final_color_temp }}"
                transition: 30

    # Bath light (if on and not overridden)
    # GOLDEN RULE (Phase-Aware):
    #   - Sunrise: Allow brightening (light turned on at night can brighten with schedule)
    #   - Other phases: Only dim/warm, never brighten/cool
    - if:
        - condition: state
          entity_id: light.bath_light
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_bath_override
          state: "off"
      then:
        - variables:
            # Read current light state
            current_brightness: "{{ state_attr('light.bath_light', 'brightness') | default(255) | int }}"
            current_color_temp: "{{ state_attr('light.bath_light', 'color_temp_kelvin') | default(4000) | int }}"
            # GOLDEN RULE: Phase-aware brightness
            # During Sunrise: use scheduled values (allow brightening)
            # Other phases: take minimum (only dim)
            final_brightness: >
              {% if phase == 'Sunrise' %}
                {{ brightness_value | int }}
              {% else %}
                {{ [brightness_value | int, current_brightness] | min }}
              {% endif %}
            # Color temp always uses min (warmer = lower K, always safe to warm up)
            final_color_temp: "{{ [color_temp_kelvin | int, current_color_temp] | min }}"
            # Check if we should apply changes
            should_apply: >
              {% if phase == 'Sunrise' %}
                {{ brightness_value | int != current_brightness or color_temp_kelvin | int != current_color_temp }}
              {% else %}
                {{ final_brightness < current_brightness or final_color_temp < current_color_temp }}
              {% endif %}
        # Apply if there's a meaningful change
        - if:
            - condition: template
              value_template: "{{ should_apply }}"
          then:
            - service: light.turn_on
              entity_id: light.bath_light
              data:
                brightness: "{{ final_brightness }}"
                color_temp_kelvin: "{{ final_color_temp }}"
                transition: 30

    # Clear debounce flag after 5 seconds (allows time for light state to update)
    - delay:
        seconds: 5
    - service: input_boolean.turn_off
      entity_id: input_boolean.circadian_automation_active

# -----------------------------------------------------------------------------
# CIRCADIAN POWER-ON HANDLER
# Trigger: Light turns on
# Action: Set to warmest color temp (2200K) with scheduled brightness
# Note: Power-on always uses warmest color for gentle start
# Minimum Floor: 5% brightness on power-on (prevents confusing near-invisible state)
# -----------------------------------------------------------------------------
- id: circadian_power_on
  alias: "Circadian - Light Power On"
  description: "When light turns on, set to warm color temp with scheduled brightness (min 5%)"
  mode: parallel
  max: 3

  trigger:
    - platform: state
      entity_id:
        - light.study_ikea_light
        - light.living_ikea_light
        - light.bath_light
      from: "off"
      to: "on"

  condition:
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"

  variables:
    room: >
      {% if trigger.entity_id == 'light.study_ikea_light' %}study
      {% elif trigger.entity_id == 'light.bath_light' %}bath
      {% else %}living{% endif %}
    override_flag: "input_boolean.circadian_{{ room }}_override"
    light_name: >
      {% if room == 'study' %}Study
      {% elif room == 'bath' %}Bath
      {% else %}Living{% endif %}
    brightness_pct: "{{ states('sensor.circadian_brightness') | int(100) }}"
    # Power-on floor: minimum 5% brightness so users can see the light turned on
    # At night (1% scheduled), this ensures light is visible on power-on
    brightness_pct_floored: "{{ [brightness_pct | int, 5] | max }}"
    brightness_value: "{{ (brightness_pct_floored / 100 * 255) | round(0) }}"
    phase: "{{ states('sensor.circadian_phase') }}"

  action:
    # Skip if overridden
    - condition: template
      value_template: "{{ is_state(override_flag, 'off') }}"

    # Set debounce flag
    - service: input_boolean.turn_on
      entity_id: input_boolean.circadian_automation_active

    # Small delay for light to initialize
    - delay:
        milliseconds: 300

    # Apply: warmest color temp (2200K) + scheduled brightness (min 5%)
    - service: light.turn_on
      target:
        entity_id: "{{ trigger.entity_id }}"
      data:
        brightness: "{{ brightness_value }}"
        color_temp_kelvin: 2200
        transition: 2

    # Clear debounce after 5 seconds
    - delay:
        seconds: 5
    - service: input_boolean.turn_off
      entity_id: input_boolean.circadian_automation_active

# -----------------------------------------------------------------------------
# CIRCADIAN OVERRIDE DETECTION
# Trigger: Light brightness or color_temp changes
# Condition: Automation is NOT actively changing lights (debounce check)
# Threshold: Ignore changes < 5 units (Zigbee noise at low brightness)
# Action: Set 30-minute override timer
# Note: Detects remote presses via timing, not context (remotes bypass HA context)
# -----------------------------------------------------------------------------
- id: circadian_override_detect
  alias: "Circadian - Override Detection"
  description: "Detects manual light changes (â‰¥5 units) and sets 30-minute override"
  mode: parallel
  max: 3

  trigger:
    - platform: state
      entity_id: light.study_ikea_light
      attribute: brightness
    - platform: state
      entity_id: light.study_ikea_light
      attribute: color_temp
    - platform: state
      entity_id: light.living_ikea_light
      attribute: brightness
    - platform: state
      entity_id: light.living_ikea_light
      attribute: color_temp
    - platform: state
      entity_id: light.bath_light
      attribute: brightness
    - platform: state
      entity_id: light.bath_light
      attribute: color_temp

  condition:
    # Light must be on
    - condition: template
      value_template: "{{ trigger.to_state.state == 'on' }}"
    # Circadian must be enabled
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"
    # Automation must NOT be actively changing lights (debounce check)
    - condition: state
      entity_id: input_boolean.circadian_automation_active
      state: "off"
    # Threshold: Ignore changes < 5 units to filter Zigbee noise at low brightness
    # At 1% brightness (value ~3), small fluctuations of Â±1-2 would otherwise trigger overrides
    - condition: template
      value_template: >
        {% set old_val = trigger.from_state.attributes.get(trigger.attribute, 0) | int(0) %}
        {% set new_val = trigger.to_state.attributes.get(trigger.attribute, 0) | int(0) %}
        {% set change = (new_val - old_val) | abs %}
        {{ change >= 5 }}

  variables:
    room: >
      {% if 'study' in trigger.entity_id %}study
      {% elif 'bath' in trigger.entity_id %}bath
      {% else %}living{% endif %}
    override_flag: "input_boolean.circadian_{{ room }}_override"
    expiry_entity: "input_datetime.circadian_{{ room }}_override_expires"
    light_name: >
      {% if room == 'study' %}Study
      {% elif room == 'bath' %}Bath
      {% else %}Living{% endif %}
    # Format expiration time as strings (avoid strftime on variable)
    expiry_datetime: "{{ (now() + timedelta(minutes=30)).strftime('%Y-%m-%d %H:%M:%S') }}"
    expiry_time: "{{ (now() + timedelta(minutes=30)).strftime('%H:%M') }}"

  action:
    # Set override flag
    - service: input_boolean.turn_on
      target:
        entity_id: "{{ override_flag }}"

    # Set expiration time
    - service: input_datetime.set_datetime
      target:
        entity_id: "{{ expiry_entity }}"
      data:
        datetime: "{{ expiry_datetime }}"

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸ’¡ {{ light_name }} Override"
        message: "Manual adjustment detected. Schedule resumes {{ expiry_time }}."
        data:
          channel: "Lights"
          importance: low
          tag: "circadian_override_{{ room }}"

# -----------------------------------------------------------------------------
# CIRCADIAN OVERRIDE EXPIRY CHECK
# Trigger: Every minute
# Condition: At least one override is active
# Action: Clear expired overrides and restore scheduled settings
# -----------------------------------------------------------------------------
- id: circadian_override_expiry
  alias: "Circadian - Override Expiry Check"
  description: "Checks for expired overrides every minute and restores schedule"
  mode: single

  trigger:
    - platform: time_pattern
      minutes: "/1"

  condition:
    # At least one override must be active
    - condition: or
      conditions:
        - condition: state
          entity_id: input_boolean.circadian_study_override
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_living_override
          state: "on"
        - condition: state
          entity_id: input_boolean.circadian_bath_override
          state: "on"

  variables:
    brightness_pct: "{{ states('sensor.circadian_brightness') | int(100) }}"
    color_temp_kelvin: "{{ states('sensor.circadian_color_temp') | int(3125) }}"
    brightness_value: "{{ (brightness_pct / 100 * 255) | round(0) }}"
    phase: "{{ states('sensor.circadian_phase') }}"

  action:
    # Check Study override expiry
    - if:
        - condition: state
          entity_id: input_boolean.circadian_study_override
          state: "on"
        - condition: template
          value_template: >
            {{ as_timestamp(states('input_datetime.circadian_study_override_expires'))
               < as_timestamp(now()) }}
      then:
        # Clear override flag
        - service: input_boolean.turn_off
          entity_id: input_boolean.circadian_study_override

        # Restore settings if light is on (GOLDEN RULE: phase-aware)
        - if:
            - condition: state
              entity_id: light.study_ikea_light
              state: "on"
          then:
            - variables:
                # Read current light state
                current_brightness: "{{ state_attr('light.study_ikea_light', 'brightness') | default(255) | int }}"
                current_color_temp: "{{ state_attr('light.study_ikea_light', 'color_temp_kelvin') | default(4000) | int }}"
                # GOLDEN RULE: Phase-aware brightness
                # During Sunrise: use scheduled values (allow brightening)
                # Other phases: take minimum (only dim)
                final_brightness: >
                  {% if phase == 'Sunrise' %}
                    {{ brightness_value | int }}
                  {% else %}
                    {{ [brightness_value | int, current_brightness] | min }}
                  {% endif %}
                final_color_temp: "{{ [color_temp_kelvin | int, current_color_temp] | min }}"
                # Check if we should apply changes
                should_apply: >
                  {% if phase == 'Sunrise' %}
                    {{ brightness_value | int != current_brightness or color_temp_kelvin | int != current_color_temp }}
                  {% else %}
                    {{ final_brightness < current_brightness or final_color_temp < current_color_temp }}
                  {% endif %}
            - service: input_boolean.turn_on
              entity_id: input_boolean.circadian_automation_active
            # Apply if there's a meaningful change
            - if:
                - condition: template
                  value_template: "{{ should_apply }}"
              then:
                - service: light.turn_on
                  entity_id: light.study_ikea_light
                  data:
                    brightness: "{{ final_brightness }}"
                    color_temp_kelvin: "{{ final_color_temp }}"
                    transition: 60
                # Notification only when light was actually changed
                - service: notify.all_phones
                  data:
                    title: "ðŸ’¡ Study Light"
                    message: "Override ended. Adjusted to {{ ((final_brightness | int / 255) * 100) | round(0) }}%."
                    data:
                      channel: "Lights"
                      importance: low
                      tag: "circadian_override_study"
            - delay:
                seconds: 5
            - service: input_boolean.turn_off
              entity_id: input_boolean.circadian_automation_active

    # Check Living override expiry
    - if:
        - condition: state
          entity_id: input_boolean.circadian_living_override
          state: "on"
        - condition: template
          value_template: >
            {{ as_timestamp(states('input_datetime.circadian_living_override_expires'))
               < as_timestamp(now()) }}
      then:
        # Clear override flag
        - service: input_boolean.turn_off
          entity_id: input_boolean.circadian_living_override

        # Restore settings if light is on (GOLDEN RULE: phase-aware)
        - if:
            - condition: state
              entity_id: light.living_ikea_light
              state: "on"
          then:
            - variables:
                # Read current light state
                current_brightness: "{{ state_attr('light.living_ikea_light', 'brightness') | default(255) | int }}"
                current_color_temp: "{{ state_attr('light.living_ikea_light', 'color_temp_kelvin') | default(4000) | int }}"
                # GOLDEN RULE: Phase-aware brightness
                # During Sunrise: use scheduled values (allow brightening)
                # Other phases: take minimum (only dim)
                final_brightness: >
                  {% if phase == 'Sunrise' %}
                    {{ brightness_value | int }}
                  {% else %}
                    {{ [brightness_value | int, current_brightness] | min }}
                  {% endif %}
                final_color_temp: "{{ [color_temp_kelvin | int, current_color_temp] | min }}"
                # Check if we should apply changes
                should_apply: >
                  {% if phase == 'Sunrise' %}
                    {{ brightness_value | int != current_brightness or color_temp_kelvin | int != current_color_temp }}
                  {% else %}
                    {{ final_brightness < current_brightness or final_color_temp < current_color_temp }}
                  {% endif %}
            - service: input_boolean.turn_on
              entity_id: input_boolean.circadian_automation_active
            # Apply if there's a meaningful change
            - if:
                - condition: template
                  value_template: "{{ should_apply }}"
              then:
                - service: light.turn_on
                  entity_id: light.living_ikea_light
                  data:
                    brightness: "{{ final_brightness }}"
                    color_temp_kelvin: "{{ final_color_temp }}"
                    transition: 60
                # Notification only when light was actually changed
                - service: notify.all_phones
                  data:
                    title: "ðŸ’¡ Living Light"
                    message: "Override ended. Adjusted to {{ ((final_brightness | int / 255) * 100) | round(0) }}%."
                    data:
                      channel: "Lights"
                      importance: low
                      tag: "circadian_override_living"
            - delay:
                seconds: 5
            - service: input_boolean.turn_off
              entity_id: input_boolean.circadian_automation_active

    # Check Bath override expiry
    - if:
        - condition: state
          entity_id: input_boolean.circadian_bath_override
          state: "on"
        - condition: template
          value_template: >
            {{ as_timestamp(states('input_datetime.circadian_bath_override_expires'))
               < as_timestamp(now()) }}
      then:
        # Clear override flag
        - service: input_boolean.turn_off
          entity_id: input_boolean.circadian_bath_override

        # Restore settings if light is on (GOLDEN RULE: phase-aware)
        - if:
            - condition: state
              entity_id: light.bath_light
              state: "on"
          then:
            - variables:
                # Read current light state
                current_brightness: "{{ state_attr('light.bath_light', 'brightness') | default(255) | int }}"
                current_color_temp: "{{ state_attr('light.bath_light', 'color_temp_kelvin') | default(4000) | int }}"
                # GOLDEN RULE: Phase-aware brightness
                # During Sunrise: use scheduled values (allow brightening)
                # Other phases: take minimum (only dim)
                final_brightness: >
                  {% if phase == 'Sunrise' %}
                    {{ brightness_value | int }}
                  {% else %}
                    {{ [brightness_value | int, current_brightness] | min }}
                  {% endif %}
                final_color_temp: "{{ [color_temp_kelvin | int, current_color_temp] | min }}"
                # Check if we should apply changes
                should_apply: >
                  {% if phase == 'Sunrise' %}
                    {{ brightness_value | int != current_brightness or color_temp_kelvin | int != current_color_temp }}
                  {% else %}
                    {{ final_brightness < current_brightness or final_color_temp < current_color_temp }}
                  {% endif %}
            - service: input_boolean.turn_on
              entity_id: input_boolean.circadian_automation_active
            # Apply if there's a meaningful change
            - if:
                - condition: template
                  value_template: "{{ should_apply }}"
              then:
                - service: light.turn_on
                  entity_id: light.bath_light
                  data:
                    brightness: "{{ final_brightness }}"
                    color_temp_kelvin: "{{ final_color_temp }}"
                    transition: 60
                # Notification only when light was actually changed
                - service: notify.all_phones
                  data:
                    title: "ðŸ’¡ Bath Light"
                    message: "Override ended. Adjusted to {{ ((final_brightness | int / 255) * 100) | round(0) }}%."
                    data:
                      channel: "Lights"
                      importance: low
                      tag: "circadian_override_bath"
            - delay:
                seconds: 5
            - service: input_boolean.turn_off
              entity_id: input_boolean.circadian_automation_active

# -----------------------------------------------------------------------------
# CIRCADIAN PHASE NOTIFICATION
# Trigger: Phase changes (Nightâ†’Sunriseâ†’Dayâ†’Sunsetâ†’Night)
# Condition: Circadian enabled and at least one light is on
# Action: Send notification about the phase transition
# -----------------------------------------------------------------------------
- id: circadian_phase_notification
  alias: "Circadian - Phase Change Notification"
  description: "Notifies when circadian phase changes"
  mode: single

  trigger:
    - platform: state
      entity_id: sensor.circadian_phase

  condition:
    - condition: state
      entity_id: input_boolean.circadian_enabled
      state: "on"
    # At least one light must be on
    - condition: or
      conditions:
        - condition: state
          entity_id: light.study_ikea_light
          state: "on"
        - condition: state
          entity_id: light.living_ikea_light
          state: "on"
        - condition: state
          entity_id: light.bath_light
          state: "on"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸŒ… Circadian Lighting"
        message: >
          {% set phase = states('sensor.circadian_phase') %}
          {% if phase == 'Sunrise' %}
            Sunrise mode: Gradually brightening to 100%
          {% elif phase == 'Day' %}
            Day mode: Full brightness (100%)
          {% elif phase == 'Sunset' %}
            Sunset mode: Gradually dimming to 1%
          {% elif phase == 'Night' %}
            Night mode: Minimal light (1%)
          {% endif %}
        data:
          channel: "Lights"
          importance: low
          tag: "circadian_phase"

# -----------------------------------------------------------------------------
# CIRCADIAN HA STARTUP INIT
# Trigger: Home Assistant starts
# Action: Enable circadian if unknown, clear stale automation_active flag
# -----------------------------------------------------------------------------
- id: circadian_ha_startup
  alias: "Circadian - HA Startup Init"
  description: "Initializes circadian lighting state on Home Assistant startup"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  action:
    # Always enable circadian on startup (user can disable manually if needed)
    - service: input_boolean.turn_on
      target:
        entity_id: input_boolean.circadian_enabled

    # Clear automation_active flag (might be stale from crash)
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.circadian_automation_active

    # Clear any stale overrides from before restart
    - service: input_boolean.turn_off
      target:
        entity_id:
          - input_boolean.circadian_study_override
          - input_boolean.circadian_living_override
          - input_boolean.circadian_bath_override

    # Notification
    - service: notify.all_phones
      data:
        title: "ðŸ’¡ Circadian Initialized"
        message: "Lighting schedule active. Phase: {{ states('sensor.circadian_phase') }}."
        data:
          channel: "Info"
          importance: low
          tag: "circadian_startup"

# -----------------------------------------------------------------------------
# CIRCADIAN MQTT CONTROL (Dashboard Integration)
# Trigger: MQTT command from web dashboard
# Action: Toggle circadian enabled or clear override flags
# Purpose: Allows dashboard to control circadian without HA REST API token
# Commands:
#   {"action": "toggle"} - Toggle circadian_enabled
#   {"action": "enable"} - Enable circadian
#   {"action": "disable"} - Disable circadian
#   {"action": "clear_override", "room": "study"} - Clear study override
#   {"action": "clear_override", "room": "living"} - Clear living override
#   {"action": "clear_override", "room": "bath"} - Clear bath override
#   {"action": "apply_circadian", "room": "study"} - Apply schedule to study light
#   {"action": "apply_circadian", "room": "living"} - Apply schedule to living light
#   {"action": "apply_circadian", "room": "bath"} - Apply schedule to bath light
# -----------------------------------------------------------------------------
- id: circadian_mqtt_control
  alias: "Circadian - MQTT Dashboard Control"
  description: "Handles circadian control commands from web dashboard via MQTT"
  mode: parallel
  max: 4

  trigger:
    - platform: mqtt
      topic: "homeassistant/circadian/command"

  action:
    - choose:
        # Toggle circadian enabled
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'toggle' }}"
          sequence:
            - service: input_boolean.toggle
              target:
                entity_id: input_boolean.circadian_enabled

        # Enable circadian
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'enable' }}"
          sequence:
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.circadian_enabled

        # Disable circadian
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'disable' }}"
          sequence:
            - service: input_boolean.turn_off
              target:
                entity_id: input_boolean.circadian_enabled

        # Clear override for a specific room
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'clear_override' }}"
          sequence:
            - service: input_boolean.turn_off
              target:
                entity_id: "input_boolean.circadian_{{ trigger.payload_json.room }}_override"

        # Apply circadian schedule to a specific light
        - conditions:
            - condition: template
              value_template: "{{ trigger.payload_json.action == 'apply_circadian' }}"
          sequence:
            - variables:
                room: "{{ trigger.payload_json.room }}"
                light_entity: >
                  {% if room == 'study' %}light.study_ikea_light
                  {% elif room == 'bath' %}light.bath_light
                  {% else %}light.living_ikea_light{% endif %}
                brightness_value: "{{ (states('sensor.circadian_brightness') | int(100) / 100 * 255) | round(0) }}"
                color_temp_kelvin: "{{ states('sensor.circadian_color_temp') | int(3125) }}"
            - service: input_boolean.turn_on
              target:
                entity_id: input_boolean.circadian_automation_active
            - service: light.turn_on
              target:
                entity_id: "{{ light_entity }}"
              data:
                brightness: "{{ brightness_value }}"
                color_temp_kelvin: "{{ color_temp_kelvin }}"
                transition: 2
            # Clear override flag since user explicitly requested schedule
            - service: input_boolean.turn_off
              target:
                entity_id: "input_boolean.circadian_{{ room }}_override"
            - delay:
                seconds: 5
            - service: input_boolean.turn_off
              target:
                entity_id: input_boolean.circadian_automation_active

# -----------------------------------------------------------------------------
# CIRCADIAN - MQTT STATE PUBLISHER
# Purpose: Publishes circadian state to MQTT for dashboard consumption
# Triggers on ANY circadian entity state change
# Topic: homeassistant/circadian/state (JSON payload)
# -----------------------------------------------------------------------------
- id: circadian_mqtt_state_publisher
  alias: "Circadian - MQTT State Publisher"
  description: "Publishes circadian state to MQTT whenever any entity changes"
  mode: queued
  max: 5

  trigger:
    # Trigger on any circadian-related entity change
    - platform: state
      entity_id:
        - sensor.circadian_phase
        - sensor.circadian_brightness
        - sensor.circadian_color_temp
        - input_boolean.circadian_enabled
        - input_boolean.circadian_study_override
        - input_boolean.circadian_living_override
        - input_boolean.circadian_bath_override
        - input_datetime.circadian_study_override_expires
        - input_datetime.circadian_living_override_expires
        - input_datetime.circadian_bath_override_expires

  action:
    - service: mqtt.publish
      data:
        topic: "homeassistant/circadian/state"
        retain: true
        payload: >
          {
            "phase": "{{ states('sensor.circadian_phase') }}",
            "brightness": {{ states('sensor.circadian_brightness') | int(100) }},
            "colorTemp": {{ states('sensor.circadian_color_temp') | int(3125) }},
            "enabled": {{ is_state('input_boolean.circadian_enabled', 'on') | lower }},
            "overrides": {
              "study": {
                "active": {{ is_state('input_boolean.circadian_study_override', 'on') | lower }},
                "expires": "{{ states('input_datetime.circadian_study_override_expires') }}"
              },
              "living": {
                "active": {{ is_state('input_boolean.circadian_living_override', 'on') | lower }},
                "expires": "{{ states('input_datetime.circadian_living_override_expires') }}"
              },
              "bath": {
                "active": {{ is_state('input_boolean.circadian_bath_override', 'on') | lower }},
                "expires": "{{ states('input_datetime.circadian_bath_override_expires') }}"
              }
            },
            "timestamp": "{{ now().isoformat() }}"
          }

# =============================================================================
# SENSOR OFFLINE MONITORING
# Purpose: Alert when contact sensors go offline (affects heater safety system)
# Problem: When sensors are "unavailable", heater resume automation can't work
#          because it requires all sensors to be state="off" (not "unavailable")
# Solution: Alert the user so they can manually trigger sensors to rejoin
# =============================================================================

# -----------------------------------------------------------------------------
# CONTACT SENSOR OFFLINE - IMMEDIATE ALERT
# Trigger: Any contact sensor goes unavailable for 5+ minutes
# Action: Send mobile notification with sensor name and recovery instructions
# -----------------------------------------------------------------------------
- id: contact_sensor_offline_alert
  alias: "Contact Sensor Offline Alert"
  description: "Alert when any contact sensor becomes unavailable"
  mode: parallel
  max: 8

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      to: "unavailable"
      for: "00:05:00"  # Wait 5 min to confirm not temporary

  variables:
    sensor_names:
      binary_sensor.bath_window_contact_sensor_contact: "Bathroom Window"
      binary_sensor.bed_window_contact_sensor_contact: "Bedroom Window"
      binary_sensor.kitchen_window_contact_sensor_contact: "Kitchen Window"
      binary_sensor.study_window_contact_sensor_large_contact: "Study Large Window"
      binary_sensor.study_window_contact_sensor_small_contact: "Study Small Window"
      binary_sensor.living_window_contact_sensor_window_contact: "Living Window"
      binary_sensor.living_window_contact_sensor_balcony_door_contact: "Balcony Door"
      binary_sensor.hallway_window_contact_sensor_main_door_contact: "Main Door"
    sensor_name: "{{ sensor_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸ“µ SENSOR OFFLINE"
        message: >
          {{ sensor_name }} sensor is offline.
          Heaters may not resume automatically.
          Try opening/closing the window to wake it.
        data:
          channel: "Alerts"
          importance: high
          tag: "sensor_offline_{{ trigger.entity_id }}"
    - service: script.send_alert_email
      data:
        severity: "WARNING"
        title: "Contact Sensor Offline"
        subtitle: "{{ sensor_name }}"
        description: >-
          {{ sensor_name }} contact sensor went offline. This affects the heater safety
          system â€” heaters may not resume automatically when windows close because the
          sensor state reads "unavailable" instead of "closed".
        actions: "Open and close the physical window to wake the sensor|If sensor doesn't recover, check battery (CR2032)"
        plain_text: >-
          {{ sensor_name }} contact sensor went offline at {{ now().strftime('%H:%M on %b %d') }}.
          This affects the heater safety system. Recovery: Open/close the window to wake the sensor.
    - service: system_log.write
      data:
        message: "ALERT: {{ sensor_name }} contact sensor went offline"
        level: warning

# -----------------------------------------------------------------------------
# CONTACT SENSOR OFFLINE - REPEAT ALERT EVERY 4 HOURS
# Trigger: Every 4 hours (time pattern)
# Condition: At least one contact sensor is unavailable
# Action: Send reminder notification listing all offline sensors
# -----------------------------------------------------------------------------
- id: contact_sensor_offline_repeat
  alias: "Contact Sensor Offline - Repeat Alert"
  description: "Repeat offline alert every 4 hours"
  mode: single

  trigger:
    - platform: time_pattern
      hours: "/4"

  action:
    - variables:
        sensor_names:
          binary_sensor.bath_window_contact_sensor_contact: "Bathroom"
          binary_sensor.bed_window_contact_sensor_contact: "Bedroom"
          binary_sensor.kitchen_window_contact_sensor_contact: "Kitchen"
          binary_sensor.study_window_contact_sensor_large_contact: "Study Large"
          binary_sensor.study_window_contact_sensor_small_contact: "Study Small"
          binary_sensor.living_window_contact_sensor_window_contact: "Living"
          binary_sensor.living_window_contact_sensor_balcony_door_contact: "Balcony Door"
          binary_sensor.hallway_window_contact_sensor_main_door_contact: "Main Door"
        offline_list: >
          {% set ns = namespace(sensors=[]) %}
          {% for entity, name in sensor_names.items() %}
            {% if states(entity) == 'unavailable' %}
              {% set ns.sensors = ns.sensors + [name] %}
            {% endif %}
          {% endfor %}
          {{ ns.sensors }}
        offline_count: "{{ offline_list | length }}"
    - condition: template
      value_template: "{{ offline_count | int > 0 }}"
    - service: notify.all_phones
      data:
        title: "ðŸ“µ {{ offline_count }} SENSOR(S) STILL OFFLINE"
        message: >
          {{ offline_list | join(', ') }} sensor(s) offline.
          Heaters won't auto-resume until fixed.
          Open/close window or check battery.
        data:
          channel: "Alerts"
          importance: high
          tag: "sensor_offline_repeat"

# -----------------------------------------------------------------------------
# CONTACT SENSOR BACK ONLINE - CLEAR ALERT
# Trigger: Any contact sensor transitions FROM unavailable to any other state
# Action: Send recovery notification and clear the offline alert
# -----------------------------------------------------------------------------
- id: contact_sensor_back_online
  alias: "Contact Sensor Back Online"
  description: "Clear alert when sensor comes back online"
  mode: parallel
  max: 8

  trigger:
    - platform: state
      entity_id:
        - binary_sensor.bath_window_contact_sensor_contact
        - binary_sensor.bed_window_contact_sensor_contact
        - binary_sensor.kitchen_window_contact_sensor_contact
        - binary_sensor.study_window_contact_sensor_large_contact
        - binary_sensor.study_window_contact_sensor_small_contact
        - binary_sensor.living_window_contact_sensor_window_contact
        - binary_sensor.living_window_contact_sensor_balcony_door_contact
        - binary_sensor.hallway_window_contact_sensor_main_door_contact
      from: "unavailable"

  variables:
    sensor_names:
      binary_sensor.bath_window_contact_sensor_contact: "Bathroom Window"
      binary_sensor.bed_window_contact_sensor_contact: "Bedroom Window"
      binary_sensor.kitchen_window_contact_sensor_contact: "Kitchen Window"
      binary_sensor.study_window_contact_sensor_large_contact: "Study Large Window"
      binary_sensor.study_window_contact_sensor_small_contact: "Study Small Window"
      binary_sensor.living_window_contact_sensor_window_contact: "Living Window"
      binary_sensor.living_window_contact_sensor_balcony_door_contact: "Balcony Door"
      binary_sensor.hallway_window_contact_sensor_main_door_contact: "Main Door"
    sensor_name: "{{ sensor_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    - service: notify.all_phones
      data:
        title: "âœ… SENSOR ONLINE"
        message: "{{ sensor_name }} sensor is back online"
        data:
          channel: "Alerts"
          tag: "sensor_offline_{{ trigger.entity_id }}"
    - service: system_log.write
      data:
        message: "RECOVERED: {{ sensor_name }} contact sensor is back online"
        level: info

# =============================================================================
# ZIGBEE NETWORK MONITORING ALERTS
# Purpose: Monitor Zigbee network health during device recovery
# Created: 2026-01-05 (after network reformation incident)
# =============================================================================

# -----------------------------------------------------------------------------
# ZIGBEE DEVICE JOINED ALERT
# Trigger: Any device successfully completes interview (joins network)
# Action: Mobile notification to both phones
# Purpose: Monitor device recovery after network reformation
# -----------------------------------------------------------------------------
- id: zigbee_device_joined_alert
  alias: "Zigbee Device Joined Alert"
  description: "Notifies when any Zigbee device successfully joins the network"
  mode: parallel
  max: 10

  trigger:
    - platform: mqtt
      topic: "zigbee2mqtt/bridge/event"

  condition:
    - condition: template
      value_template: >
        {{ trigger.payload_json.type == 'device_interview' and
           trigger.payload_json.data.status == 'successful' }}

  action:
    - service: notify.all_phones
      data:
        title: "ðŸŽ‰ Zigbee Device Joined!"
        message: >
          {{ trigger.payload_json.data.friendly_name }} has joined the network
          ({{ trigger.payload_json.data.ieee_address }})
        data:
          channel: "Zigbee"
          importance: high
          tag: "zigbee_join_{{ trigger.payload_json.data.ieee_address }}"
    - service: system_log.write
      data:
        message: >
          ZIGBEE JOIN: {{ trigger.payload_json.data.friendly_name }}
          ({{ trigger.payload_json.data.ieee_address }}) joined successfully
        level: info

# -----------------------------------------------------------------------------
# ZIGBEE DEVICE LEFT NETWORK
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  "Offline" vs "Left" - they are NOT the same thing!                    â”‚
# â”‚                                                                         â”‚
# â”‚  OFFLINE (unavailable):                                                â”‚
# â”‚    Device lost contact. Battery died, out of range, router down.       â”‚
# â”‚    Still paired. Will reconnect automatically when reachable again.    â”‚
# â”‚                                                                         â”‚
# â”‚  LEFT NETWORK (device_leave):                                          â”‚
# â”‚    Device actively de-paired itself from the coordinator.              â”‚
# â”‚    Gone from the network. Must be re-paired manually.                  â”‚
# â”‚    Causes: firmware reset, power cycle during pairing window,          â”‚
# â”‚            or the Jan 4 incident where rapid restarts orphaned all 35. â”‚
# â”‚                                                                         â”‚
# â”‚  This is the WORSE event. Offline devices come back. Left devices     â”‚
# â”‚  need manual intervention to re-pair.                                  â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# Trigger: zigbee2mqtt/bridge/event with type "device_leave"
# Action: Phone + Email (this is serious)
# -----------------------------------------------------------------------------
- id: zigbee_device_left_alert
  alias: "Zigbee Device Left Network"
  description: "Alerts when a device leaves the Zigbee network (de-paired, needs manual re-pairing)"
  mode: parallel
  max: 10

  trigger:
    - platform: mqtt
      topic: "zigbee2mqtt/bridge/event"

  condition:
    - condition: template
      value_template: "{{ trigger.payload_json.type == 'device_leave' }}"

  action:
    - service: notify.all_phones
      data:
        title: "ðŸš¨ DEVICE LEFT ZIGBEE NETWORK"
        message: >
          {{ trigger.payload_json.data.friendly_name | default(trigger.payload_json.data.ieee_address) }}
          has LEFT the network! It must be re-paired manually.
        data:
          channel: "Critical"
          importance: max
          vibrationPattern: "100, 1000, 100, 1000, 100"
          tag: "zigbee_leave_{{ trigger.payload_json.data.ieee_address }}"
    - service: script.send_alert_email
      data:
        severity: "CRITICAL"
        title: "Device Left Zigbee Network"
        subtitle: "{{ trigger.payload_json.data.friendly_name | default('Unknown Device') }}"
        description: >-
          This is NOT the same as going offline. The device has actively de-paired itself
          from the coordinator and will NOT reconnect automatically. Manual re-pairing is required.
        actions: "Put Zigbee2MQTT in pairing mode (Settings â†’ Permit Join)|Reset the device (hold pairing button 5â€“10 seconds)|Wait for it to rejoin â€” you'll get a 'Device Joined' notification"
        details: >-
          Device: {{ trigger.payload_json.data.friendly_name | default('Unknown') }}
          IEEE:   {{ trigger.payload_json.data.ieee_address | default('Unknown') }}

          If multiple devices are leaving, check coordinator:
          ssh pi@pi "sudo systemctl status zigbee2mqtt"
        plain_text: >-
          {{ trigger.payload_json.data.friendly_name | default('Unknown') }} has LEFT the Zigbee network
          ({{ trigger.payload_json.data.ieee_address | default('Unknown') }}). Re-pair required.
    - service: system_log.write
      data:
        message: >
          ZIGBEE LEAVE: {{ trigger.payload_json.data.friendly_name | default('Unknown') }}
          ({{ trigger.payload_json.data.ieee_address | default('Unknown') }}) left the network
        level: error

# -----------------------------------------------------------------------------
# ZIGBEE ROUTER OFFLINE ALERT
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  Routers form the Zigbee mesh backbone. When one goes offline,         â”‚
# â”‚  nearby battery sensors lose their relay path and may go offline too.  â”‚
# â”‚                                                                         â”‚
# â”‚  MONITORED (always-powered â€” offline means real problem):              â”‚
# â”‚    3x Smart Plugs           (mains)                                    â”‚
# â”‚    3x Light Switches        (hardwired SONOFF â€” Study, Bed, Living)    â”‚
# â”‚    1x CO2 Sensor            (USB-powered)                              â”‚
# â”‚    5x Human Presence        (USB-powered SNZB-06P â€” all rooms)         â”‚
# â”‚                                                                         â”‚
# â”‚  EXCLUDED (manually powered off â€” would cause false alerts):           â”‚
# â”‚    2x IKEA Lights           (Study, Living â€” wall switch)              â”‚
# â”‚    1x AwoX Bath Light       (wall switch)                              â”‚
# â”‚                                                                         â”‚
# â”‚  Trigger: state â†’ "unavailable" for 2 minutes                         â”‚
# â”‚  Action: HTML email only (12 devices â€” phone push too noisy)            â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# -----------------------------------------------------------------------------
- id: zigbee_router_offline_alert
  alias: "Zigbee Router Offline Alert"
  description: "Notifies when any Zigbee router device goes offline"
  mode: parallel
  max: 10

  trigger:
    # Smart Plugs
    - platform: state
      entity_id: switch.smart_plug_1
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: switch.smart_plug_2
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: switch.smart_plug_3
      to: "unavailable"
      for:
        minutes: 2
    # IKEA Lights + Bath Light excluded â€” manually powered off via wall switch,
    # would trigger false alerts constantly.
    # Light Switches (SONOFF, hardwired â€” always powered)
    - platform: state
      entity_id: switch.study_light_switch
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: switch.bed_light_switch
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: switch.living_light_switch
      to: "unavailable"
      for:
        minutes: 2
    # CO2 Sensor (router device, USB-powered)
    - platform: state
      entity_id: sensor.hallway_co2_co2
      to: "unavailable"
      for:
        minutes: 2
    # Human Presence Sensors (SNZB-06P, USB-powered routers)
    - platform: state
      entity_id: binary_sensor.study_human_presence_occupancy
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: binary_sensor.living_human_presence_occupancy
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: binary_sensor.kitchen_human_presence_occupancy
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: binary_sensor.bath_human_presence_occupancy
      to: "unavailable"
      for:
        minutes: 2
    - platform: state
      entity_id: binary_sensor.bed_human_presence_occupancy
      to: "unavailable"
      for:
        minutes: 2

  variables:
    device_names:
      switch.smart_plug_1: "Smart Plug [1]"
      switch.smart_plug_2: "Smart Plug [2]"
      switch.smart_plug_3: "Smart Plug [3]"
      switch.study_light_switch: "[Study] Light Switch"
      switch.bed_light_switch: "[Bed] Light Switch"
      switch.living_light_switch: "[Living] Light Switch"
      sensor.hallway_co2_co2: "[Hallway] CO2 Sensor"
      binary_sensor.study_human_presence_occupancy: "[Study] Human Presence"
      binary_sensor.living_human_presence_occupancy: "[Living] Human Presence"
      binary_sensor.kitchen_human_presence_occupancy: "[Kitchen] Human Presence"
      binary_sensor.bath_human_presence_occupancy: "[Bath] Human Presence"
      binary_sensor.bed_human_presence_occupancy: "[Bed] Human Presence"
    device_name: "{{ device_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    # Email only â€” no phone push. 12 routers monitored, would be noisy.
    - service: script.send_alert_email
      data:
        severity: "CRITICAL"
        title: "Zigbee Router Offline"
        subtitle: "{{ device_name }}"
        description: >-
          Router devices form the Zigbee mesh backbone. When one goes offline,
          nearby battery-powered sensors may lose their relay path and go offline too.
        actions: "Check if the device is physically powered on|Verify the outlet or switch hasn't been turned off|If powered, try unplugging for 10 seconds and re-plugging"
        plain_text: >-
          {{ device_name }} went offline at {{ now().strftime('%H:%M on %b %d') }}.
          Router devices form the mesh backbone. Check if device is powered on.
    - service: system_log.write
      data:
        message: "ROUTER OFFLINE: {{ device_name }} ({{ trigger.entity_id }}) went unavailable"
        level: warning

# -----------------------------------------------------------------------------
# ZIGBEE ROUTER BACK ONLINE ALERT
# Trigger: Any router device comes back online
# Action: INFO email (resolves offline alert in inbox) + system log
# -----------------------------------------------------------------------------
- id: zigbee_router_online_alert
  alias: "Zigbee Router Back Online Alert"
  description: "Notifies when a Zigbee router device comes back online"
  mode: parallel
  max: 10

  trigger:
    # Smart Plugs
    - platform: state
      entity_id: switch.smart_plug_1
      from: "unavailable"
    - platform: state
      entity_id: switch.smart_plug_2
      from: "unavailable"
    - platform: state
      entity_id: switch.smart_plug_3
      from: "unavailable"
    # IKEA Lights + Bath Light excluded â€” powered off manually, see offline alert comment
    # Light Switches (SONOFF, hardwired â€” always powered)
    - platform: state
      entity_id: switch.study_light_switch
      from: "unavailable"
    - platform: state
      entity_id: switch.bed_light_switch
      from: "unavailable"
    - platform: state
      entity_id: switch.living_light_switch
      from: "unavailable"
    # CO2 Sensor (router device, USB-powered)
    - platform: state
      entity_id: sensor.hallway_co2_co2
      from: "unavailable"
    # Human Presence Sensors (SNZB-06P, USB-powered routers)
    - platform: state
      entity_id: binary_sensor.study_human_presence_occupancy
      from: "unavailable"
    - platform: state
      entity_id: binary_sensor.living_human_presence_occupancy
      from: "unavailable"
    - platform: state
      entity_id: binary_sensor.kitchen_human_presence_occupancy
      from: "unavailable"
    - platform: state
      entity_id: binary_sensor.bath_human_presence_occupancy
      from: "unavailable"
    - platform: state
      entity_id: binary_sensor.bed_human_presence_occupancy
      from: "unavailable"

  variables:
    device_names:
      switch.smart_plug_1: "Smart Plug [1]"
      switch.smart_plug_2: "Smart Plug [2]"
      switch.smart_plug_3: "Smart Plug [3]"
      switch.study_light_switch: "[Study] Light Switch"
      switch.bed_light_switch: "[Bed] Light Switch"
      switch.living_light_switch: "[Living] Light Switch"
      sensor.hallway_co2_co2: "[Hallway] CO2 Sensor"
      binary_sensor.study_human_presence_occupancy: "[Study] Human Presence"
      binary_sensor.living_human_presence_occupancy: "[Living] Human Presence"
      binary_sensor.kitchen_human_presence_occupancy: "[Kitchen] Human Presence"
      binary_sensor.bath_human_presence_occupancy: "[Bath] Human Presence"
      binary_sensor.bed_human_presence_occupancy: "[Bed] Human Presence"
    device_name: "{{ device_names.get(trigger.entity_id, trigger.entity_id) }}"

  action:
    # Recovery email so offline alert in Siva's inbox gets a resolution signal
    - service: script.send_alert_email
      data:
        severity: "INFO"
        title: "Zigbee Router Back Online"
        subtitle: "{{ device_name }}"
        description: >-
          {{ device_name }} has recovered and is back online. No action needed.
        actions: ""
        plain_text: >-
          {{ device_name }} is back online at {{ now().strftime('%H:%M on %b %d') }}.
    - service: system_log.write
      data:
        message: "ROUTER ONLINE: {{ device_name }} ({{ trigger.entity_id }}) is back"
        level: info

# =============================================================================
# THERMOSTAT BOOST - EXPIRY AUTOMATIONS
# Purpose: Auto-restore thermostat temperature when 60-minute boost expires
# Dashboard feature: "Boost 22Â°C for 60 min" button
# =============================================================================

# -----------------------------------------------------------------------------
# STUDY BOOST - EXPIRES
# Trigger: Time matches input_datetime.study_boost_end
# Action: Restore original temperature, publish to MQTT
# -----------------------------------------------------------------------------
- id: study_boost_expires
  alias: "Study Boost - Expires"
  description: "Restore study thermostat when boost timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.study_boost_end

  condition:
    # Only if boost is actually active (expiry is in the future or just passed)
    - condition: template
      value_template: >
        {{ (as_timestamp(states('input_datetime.study_boost_end')) - as_timestamp(now())) | abs < 120 }}

  action:
    - service: script.thermostat_boost_cancel
      data:
        thermostat_id: study

# -----------------------------------------------------------------------------
# LIVING INNER BOOST - EXPIRES
# -----------------------------------------------------------------------------
- id: living_inner_boost_expires
  alias: "Living Inner Boost - Expires"
  description: "Restore living inner thermostat when boost timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.living_inner_boost_end

  condition:
    - condition: template
      value_template: >
        {{ (as_timestamp(states('input_datetime.living_inner_boost_end')) - as_timestamp(now())) | abs < 120 }}

  action:
    - service: script.thermostat_boost_cancel
      data:
        thermostat_id: living_inner

# -----------------------------------------------------------------------------
# LIVING OUTER BOOST - EXPIRES
# -----------------------------------------------------------------------------
- id: living_outer_boost_expires
  alias: "Living Outer Boost - Expires"
  description: "Restore living outer thermostat when boost timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.living_outer_boost_end

  condition:
    - condition: template
      value_template: >
        {{ (as_timestamp(states('input_datetime.living_outer_boost_end')) - as_timestamp(now())) | abs < 120 }}

  action:
    - service: script.thermostat_boost_cancel
      data:
        thermostat_id: living_outer

# -----------------------------------------------------------------------------
# BEDROOM BOOST - EXPIRES
# -----------------------------------------------------------------------------
- id: bedroom_boost_expires
  alias: "Bedroom Boost - Expires"
  description: "Restore bedroom thermostat when boost timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.bedroom_boost_end

  condition:
    - condition: template
      value_template: >
        {{ (as_timestamp(states('input_datetime.bedroom_boost_end')) - as_timestamp(now())) | abs < 120 }}

  action:
    - service: script.thermostat_boost_cancel
      data:
        thermostat_id: bedroom

# -----------------------------------------------------------------------------
# GLOBAL BOOST MODE - EXPIRES
# Purpose: Disable global boost mode when timer expires (reverts to 22Â°C max)
# NOTE: This does NOT change any thermostat temperatures, just the max limit
# -----------------------------------------------------------------------------
- id: global_boost_mode_expires
  alias: "Global Boost Mode - Expires"
  description: "Disable global boost mode when timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.global_boost_end

  condition:
    # Only if boost mode is actually active (expiry is recent)
    - condition: template
      value_template: >
        {{ (as_timestamp(states('input_datetime.global_boost_end')) - as_timestamp(now())) | abs < 120 }}

  action:
    - service: script.global_boost_mode_cancel

# -----------------------------------------------------------------------------
# CO2 OVERRIDE - EXPIRES
# Purpose: Cancel CO2 override when 6-hour timer expires
# -----------------------------------------------------------------------------
- id: co2_override_expires
  alias: "CO2 Override - Expires"
  description: "Cancel CO2 override when timer expires"
  mode: single

  trigger:
    - platform: time
      at: input_datetime.co2_override_end

  condition:
    # Only if expiry is recent (within 120 seconds)
    - condition: template
      value_template: >
        {{ (as_timestamp(states('input_datetime.co2_override_end')) - as_timestamp(now())) | abs < 120 }}

  action:
    - service: script.co2_override_cancel

# -----------------------------------------------------------------------------
# CO2 OVERRIDE - STATE PUBLISHER
# Purpose: Publish CO2 override state to MQTT on HA startup for dashboard recovery
# -----------------------------------------------------------------------------
- id: co2_override_state_publisher
  alias: "CO2 Override - State Publisher"
  description: "Publish CO2 override state to MQTT on startup"
  mode: single

  trigger:
    - platform: homeassistant
      event: start

  action:
    - delay:
        seconds: 10  # Wait for MQTT to be ready
    - service: mqtt.publish
      data:
        topic: "dashboard/co2-override"
        retain: true
        payload: >
          {"active": {{ is_state('input_boolean.co2_override_active', 'on') | lower }}, "expires_at": "{{ states('input_datetime.co2_override_end') }}"}

# -----------------------------------------------------------------------------
# THERMOSTAT ZOMBIE STATE RECOVERY
# Purpose: Detect and recover thermostats stuck in OFF mode due to MQTT race conditions
# Bug Reference: 2026-01-12 Living Outer stuck at OFF/7Â°C after MQTT sync error
#
# Detection Logic:
#   - Thermostat is OFF with setpoint â‰¤ 7Â°C (frost protection)
#   - Room temperature is below comfort threshold (17Â°C)
#   - No guard flags active (not deliberately turned off)
#
# Action: Auto-recover to heat mode with 18Â°C setpoint + notification
# -----------------------------------------------------------------------------
- id: thermostat_zombie_state_recovery
  alias: "Thermostat Zombie State Recovery"
  description: "Detect and recover thermostats stuck in OFF mode due to MQTT errors"
  mode: single

  trigger:
    - platform: time_pattern
      minutes: "/30"  # Every 30 minutes

  condition:
    # Only run if no guard flags are active (heaters weren't deliberately turned off)
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"

  variables:
    # Detect zombie thermostats: OFF mode + setpoint â‰¤ 7Â°C + stuck > 60 min
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚  FIX (Feb 7, 2026): Replaced temp<17 with last_changed > 60min â”‚
    # â”‚                                                                 â”‚
    # â”‚  OLD: temp<17 guard â†’ MASKED by other TRV heating same room    â”‚
    # â”‚  Living Outer kept room at 18Â°C â†’ Living Inner zombie missed!  â”‚
    # â”‚                                                                 â”‚
    # â”‚  NEW: last_changed > 60min â†’ catches zombies regardless of     â”‚
    # â”‚  room temperature. Protects against user-intentional OFF       â”‚
    # â”‚  (recent last_changed = user did it on purpose).               â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    zombie_thermostats: >
      {% set zombies = [] %}
      {% if states('climate.study_thermostat') == 'off'
            and (state_attr('climate.study_thermostat', 'temperature') | float(20)) <= 7
            and ((as_timestamp(now()) - as_timestamp(states.climate.study_thermostat.last_changed)) > 3600) %}
        {% set zombies = zombies + ['study'] %}
      {% endif %}
      {% if states('climate.living_thermostat_inner') == 'off'
            and (state_attr('climate.living_thermostat_inner', 'temperature') | float(20)) <= 7
            and ((as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_inner.last_changed)) > 3600) %}
        {% set zombies = zombies + ['living_inner'] %}
      {% endif %}
      {% if states('climate.living_thermostat_outer') == 'off'
            and (state_attr('climate.living_thermostat_outer', 'temperature') | float(20)) <= 7
            and ((as_timestamp(now()) - as_timestamp(states.climate.living_thermostat_outer.last_changed)) > 3600) %}
        {% set zombies = zombies + ['living_outer'] %}
      {% endif %}
      {% if states('climate.bed_thermostat') == 'off'
            and (state_attr('climate.bed_thermostat', 'temperature') | float(20)) <= 7
            and ((as_timestamp(now()) - as_timestamp(states.climate.bed_thermostat.last_changed)) > 3600) %}
        {% set zombies = zombies + ['bedroom'] %}
      {% endif %}
      {{ zombies }}

  action:
    # Only proceed if we found zombie thermostats
    - condition: template
      value_template: "{{ zombie_thermostats | length > 0 }}"

    # Log to InfluxDB for debugging
    - service: influxdb.write
      data:
        measurement: thermostat_events
        tags:
          event_type: zombie_recovery
        fields:
          thermostats: "{{ zombie_thermostats | join(',') }}"
          count: "{{ zombie_thermostats | length }}"

    # Send notification
    - service: notify.all_phones
      data:
        title: "ðŸ§Ÿ Thermostat Zombie Recovery"
        message: "Auto-recovering stuck thermostat(s): {{ zombie_thermostats | join(', ') }}. Setting to 18Â°C."
        data:
          channel: "Warning"
          importance: high
          tag: "thermostat_zombie"

    # TTS announcement (respect quiet hours 23:00-07:00, uses fallback cascade)
    - if:
        - condition: template
          value_template: "{{ now().hour >= 7 and now().hour < 23 }}"
      then:
        - service: script.smart_tts_announce
          data:
            message: "Recovering stuck thermostat. {{ zombie_thermostats | join(' and ') }}."
            title: "ðŸ”§ Thermostat Recovery"

    # Recover each zombie thermostat
    - if:
        - condition: template
          value_template: "{{ 'study' in zombie_thermostats }}"
      then:
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.study_thermostat
          data:
            hvac_mode: "heat"
        - delay:
            seconds: 2
        - service: climate.set_temperature
          target:
            entity_id: climate.study_thermostat
          data:
            temperature: 18

    - if:
        - condition: template
          value_template: "{{ 'living_inner' in zombie_thermostats }}"
      then:
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_inner
          data:
            hvac_mode: "heat"
        - delay:
            seconds: 2
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_inner
          data:
            temperature: 18

    - if:
        - condition: template
          value_template: "{{ 'living_outer' in zombie_thermostats }}"
      then:
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.living_thermostat_outer
          data:
            hvac_mode: "heat"
        - delay:
            seconds: 2
        - service: climate.set_temperature
          target:
            entity_id: climate.living_thermostat_outer
          data:
            temperature: 18

    - if:
        - condition: template
          value_template: "{{ 'bedroom' in zombie_thermostats }}"
      then:
        - service: climate.set_hvac_mode
          target:
            entity_id: climate.bed_thermostat
          data:
            hvac_mode: "heat"
        - delay:
            seconds: 2
        - service: climate.set_temperature
          target:
            entity_id: climate.bed_thermostat
          data:
            temperature: 18

# =============================================================================
# STUCK-IDLE RECOVERY (Feb 7, 2026)
# =============================================================================
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  INCIDENT: Feb 7, 2026 â€” Living Inner TRV stuck idle for 10+ hours        â”‚
# â”‚                                                                             â”‚
# â”‚  mode=heat, setpoint=19Â°C, temp=17.2Â°C, but running_state=idle             â”‚
# â”‚  Valve motor seized after 10h in OFF mode (voltage 1770â†’1145 mV)           â”‚
# â”‚  TRV accepted mode=heat but valve physically wouldn't open                 â”‚
# â”‚                                                                             â”‚
# â”‚  All 3 safety nets missed it:                                               â”‚
# â”‚    1. Heater Watchdog: only checks window+heating violations               â”‚
# â”‚    2. Zombie Recovery: temp<17 guard masked by Living Outer (18Â°C)         â”‚
# â”‚    3. Window Resume: fired correctly but no follow-up check                â”‚
# â”‚                                                                             â”‚
# â”‚  DETECTION (per-TRV, avoids room masking):                                 â”‚
# â”‚    state=heat AND hvac_action=idle AND deficitâ‰¥2Â°C AND stuck>60min         â”‚
# â”‚                                                                             â”‚
# â”‚  TWO-PHASE RECOVERY:                                                       â”‚
# â”‚    Phase 1 (gentle): MQTT open_window OFF + re-poke setpoint               â”‚
# â”‚    Phase 2 (aggressive): offâ†’heatâ†’MQTT resetâ†’setpoint (if Phase 1 fails)  â”‚
# â”‚                                                                             â”‚
# â”‚  RATE LIMIT: 3 attempts/hour per TRV via input_number + input_datetime     â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# =============================================================================

# -----------------------------------------------------------------------------
# STUCK-IDLE RECOVERY â€” Detect + auto-recover TRVs stuck in idle with temp deficit
# -----------------------------------------------------------------------------
- id: thermostat_stuck_idle_recovery
  alias: "Thermostat Stuck-Idle Recovery"
  description: >
    Detects TRVs in heat mode with hvac_action=idle for >60min despite â‰¥2Â°C deficit.
    Two-phase recovery: gentle MQTT reset first, then aggressive off/heat cycle.
  mode: single

  trigger:
    # Poll every 15 minutes (primary detection)
    - platform: time_pattern
      minutes: "/15"
    # Also check 5 minutes after HA startup (catch stuck state from before restart)
    - platform: homeassistant
      event: start

  condition:
    # Don't interfere with intentional shutoffs
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"

  action:
    # Delay 5 minutes on HA startup to let entities settle
    - if:
        - condition: template
          value_template: "{{ trigger.platform == 'homeassistant' }}"
      then:
        - delay:
            minutes: 5

    # â”€â”€â”€ Build list of stuck-idle thermostats â”€â”€â”€
    # Per-TRV detection avoids room masking (Living Inner masked by Living Outer)
    - variables:
        stuck_thermostats: >
          {% set stuck = [] %}
          {% set now_ts = as_timestamp(now()) %}

          {# === Study === #}
          {% set e = 'climate.study_thermostat' %}
          {% set window_start_ts = as_timestamp(states('input_datetime.study_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.study_idle_recovery_count') | int(0) %}
          {% set count = 0 if (now_ts - window_start_ts) > 3600 else count %}
          {% if states(e) == 'heat'
                and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0
                and (now_ts - as_timestamp(states[e].last_changed)) > 3600
                and count < 3 %}
            {% set stuck = stuck + [{'name': 'study', 'entity': e,
                                      'setpoint': state_attr(e, 'temperature') | float(19),
                                      'current': state_attr(e, 'current_temperature') | float(0),
                                      'battery': states('sensor.study_thermostat_battery') | int(100),
                                      'mqtt_topic': 'zigbee2mqtt/[Study] Thermostat/set',
                                      'count_entity': 'input_number.study_idle_recovery_count',
                                      'window_entity': 'input_datetime.study_idle_recovery_window_start'}] %}
          {% endif %}

          {# === Living Inner === #}
          {% set e = 'climate.living_thermostat_inner' %}
          {% set window_start_ts = as_timestamp(states('input_datetime.living_inner_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.living_inner_idle_recovery_count') | int(0) %}
          {% set count = 0 if (now_ts - window_start_ts) > 3600 else count %}
          {% if states(e) == 'heat'
                and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0
                and (now_ts - as_timestamp(states[e].last_changed)) > 3600
                and count < 3 %}
            {% set stuck = stuck + [{'name': 'living_inner', 'entity': e,
                                      'setpoint': state_attr(e, 'temperature') | float(19),
                                      'current': state_attr(e, 'current_temperature') | float(0),
                                      'battery': states('sensor.living_thermostat_inner_battery') | int(100),
                                      'mqtt_topic': 'zigbee2mqtt/[Living] Thermostat Inner/set',
                                      'count_entity': 'input_number.living_inner_idle_recovery_count',
                                      'window_entity': 'input_datetime.living_inner_idle_recovery_window_start'}] %}
          {% endif %}

          {# === Living Outer === #}
          {% set e = 'climate.living_thermostat_outer' %}
          {% set window_start_ts = as_timestamp(states('input_datetime.living_outer_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.living_outer_idle_recovery_count') | int(0) %}
          {% set count = 0 if (now_ts - window_start_ts) > 3600 else count %}
          {% if states(e) == 'heat'
                and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0
                and (now_ts - as_timestamp(states[e].last_changed)) > 3600
                and count < 3 %}
            {% set stuck = stuck + [{'name': 'living_outer', 'entity': e,
                                      'setpoint': state_attr(e, 'temperature') | float(19),
                                      'current': state_attr(e, 'current_temperature') | float(0),
                                      'battery': states('sensor.living_thermostat_outer_battery') | int(100),
                                      'mqtt_topic': 'zigbee2mqtt/[Living] Thermostat Outer/set',
                                      'count_entity': 'input_number.living_outer_idle_recovery_count',
                                      'window_entity': 'input_datetime.living_outer_idle_recovery_window_start'}] %}
          {% endif %}

          {# === Bedroom === #}
          {% set e = 'climate.bed_thermostat' %}
          {% set window_start_ts = as_timestamp(states('input_datetime.bedroom_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.bedroom_idle_recovery_count') | int(0) %}
          {% set count = 0 if (now_ts - window_start_ts) > 3600 else count %}
          {% if states(e) == 'heat'
                and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0
                and (now_ts - as_timestamp(states[e].last_changed)) > 3600
                and count < 3 %}
            {% set stuck = stuck + [{'name': 'bedroom', 'entity': e,
                                      'setpoint': state_attr(e, 'temperature') | float(19),
                                      'current': state_attr(e, 'current_temperature') | float(0),
                                      'battery': states('sensor.bed_thermostat_battery') | int(100),
                                      'mqtt_topic': 'zigbee2mqtt/[Bed] Thermostat/set',
                                      'count_entity': 'input_number.bedroom_idle_recovery_count',
                                      'window_entity': 'input_datetime.bedroom_idle_recovery_window_start'}] %}
          {% endif %}

          {{ stuck }}

    # Only proceed if we found stuck thermostats
    - condition: template
      value_template: "{{ stuck_thermostats | length > 0 }}"

    # Log to InfluxDB
    - service: influxdb.write
      data:
        measurement: thermostat_events
        tags:
          event_type: stuck_idle_detected
        fields:
          thermostats: "{{ stuck_thermostats | map(attribute='name') | join(',') }}"
          count: "{{ stuck_thermostats | length }}"

    # â”€â”€â”€ Phase 1: Gentle recovery (MQTT reset + re-poke setpoint) â”€â”€â”€
    # Fixes the common case: open_window flag stuck from previous off cycle
    - repeat:
        for_each: "{{ stuck_thermostats }}"
        sequence:
          # Skip low-battery TRVs (alert only, no auto-recovery)
          - if:
              - condition: template
                value_template: "{{ repeat.item.battery < 40 }}"
            then:
              - service: notify.all_phones
                data:
                  title: "ðŸ”‹ TRV Low Battery â€” Skipping Recovery"
                  message: >
                    {{ repeat.item.name | replace('_', ' ') | title }} stuck idle
                    ({{ repeat.item.current }}Â°C / {{ repeat.item.setpoint }}Â°C target)
                    but battery at {{ repeat.item.battery }}%. Manual fix needed.
                  data:
                    channel: "Warning"
                    importance: high
                    tag: "stuck_idle_battery_{{ repeat.item.name }}"
            else:
              # Phase 1: Reset open_window flag via MQTT (retain=true in case TRV is offline)
              - service: mqtt.publish
                data:
                  topic: "{{ repeat.item.mqtt_topic }}"
                  payload: '{"open_window": "OFF"}'
                  retain: true
              # Re-poke setpoint to wake up TRV controller
              - service: climate.set_temperature
                target:
                  entity_id: "{{ repeat.item.entity }}"
                data:
                  temperature: "{{ repeat.item.setpoint }}"
              - delay:
                  seconds: 3

    # Wait for Phase 1 to take effect
    - delay:
        seconds: 60

    # â”€â”€â”€ Re-check: which TRVs are still stuck after Phase 1? â”€â”€â”€
    - variables:
        still_stuck: >
          {% set stuck = [] %}
          {% for trv in stuck_thermostats %}
            {% if trv.battery >= 40
                  and states(trv.entity) == 'heat'
                  and state_attr(trv.entity, 'hvac_action') == 'idle'
                  and (state_attr(trv.entity, 'temperature') | float(20)) - (state_attr(trv.entity, 'current_temperature') | float(20)) >= 2.0 %}
              {% set stuck = stuck + [trv] %}
            {% endif %}
          {% endfor %}
          {{ stuck }}

    # â”€â”€â”€ Phase 2: Aggressive recovery (offâ†’heat cycle) for still-stuck TRVs â”€â”€â”€
    - if:
        - condition: template
          value_template: "{{ still_stuck | length > 0 }}"
      then:
        - repeat:
            for_each: "{{ still_stuck }}"
            sequence:
              # Save setpoint with floor guard (race condition protection)
              - variables:
                  safe_setpoint: "{{ [repeat.item.setpoint, 18] | max }}"

              # Off â†’ 5s â†’ Heat â†’ MQTT reset â†’ 5s â†’ Setpoint
              - service: climate.set_hvac_mode
                target:
                  entity_id: "{{ repeat.item.entity }}"
                data:
                  hvac_mode: "off"
              - delay:
                  seconds: 5
              - service: climate.set_hvac_mode
                target:
                  entity_id: "{{ repeat.item.entity }}"
                data:
                  hvac_mode: "heat"
              - service: mqtt.publish
                data:
                  topic: "{{ repeat.item.mqtt_topic }}"
                  payload: '{"open_window": "OFF"}'
                  retain: true
              - delay:
                  seconds: 5
              - service: climate.set_temperature
                target:
                  entity_id: "{{ repeat.item.entity }}"
                data:
                  temperature: "{{ safe_setpoint }}"

              # Update rate limit counter
              # IMPORTANT: Reset window FIRST, then set count, then increment
              # (prevents race where expired window allows >3 attempts)
              - service: input_datetime.set_datetime
                target:
                  entity_id: "{{ repeat.item.window_entity }}"
                data:
                  datetime: >
                    {% set window_ts = as_timestamp(states(repeat.item.window_entity)) | default(0) %}
                    {% if (as_timestamp(now()) - window_ts) > 3600 %}
                      {{ now().strftime('%Y-%m-%d %H:%M:%S') }}
                    {% else %}
                      {{ states(repeat.item.window_entity) }}
                    {% endif %}
              - service: input_number.set_value
                target:
                  entity_id: "{{ repeat.item.count_entity }}"
                data:
                  value: >
                    {% set window_ts = as_timestamp(states(repeat.item.window_entity)) | default(0) %}
                    {% set count = states(repeat.item.count_entity) | int(0) %}
                    {% if (as_timestamp(now()) - window_ts) > 3600 %}0{% else %}{{ count }}{% endif %}
              - service: input_number.increment
                target:
                  entity_id: "{{ repeat.item.count_entity }}"

              - delay:
                  seconds: 3

        # Notify about Phase 2 recovery
        - service: notify.all_phones
          data:
            title: "ðŸ”§ TRV Stuck-Idle Recovery (Phase 2)"
            message: >
              Auto-recovering: {{ still_stuck | map(attribute='name') | join(', ') | replace('_', ' ') | title }}.
              Offâ†’heat cycle performed. Check if heating resumes.
            data:
              channel: "Warning"
              importance: high
              tag: "stuck_idle_recovery"

        # TTS (respect quiet hours)
        - if:
            - condition: template
              value_template: "{{ now().hour >= 7 and now().hour < 23 }}"
          then:
            - service: script.smart_tts_announce
              data:
                message: >
                  Recovering stuck thermostat.
                  {{ still_stuck | map(attribute='name') | join(' and ') | replace('_', ' ') }}.
                title: "ðŸ”§ Stuck-Idle Recovery"

        # Email alert
        - service: script.send_alert_email
          data:
            severity: "WARNING"
            title: "TRV Stuck-Idle Recovery"
            subtitle: "{{ still_stuck | map(attribute='name') | join(', ') | replace('_', ' ') | title }}"
            description: >
              Phase 2 recovery (offâ†’heat cycle) performed for stuck TRV(s).
              Detection: mode=heat, action=idle, deficit â‰¥ 2Â°C for > 60 minutes.
            actions: "Check HA dashboard for heating status|Verify TRV valve is opening|Check battery level"
            details: >
              {% for trv in still_stuck %}
              {{ trv.name | replace('_', ' ') | title }}: {{ trv.current }}Â°C / {{ trv.setpoint }}Â°C target, battery {{ trv.battery }}%
              {% endfor %}

        # Log to InfluxDB
        - service: influxdb.write
          data:
            measurement: thermostat_events
            tags:
              event_type: stuck_idle_phase2_recovery
            fields:
              thermostats: "{{ still_stuck | map(attribute='name') | join(',') }}"
              count: "{{ still_stuck | length }}"

      else:
        # Phase 1 was enough â€” log success quietly
        - service: influxdb.write
          data:
            measurement: thermostat_events
            tags:
              event_type: stuck_idle_phase1_success
            fields:
              thermostats: "{{ stuck_thermostats | map(attribute='name') | join(',') }}"

# -----------------------------------------------------------------------------
# STUCK-IDLE MAX ATTEMPTS â€” Escalation alert when recovery fails
# -----------------------------------------------------------------------------
- id: thermostat_stuck_idle_max_attempts
  alias: "Thermostat Stuck-Idle Max Attempts Alert"
  description: >
    CRITICAL alert when a TRV has had 3+ recovery attempts in 1 hour and is still stuck.
    Manual intervention required â€” likely hardware issue (valve motor, battery).
  mode: single

  trigger:
    - platform: time_pattern
      minutes: "/15"

  condition:
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"

  action:
    - variables:
        maxed_out: >
          {% set maxed = [] %}
          {% set now_ts = as_timestamp(now()) %}

          {% set e = 'climate.study_thermostat' %}
          {% set window_ts = as_timestamp(states('input_datetime.study_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.study_idle_recovery_count') | int(0) %}
          {% if count >= 3 and (now_ts - window_ts) <= 3600
                and states(e) == 'heat' and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0 %}
            {% set maxed = maxed + [{'name': 'Study', 'current': state_attr(e, 'current_temperature') | float(0),
                                      'setpoint': state_attr(e, 'temperature') | float(0),
                                      'battery': states('sensor.study_thermostat_battery') | int(0)}] %}
          {% endif %}

          {% set e = 'climate.living_thermostat_inner' %}
          {% set window_ts = as_timestamp(states('input_datetime.living_inner_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.living_inner_idle_recovery_count') | int(0) %}
          {% if count >= 3 and (now_ts - window_ts) <= 3600
                and states(e) == 'heat' and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0 %}
            {% set maxed = maxed + [{'name': 'Living Inner', 'current': state_attr(e, 'current_temperature') | float(0),
                                      'setpoint': state_attr(e, 'temperature') | float(0),
                                      'battery': states('sensor.living_thermostat_inner_battery') | int(0)}] %}
          {% endif %}

          {% set e = 'climate.living_thermostat_outer' %}
          {% set window_ts = as_timestamp(states('input_datetime.living_outer_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.living_outer_idle_recovery_count') | int(0) %}
          {% if count >= 3 and (now_ts - window_ts) <= 3600
                and states(e) == 'heat' and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0 %}
            {% set maxed = maxed + [{'name': 'Living Outer', 'current': state_attr(e, 'current_temperature') | float(0),
                                      'setpoint': state_attr(e, 'temperature') | float(0),
                                      'battery': states('sensor.living_thermostat_outer_battery') | int(0)}] %}
          {% endif %}

          {% set e = 'climate.bed_thermostat' %}
          {% set window_ts = as_timestamp(states('input_datetime.bedroom_idle_recovery_window_start')) | default(0) %}
          {% set count = states('input_number.bedroom_idle_recovery_count') | int(0) %}
          {% if count >= 3 and (now_ts - window_ts) <= 3600
                and states(e) == 'heat' and state_attr(e, 'hvac_action') == 'idle'
                and (state_attr(e, 'temperature') | float(20)) - (state_attr(e, 'current_temperature') | float(20)) >= 2.0 %}
            {% set maxed = maxed + [{'name': 'Bedroom', 'current': state_attr(e, 'current_temperature') | float(0),
                                      'setpoint': state_attr(e, 'temperature') | float(0),
                                      'battery': states('sensor.bed_thermostat_battery') | int(0)}] %}
          {% endif %}

          {{ maxed }}

    - condition: template
      value_template: "{{ maxed_out | length > 0 }}"

    - service: notify.all_phones
      data:
        title: "ðŸš¨ CRITICAL: TRV Recovery Failed"
        message: >
          {{ maxed_out | length }} thermostat(s) still stuck after 3 recovery attempts!
          {% for trv in maxed_out %}
          {{ trv.name }}: {{ trv.current }}Â°C (target {{ trv.setpoint }}Â°C), battery {{ trv.battery }}%
          {% endfor %}
          Manual fix needed: check battery and valve motor.
        data:
          channel: "Critical"
          importance: max
          tag: "stuck_idle_critical"

    - service: script.send_alert_email
      data:
        severity: "CRITICAL"
        title: "TRV Recovery Failed â€” Manual Fix Required"
        subtitle: "{{ maxed_out | map(attribute='name') | join(', ') }}"
        description: >
          3 auto-recovery attempts failed in the last hour. The TRV valve motor may be
          seized or the battery too low to drive the motor. Physical intervention required.
        actions: "Remove TRV and manually open valve|Replace battery|Reset TRV via Z2M re-pair"
        details: >
          {% for trv in maxed_out %}
          {{ trv.name }}: {{ trv.current }}Â°C / {{ trv.setpoint }}Â°C, battery {{ trv.battery }}%
          {% endfor %}

    - service: influxdb.write
      data:
        measurement: thermostat_events
        tags:
          event_type: stuck_idle_max_attempts
        fields:
          thermostats: "{{ maxed_out | map(attribute='name') | join(',') }}"

# =============================================================================
# DAILY VALVE EXERCISE (Fix 3, Feb 9 2026)
# =============================================================================
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  INCIDENT: Feb 9, 2026 â€” Bedroom TRV valve motor seized after         â”‚
# â”‚  extended idle period. Motor voltage degraded 2070â†’1662 mV.           â”‚
# â”‚                                                                         â”‚
# â”‚  PREVENTION: At 3:07 AM, briefly bump each TRV's setpoint by 5Â°C for â”‚
# â”‚  30 seconds, then restore. Forces the valve to open/close, preventing â”‚
# â”‚  the motor from seizing due to prolonged inactivity.                  â”‚
# â”‚  Time offset from 03:00 to avoid collision with /15 minute polls.    â”‚
# â”‚                                                                         â”‚
# â”‚  Timeline per TRV:                                                     â”‚
# â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
# â”‚  â”‚ MQTT     â”‚ Bump     â”‚ Wait     â”‚ Restore  â”‚ Pause    â”‚            â”‚
# â”‚  â”‚ reset    â”‚ +5Â°C     â”‚ 30s      â”‚ +verify  â”‚ 15s      â”‚            â”‚
# â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
# â”‚                                                                         â”‚
# â”‚  Safety: Only TRVs in heat mode, no windows open, no CO2 guard.      â”‚
# â”‚  3 AM chosen: everyone asleep, brief temp bump is imperceptible.      â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# =============================================================================

- id: daily_valve_exercise
  alias: "Daily Valve Exercise (3:07 AM)"
  description: >
    At 3:07 AM, briefly bump setpoint on all TRVs in heat mode by 5Â°C for 30s,
    then restore. Forces valve motor to open/close, preventing seizure.
    Time offset from 03:00 to avoid collision with /15 minute poll automations.
  mode: single

  trigger:
    # Offset from 03:00 to avoid collision with time_pattern /15 automations
    # (stuck-idle recovery polls at :00, :15, :30, :45)
    - platform: time
      at: "03:07:00"

  condition:
    # Safety: no windows open
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_window
      state: "off"
    # Safety: no CO2 guard
    - condition: state
      entity_id: input_boolean.heaters_off_due_to_co2
      state: "off"

  action:
    - variables:
        thermostats:
          - entity_id: climate.study_thermostat
            name: Study
            mqtt_topic: "zigbee2mqtt/[Study] Thermostat/set"
            battery_entity: sensor.study_thermostat_battery
          - entity_id: climate.living_thermostat_inner
            name: Living Inner
            mqtt_topic: "zigbee2mqtt/[Living] Thermostat Inner/set"
            battery_entity: sensor.living_thermostat_inner_battery
          - entity_id: climate.living_thermostat_outer
            name: Living Outer
            mqtt_topic: "zigbee2mqtt/[Living] Thermostat Outer/set"
            battery_entity: sensor.living_thermostat_outer_battery
          - entity_id: climate.bed_thermostat
            name: Bedroom
            mqtt_topic: "zigbee2mqtt/[Bed] Thermostat/set"
            battery_entity: sensor.bed_thermostat_battery

    - repeat:
        for_each: "{{ thermostats }}"
        sequence:
          # Only exercise TRVs in heat mode
          - condition: template
            value_template: "{{ states(repeat.item.entity_id) == 'heat' }}"

          # Skip low-battery TRVs (motor exercise drains battery)
          - condition: template
            value_template: "{{ states(repeat.item.battery_entity) | int(100) >= 40 }}"

          - variables:
              original_setpoint: "{{ state_attr(repeat.item.entity_id, 'temperature') | float(18) }}"
              exercise_setpoint: "{{ [original_setpoint + 5, 30] | min }}"

          # Clear any stuck open_window flag first
          - service: mqtt.publish
            data:
              topic: "{{ repeat.item.mqtt_topic }}"
              payload: '{"open_window": "OFF"}'
              retain: true
          - delay:
              seconds: 3

          # Bump setpoint (forces valve to open wider)
          - service: climate.set_temperature
            target:
              entity_id: "{{ repeat.item.entity_id }}"
            data:
              temperature: "{{ exercise_setpoint }}"

          # Wait for valve to physically move
          - delay:
              seconds: 30

          # Restore original setpoint (with retry â€” if this fails, TRV stays hot)
          - service: climate.set_temperature
            target:
              entity_id: "{{ repeat.item.entity_id }}"
            data:
              temperature: "{{ original_setpoint }}"
          - delay:
              seconds: 5

          # Verify restore succeeded â€” retry once if not
          - if:
              - condition: template
                value_template: >
                  {{ state_attr(repeat.item.entity_id, 'temperature') | float(0) != original_setpoint | float(0) }}
            then:
              - service: climate.set_temperature
                target:
                  entity_id: "{{ repeat.item.entity_id }}"
                data:
                  temperature: "{{ original_setpoint }}"

          # Pause between TRVs (space out Zigbee commands)
          - delay:
              seconds: 15

    # Log to InfluxDB
    - service: influxdb.write
      data:
        measurement: thermostat_events
        tags:
          event_type: daily_valve_exercise
        fields:
          status: "completed"

# =============================================================================
# PRESENCE-BASED LIGHTING (AUTO-OFF)
# =============================================================================
# Trigger: mmWave human presence sensors
# Action: Turn off lights when no presence detected
# Note: Lights are turned ON manually, only AUTO-OFF when room is empty
# Created: 2026-01-19
# =============================================================================

# -----------------------------------------------------------------------------
# BEDROOM - Light OFF when unoccupied
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  Dual-trigger pattern (resilient to HA automation reloads):   â”‚
# â”‚                                                                â”‚
# â”‚  Trigger 1: state â†’ "off"     (instant response)              â”‚
# â”‚  Trigger 2: time_pattern /5   (fallback every 5 min)          â”‚
# â”‚                                                                â”‚
# â”‚  WHY: HA state triggers only fire on transitions.             â”‚
# â”‚  If automations reload while sensor is already "off",         â”‚
# â”‚  the state trigger never fires â†’ lights stay on forever.      â”‚
# â”‚  The periodic trigger catches this edge case.                  â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# -----------------------------------------------------------------------------
- id: bed_presence_light_off
  alias: "[Bed] Light Off When Unoccupied"
  description: "Turn off bedroom light when no human presence"
  mode: single

  trigger:
    # Instant: fires the moment presence sensor transitions to off
    - platform: state
      entity_id: binary_sensor.bed_human_presence_occupancy
      to: "off"
    # Fallback: catches missed transitions after HA restart/reload
    - platform: time_pattern
      minutes: "/5"

  condition:
    # Light must actually be on (skips no-op turn_off calls)
    - condition: state
      entity_id: switch.bed_light_switch
      state: "on"
    # Presence must be off for 30s (filters mmWave sensor glitches)
    - condition: state
      entity_id: binary_sensor.bed_human_presence_occupancy
      state: "off"
      for: "00:00:30"

  action:
    - service: switch.turn_off
      target:
        entity_id: switch.bed_light_switch

# -----------------------------------------------------------------------------
# LIVING - IKEA Light OFF when unoccupied
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  Dual-trigger pattern (resilient to HA automation reloads):   â”‚
# â”‚                                                                â”‚
# â”‚  Trigger 1: state â†’ "off"     (instant response)              â”‚
# â”‚  Trigger 2: time_pattern /5   (fallback every 5 min)          â”‚
# â”‚                                                                â”‚
# â”‚  See Bedroom automation above for detailed rationale.          â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# -----------------------------------------------------------------------------
- id: living_presence_ikea_light_off
  alias: "[Living] IKEA Light Off When Unoccupied"
  description: "Turn off Living IKEA light when no human presence"
  mode: single

  trigger:
    # Instant: fires the moment presence sensor transitions to off
    - platform: state
      entity_id: binary_sensor.living_human_presence_occupancy
      to: "off"
    # Fallback: catches missed transitions after HA restart/reload
    - platform: time_pattern
      minutes: "/5"

  condition:
    # Light must actually be on (skips no-op turn_off calls)
    - condition: state
      entity_id: light.living_ikea_light
      state: "on"
    # Presence must be off for 30s (filters mmWave sensor glitches)
    - condition: state
      entity_id: binary_sensor.living_human_presence_occupancy
      state: "off"
      for: "00:00:30"

  action:
    - service: light.turn_off
      target:
        entity_id: light.living_ikea_light
    # Clear circadian override so next power-on gets scheduled values
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.circadian_living_override

# -----------------------------------------------------------------------------
# STUDY - IKEA Light OFF when unoccupied
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  Dual-trigger pattern (resilient to HA automation reloads):   â”‚
# â”‚                                                                â”‚
# â”‚  Trigger 1: state â†’ "off"     (instant response)              â”‚
# â”‚  Trigger 2: time_pattern /5   (fallback every 5 min)          â”‚
# â”‚                                                                â”‚
# â”‚  See Bedroom automation above for detailed rationale.          â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# -----------------------------------------------------------------------------
- id: study_presence_ikea_light_off
  alias: "[Study] IKEA Light Off When Unoccupied"
  description: "Turn off Study IKEA light when no human presence"
  mode: single

  trigger:
    # Instant: fires the moment presence sensor transitions to off
    - platform: state
      entity_id: binary_sensor.study_human_presence_occupancy
      to: "off"
    # Fallback: catches missed transitions after HA restart/reload
    - platform: time_pattern
      minutes: "/5"

  condition:
    # Light must actually be on (skips no-op turn_off calls)
    - condition: state
      entity_id: light.study_ikea_light
      state: "on"
    # Presence must be off for 30s (filters mmWave sensor glitches)
    - condition: state
      entity_id: binary_sensor.study_human_presence_occupancy
      state: "off"
      for: "00:00:30"

  action:
    - service: light.turn_off
      target:
        entity_id: light.study_ikea_light
    # Clear circadian override so next power-on gets scheduled values
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.circadian_study_override

# -----------------------------------------------------------------------------
# KITCHEN - TTS reminder if lights appear on when unoccupied
# Uses illumination sensor (no smart lights in kitchen)
# Repeats every 3 minutes until light is turned off
# Only during non-quiet hours (07:00-23:00) and after sunset
# -----------------------------------------------------------------------------
- id: kitchen_presence_light_reminder
  alias: "[Kitchen] Light Reminder When Unoccupied"
  description: "Repeating TTS reminder every 3 min if kitchen light on with no presence"
  enabled: false
  mode: single

  trigger:
    # Check every 3 minutes
    - platform: time_pattern
      minutes: "/3"

  condition:
    # No human presence in kitchen
    - condition: state
      entity_id: binary_sensor.kitchen_human_presence_occupancy
      state: "off"
    # Light is on (illumination sensor reads bright)
    - condition: state
      entity_id: sensor.kitchen_human_presence_illumination
      state: "bright"
    # Non-quiet hours (07:00-23:00)
    - condition: time
      after: "07:00:00"
      before: "23:00:00"
    # After sunset (avoid false positives from sunlight)
    - condition: state
      entity_id: sun.sun
      state: "below_horizon"

  action:
    - service: script.smart_tts_announce
      data:
        message: "Kitchen light is still on"
        title: "ðŸ’¡ Kitchen Light"

# -----------------------------------------------------------------------------
# BATHROOM - AwoX Light ON when occupied (presence detected)
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  WHY THIS EXISTS:                                              â”‚
# â”‚  AwoX bath light has NO physical switch (unlike IKEA rooms    â”‚
# â”‚  which use SONOFF relay switches that cut/restore power).      â”‚
# â”‚  When bath_presence_light_off turns it off via Zigbee,         â”‚
# â”‚  the bulb stays powered but dark â€” needs a turn_on command.    â”‚
# â”‚                                                                â”‚
# â”‚  CIRCADIAN: We only call light.turn_on â€” the existing          â”‚
# â”‚  circadian_power_on detects the offâ†’on transition and sets     â”‚
# â”‚  brightness + 2200K automatically. At 3 AM = ~5%. Noon = 100%.â”‚
# â”‚                                                                â”‚
# â”‚  Dual-trigger pattern (same as light_off):                     â”‚
# â”‚  Trigger 1: state â†’ "on"      (instant: person enters)        â”‚
# â”‚  Trigger 2: time_pattern /5   (fallback for HA restarts)       â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# -----------------------------------------------------------------------------
- id: bath_presence_light_on
  alias: "[Bath] Light On When Occupied"
  description: "Turn on Bath AwoX light when human presence detected"
  mode: single

  trigger:
    # Instant: fires the moment presence sensor transitions to on
    - platform: state
      entity_id: binary_sensor.bath_human_presence_occupancy
      to: "on"
    # Fallback: catches HA restart while person is in dark bathroom
    - platform: time_pattern
      minutes: "/5"

  condition:
    # Light must be OFF (don't re-trigger if already on)
    - condition: state
      entity_id: light.bath_light
      state: "off"
    # Presence must be ON (essential for the periodic fallback)
    - condition: state
      entity_id: binary_sensor.bath_human_presence_occupancy
      state: "on"

  action:
    # Just turn on â€” circadian_power_on handles brightness & color temp
    - service: light.turn_on
      target:
        entity_id: light.bath_light

# -----------------------------------------------------------------------------
# BATHROOM - AwoX Light OFF when unoccupied for 3 minutes
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  Dual-trigger pattern (resilient to HA automation reloads):   â”‚
# â”‚                                                                â”‚
# â”‚  Trigger 1: state â†’ "off" for 3 min  (event-driven + grace)  â”‚
# â”‚  Trigger 2: time_pattern /5          (fallback every 5 min)   â”‚
# â”‚                                                                â”‚
# â”‚  Timeline (state trigger):                                     â”‚
# â”‚  Person leaves â”€â”€â–º Sensor keep_time â”€â”€â–º occupancy: off         â”‚
# â”‚                                               â”‚                â”‚
# â”‚                                    â”Œâ”€â”€â”€â”€ for: 3 min â”€â”€â”€â”€â”     â”‚
# â”‚                                    â”‚  (someone returns?  â”‚     â”‚
# â”‚                                    â”‚   â†’ cancel)         â”‚     â”‚
# â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
# â”‚                                               â”‚                â”‚
# â”‚                                          Light OFF             â”‚
# â”‚                                                                â”‚
# â”‚  Total: ~(keep_time + 3 min) from last movement               â”‚
# â”‚                                                                â”‚
# â”‚  Condition `for: 00:03:00` on presence check ensures the      â”‚
# â”‚  periodic trigger also respects the 3-min grace period.        â”‚
# â”‚  (Redundant for state trigger which already waited 3 min,     â”‚
# â”‚   essential for periodic trigger which knows no history.)      â”‚
# â”‚                                                                â”‚
# â”‚  Note: The trigger's `for:` timer resets on HA reload, which  â”‚
# â”‚  is exactly why the periodic fallback is needed here.          â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# -----------------------------------------------------------------------------
- id: bath_presence_light_off
  alias: "[Bath] Light Off When Unoccupied"
  description: "Turn off Bath AwoX light after 3 min of no human presence"
  mode: single

  trigger:
    # Event-driven (with grace): fires after presence off for 3 continuous minutes
    - platform: state
      entity_id: binary_sensor.bath_human_presence_occupancy
      to: "off"
      for: "00:03:00"
    # Fallback: catches missed transitions after HA restart/reload
    - platform: time_pattern
      minutes: "/5"

  condition:
    # Light must actually be on
    - condition: state
      entity_id: light.bath_light
      state: "on"
    # Presence must be off for at least 3 min
    # (redundant for state trigger which already waited 3 min, essential for periodic)
    - condition: state
      entity_id: binary_sensor.bath_human_presence_occupancy
      state: "off"
      for: "00:03:00"

  action:
    - service: light.turn_off
      target:
        entity_id: light.bath_light
    # Clear circadian override so next power-on gets scheduled values
    # Without this: manual remote adjust â†’ auto-off â†’ next entry
    # would silently skip circadian schedule for up to 25 minutes
    - service: input_boolean.turn_off
      target:
        entity_id: input_boolean.circadian_bath_override

# -----------------------------------------------------------------------------
# BATHROOM - TTS reminder (LEGACY - disabled, replaced by bath_presence_light_off)
# Kept for reference; was used before AwoX smart light was installed
# -----------------------------------------------------------------------------
# LEGACY: bath_presence_light_reminder removed
# Was: TTS reminder every 3 min if bathroom light on with no presence
# Replaced by: bath_presence_light_off (auto-turns off after 3 min unoccupied)

# =============================================================================
# THERMOSTAT LOW BATTERY ALERT
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  PURPOSE: Email alert when radiator valve battery drops < 30%           â”‚
# â”‚                                                                         â”‚
# â”‚  WHY 30%?                                                               â”‚
# â”‚  TRVZB valves report battery in 1% steps. At 20% the valve may fail   â”‚
# â”‚  to actuate in cold weather (motor needs more current). 30% gives      â”‚
# â”‚  ~2 weeks warning to order CR2450 replacements.                        â”‚
# â”‚                                                                         â”‚
# â”‚  COOLDOWN: 24 hours per thermostat (once/day is enough nagging)        â”‚
# â”‚                                                                         â”‚
# â”‚  Battery levels as of Feb 2026:                                        â”‚
# â”‚    Study: 91%  â”‚  Bed: 100%  â”‚  Living Inner: 67%  â”‚  Living Outer: 81%â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
# =============================================================================

- id: thermostat_low_battery_alert
  alias: "Thermostat Low Battery Alert"
  description: "Alert when any thermostat battery drops below 30%"
  mode: parallel
  max: 4

  trigger:
    - platform: numeric_state
      entity_id: sensor.study_thermostat_battery
      below: 30
    - platform: numeric_state
      entity_id: sensor.bed_thermostat_battery
      below: 30
    - platform: numeric_state
      entity_id: sensor.living_thermostat_inner_battery
      below: 30
    - platform: numeric_state
      entity_id: sensor.living_thermostat_outer_battery
      below: 30

  variables:
    thermostat_names:
      sensor.study_thermostat_battery: "Study"
      sensor.bed_thermostat_battery: "Bedroom"
      sensor.living_thermostat_inner_battery: "Living Inner"
      sensor.living_thermostat_outer_battery: "Living Outer"
    thermostat_name: "{{ thermostat_names.get(trigger.entity_id, trigger.entity_id) }}"
    battery_level: "{{ trigger.to_state.state }}"

  # No cooldown needed: numeric_state trigger only fires once when crossing 30%.
  # Won't re-trigger until battery recovers above 30% and drops again (never
  # happens in practice - battery drain is one-directional on TRVZB valves).

  action:
    # Email only â€” not urgent, 2 weeks to order CR2450 replacement.
    - service: script.send_alert_email
      data:
        severity: "WARNING"
        title: "Thermostat Low Battery"
        subtitle: "{{ thermostat_name }} â€” {{ battery_level }}%"
        description: >-
          {{ thermostat_name }} thermostat battery has dropped below 30%. The TRVZB radiator
          valve may fail to actuate in cold weather when battery is low. Replace soon.
        actions: "Order CR2450 replacement battery|Replace battery before it drops below 15%"
        details: >-
          Battery type: CR2450
          Threshold:    30%

          All thermostat levels:
            Study:        {{ states('sensor.study_thermostat_battery') | replace('unavailable', 'OFFLINE') | replace('unknown', '??') }}%
            Bedroom:      {{ states('sensor.bed_thermostat_battery') | replace('unavailable', 'OFFLINE') | replace('unknown', '??') }}%
            Living Inner: {{ states('sensor.living_thermostat_inner_battery') | replace('unavailable', 'OFFLINE') | replace('unknown', '??') }}%
            Living Outer: {{ states('sensor.living_thermostat_outer_battery') | replace('unavailable', 'OFFLINE') | replace('unknown', '??') }}%
        plain_text: >-
          {{ thermostat_name }} thermostat battery at {{ battery_level }}%. Battery type: CR2450.
          Order replacement before valve stops actuating.
    - service: system_log.write
      data:
        message: "LOW BATTERY: {{ thermostat_name }} thermostat at {{ battery_level }}%"
        level: warning
