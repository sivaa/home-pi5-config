<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Zigbee Network (Standalone)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Use existing dashboard styles -->
  <link rel="stylesheet" href="styles/base.css">
  <link rel="stylesheet" href="styles/layout.css?v=2">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/views/network.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <div class="page">
    <div class="page-header" style="padding: 16px 0 8px;">
      <h1 style="margin:0;font-size:28px;letter-spacing:-0.2px;">Zigbee Network Map</h1>
      <p style="margin:6px 0 0;color:#4a4a4f;">Stand-alone view extracted from the dashboard.</p>
    </div>

    <div class="network-view" x-data="networkView()" x-init="init()">
      <div class="network-controls">
        <button class="network-control-btn" :class="{ active: showSignalRange }"
                @click="showSignalRange = !showSignalRange">
          ğŸ“¶ <span x-text="showSignalRange ? 'Hide Range' : 'Show Range'"></span>
        </button>
        <button class="network-control-btn" :class="{ active: showLabels }"
                @click="showLabels = !showLabels">
          ğŸ·ï¸ <span x-text="showLabels ? 'Hide Labels' : 'Show Labels'"></span>
        </button>
        <button class="network-control-btn" :class="{ active: autoRotate }"
                @click="toggleAutoRotate()">
          ğŸ”„ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
        </button>
        <button class="network-control-btn" :class="{ active: showWallNumbers }"
                @click="toggleWallNumbers()">
          ğŸ”¢ <span x-text="showWallNumbers ? 'Hide #' : 'Show #'"></span>
        </button>
        <button class="network-control-btn" @click="resetView()">ğŸ¯ Reset</button>
        <div class="network-zoom-controls">
          <button class="network-control-btn network-zoom-btn" @click="zoomOut()">â–</button>
          <span class="network-zoom-indicator" x-text="getZoomPercent() + '%'"></span>
          <button class="network-control-btn network-zoom-btn" @click="zoomIn()">â•</button>
        </div>
      </div>

      <div class="network-container" x-ref="networkContainer"></div>

      <div class="network-legend">
        <div class="legend-item">
          <div class="legend-badge coordinator">Z</div>
          <span>Zigbee Coordinator</span>
        </div>
        <div class="legend-item">
          <div class="legend-badge router">R</div>
          <span>Zigbee Router</span>
        </div>
        <div class="legend-item">
          <div class="legend-badge end-device">E</div>
          <span>Zigbee End Device</span>
        </div>
      </div>

      <div class="network-stats">
        <div class="network-stat">
          <span>ğŸ“¡</span>
          <span x-text="deviceCount + ' devices'"></span>
        </div>
        <div class="network-stat">
          <span>ğŸ”—</span>
          <span x-text="routerCount + ' routers'"></span>
        </div>
        <div class="network-stat">
          <span>ğŸ“</span>
          <span x-text="endDeviceCount + ' end devices'"></span>
        </div>
      </div>
    </div>
  </div>

  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <script>
    // Floor plan configuration (mirrored layout used in dashboard network view)
    const FLOOR_PLAN_CONFIG = {
      apartmentWidth: 9.239,
      apartmentDepth: 6.665,  // Reduced depth version used for network view
      wallHeight: 2.0,
      wallThickness: 0.15,
      rooms: [
        { id: 'study', name: 'Study', icon: 'ğŸ“š', x: 7.285, z: 1.8485, width: 3.908, depth: 3.697, color: 0x60a5fa, labelY: 3 },
        { id: 'living', name: 'Living Room', icon: 'ğŸ›‹ï¸', x: 6.864, z: 5.181, width: 4.750, depth: 2.968, color: 0x34d399, labelY: 3 },
        { id: 'bedroom', name: 'Bedroom', icon: 'ğŸ›ï¸', x: 2.2445, z: 5.476, width: 4.489, depth: 2.378, color: 0xfbbf24, labelY: 4 },
        { id: 'kitchen', name: 'Kitchen', icon: 'ğŸ³', x: 1.6655, z: 2.8957, width: 3.331, depth: 2.7827, color: 0xf87171, labelY: 3 },
        { id: 'bathroom', name: 'Bathroom', icon: 'ğŸš¿', x: 1.6985, z: 0.7522, width: 3.397, depth: 1.5043, color: 0xa78bfa, labelY: 2 }
      ],
      balcony: { x: 9.764, z: 7.065, width: 1.050, depth: 1.200, color: 0x93c5fd },
      hallway: { x: 3.839, z: 2.0, width: 1.5, depth: 2.5, color: 0x94a3b8 },
      balconyNotch: {
        width: 1.0,
        depth: 1.5,
        hasRailing: true,
        floorColor: 0xC0C0C2
      },
      doors: [
        { x: 9.239, z: 6.465, rotation: Math.PI/2, type: 'french', swingDirection: 'inward' },
        { x: 3.706, z: 3.697, rotation: 0, swingDirection: 'south' },
        { x: 4.354, z: 1.848, rotation: Math.PI/2, swingDirection: 'east' },
        { x: 3.134, z: 3.697, rotation: 0, swingDirection: 'south' },
        { x: 3.331, z: 2.818, rotation: Math.PI/2, swingDirection: 'east' },
        { x: 3.331, z: 1.338, rotation: Math.PI/2, swingDirection: 'east' },
        { x: 0, z: 4.8, rotation: Math.PI/2, type: 'entry', swingDirection: 'east' }
      ],
      windows: [
        { x: 9.239, z: 1.848, rotation: Math.PI/2, size: 2.5 },
        { x: 9.239, z: 4.2, rotation: Math.PI/2, size: 2.5 },
        { x: 0, z: 5.976, rotation: Math.PI/2, size: 2.5 },
        { x: 0, z: 3.218, rotation: Math.PI/2, size: 1.8 },
        { x: 0, z: 1.487, rotation: Math.PI/2, size: 1.2 }
      ]
    };

    // Device configuration with types and icons
    const ZIGBEE_DEVICES = [
      { id: 'coordinator', name: 'ZBBridge-P', type: 'coordinator', icon: 'ğŸ“¡', room: 'living', x: 0.5, z: 0.4 },
      { id: 'router1', name: 'S60ZBTPF', type: 'router', icon: 'ğŸ“¢', room: 'study', x: 0.8, z: 0.2 },
      { id: 'router2', name: 'S60ZBTPF', type: 'router', icon: 'ğŸ“¢', room: 'living', x: 0.3, z: 0.3 },
      { id: 'sensor1', name: 'SNZB-02P', type: 'end-device', icon: 'ğŸŒ¡ï¸', room: 'bedroom', x: 0.2, z: 0.15 },
      { id: 'sensor2', name: 'SNZB-03P', type: 'end-device', icon: 'ğŸš¶', room: 'kitchen', x: 0.5, z: 0.1 },
      { id: 'sensor3', name: 'SNZB-04P', type: 'end-device', icon: 'ğŸšª', room: 'bathroom', x: 0.85, z: 0.1 },
      { id: 'trv', name: 'TRVZB', type: 'end-device', icon: 'ğŸ”¥', room: 'bedroom', x: 0.1, z: 0.25 }
    ];

    // Shared state for the Three.js scene
    const networkState = {
      scene: null,
      camera: null,
      renderer: null,
      roomMeshes: {},
      wallMeshes: [],
      wallNumberSprites: [],
      deviceMeshes: {},
      labelElements: {},
      signalElements: {},
      animationId: null,
      isInitialized: false,
      panOffset: { x: 0, z: 0 },
      isPanning: false,
      lastPanPos: { x: 0, y: 0 }
    };

    function networkView() {
      const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
      const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

      return {
        showSignalRange: false,
        showLabels: false,
        showWallNumbers: false,
        autoRotate: false,
        rotationAngle: 0,
        zoomLevel: 2.0,
        deviceCount: ZIGBEE_DEVICES.length,
        routerCount: ZIGBEE_DEVICES.filter(d => d.type === 'router').length,
        endDeviceCount: ZIGBEE_DEVICES.filter(d => d.type === 'end-device').length,

        init() { this.waitForContainer(); },

        waitForContainer() {
          const container = this.$refs.networkContainer;
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          if (networkState.isInitialized && networkState.renderer) {
            if (!container.contains(networkState.renderer.domElement)) {
              container.appendChild(networkState.renderer.domElement);
            }
            this.createLabels(container);
            this.onResize();
            return;
          }

          if (networkState.renderer) networkState.renderer.dispose();
          if (networkState.scene) networkState.scene.clear();
          if (networkState.animationId) cancelAnimationFrame(networkState.animationId);

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.addWallNumbers();
          this.createDevices();
          this.createLabels(container);
          this.setupPanControls(container);
          this.animate();
          networkState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          networkState.scene = new THREE.Scene();
          networkState.scene.background = new THREE.Color(0xE8DFD4);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15;
          networkState.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2, 0.1, 1000
          );
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
        },

        initRenderer(container) {
          networkState.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
          networkState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          networkState.renderer.shadowMap.enabled = true;
          networkState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(networkState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.7);
          networkState.scene.add(ambient);
          const directional = new THREE.DirectionalLight(0xffffff, 0.6);
          directional.position.set(15, 20, 15);
          networkState.scene.add(directional);
          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          networkState.scene.add(fill);
        },

        addWallNumbers() {
          networkState.wallNumberSprites.forEach(sprite => {
            networkState.scene.remove(sprite);
            if (sprite.material.map) sprite.material.map.dispose();
            sprite.material.dispose();
          });
          networkState.wallNumberSprites = [];

          const createNumberSprite = (text, color = '#FF0000') => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(String(text), 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(0.4, 0.4, 1);
            return sprite;
          };

          const getOuterWallDirection = (wall) => {
            const apartmentWidth = FLOOR_PLAN_CONFIG.apartmentWidth;
            const apartmentDepth = FLOOR_PLAN_CONFIG.apartmentDepth;
            const halfW = apartmentWidth / 2;
            const halfD = apartmentDepth / 2;
            const tolerance = 0.05;
            const lengthTolerance = 0.2;

            const params = wall.geometry.parameters;
            const isHorizontal = params.width > params.depth;
            const isVertical = params.depth > params.width;

            let result = null;
            if (isHorizontal && Math.abs(params.width - apartmentWidth) < lengthTolerance) {
              if (Math.abs(wall.position.z - (-halfD)) < tolerance) result = 'N';
              else if (Math.abs(wall.position.z - halfD) < tolerance) result = 'S';
            }
            if (isVertical && Math.abs(params.depth - apartmentDepth) < lengthTolerance) {
              if (Math.abs(wall.position.x - (-halfW)) < tolerance) result = 'W';
              else if (Math.abs(wall.position.x - halfW) < tolerance) result = 'E';
            }
            return result;
          };

          networkState.wallMeshes.forEach((wall, index) => {
            const params = wall.geometry.parameters;
            const wx = wall.position.x;
            const wy = wall.position.y + 0.5;
            const wz = wall.position.z;
            const directionLabel = getOuterWallDirection(wall);
            const isHorizontal = params.width > params.depth;
            const wallLength = isHorizontal ? params.width : params.depth;
            const halfLen = wallLength / 2 * 0.8;

            const positions = isHorizontal
              ? [[wx - halfLen, wy, wz], [wx, wy, wz], [wx + halfLen, wy, wz]]
              : [[wx, wy, wz - halfLen], [wx, wy, wz], [wx, wy, wz + halfLen]];

            positions.forEach((pos, i) => {
              const label = directionLabel || index.toString();
              const color = directionLabel ? '#228B22' : (i === 1 ? '#FF0000' : '#0066CC');
              const sprite = createNumberSprite(label, color);
              sprite.position.set(pos[0], pos[1], pos[2]);
              sprite.visible = false;
              networkState.scene.add(sprite);
              networkState.wallNumberSprites.push(sprite);
            });
          });
        },

        toggleWallNumbers() {
          this.showWallNumbers = !this.showWallNumbers;
          networkState.wallNumberSprites.forEach(sprite => {
            sprite.visible = this.showWallNumbers;
          });
        },

        buildFloorPlan() {
          networkState.wallMeshes = [];
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const floorColor = 0xC9B89A;

          const baseFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(FLOOR_PLAN_CONFIG.apartmentWidth + 2, FLOOR_PLAN_CONFIG.apartmentDepth + 2),
            new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 })
          );
          baseFloor.rotation.x = -Math.PI / 2;
          baseFloor.position.set(0, 0.001, 0);
          baseFloor.receiveShadow = true;
          networkState.scene.add(baseFloor);

          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            this.createRoom(config);
          });

          const wallHeight = 0.8;
          const wallMat = new THREE.MeshStandardMaterial({ color: 0xB5A080, roughness: 0.7, transparent: true, opacity: 0.6 });

          const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
          const living = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'living');
          const kitchen = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'kitchen');
          const bedroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bedroom');
          const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');

          const studyFrontZ = study.z + study.depth/2 - 0.5;
          const doorWidth = 0.42;
          const door4X = 3.8;
          const door2X = 4.8;
          const door4Left = door4X - doorWidth/2;
          const door4Right = door4X + doorWidth/2;
          const door2Left = door2X - doorWidth/2;
          const door2Right = door2X + doorWidth/2;

          const wall3LeftWidth = door4Left;
          const wall3Left = new THREE.Mesh(new THREE.BoxGeometry(wall3LeftWidth, wallHeight, 0.08), wallMat);
          wall3Left.position.set(door4Left/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Left);
          networkState.wallMeshes.push(wall3Left);

          const wall3MidWidth = door2Left - door4Right;
          const wall3Mid = new THREE.Mesh(new THREE.BoxGeometry(wall3MidWidth, wallHeight, 0.08), wallMat);
          wall3Mid.position.set(door4Right + wall3MidWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Mid);
          networkState.wallMeshes.push(wall3Mid);

          const wall3RightWidth = FLOOR_PLAN_CONFIG.apartmentWidth - door2Right;
          const wall3Right = new THREE.Mesh(new THREE.BoxGeometry(wall3RightWidth, wallHeight, 0.08), wallMat);
          wall3Right.position.set(door2Right + wall3RightWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Right);
          networkState.wallMeshes.push(wall3Right);

          const wall16Z = 0;
          const wall15Z = study.z + study.depth/2;
          const coatWallLength = (wall15Z - wall16Z) * 0.30;
          const coatWallCenterZ = wall16Z + coatWallLength / 2;
          const coatWallX = 4.6;

          const coatWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, coatWallLength), wallMat);
          coatWall.position.set(coatWallX - centerX, wallHeight/2, coatWallCenterZ - centerZ);
          networkState.scene.add(coatWall);
          networkState.wallMeshes.push(coatWall);

          const mainDoorX = 4.0;
          const mainDoorWidth = 0.42;
          const mainDoorLeft = mainDoorX - mainDoorWidth/2;
          const mainDoorRight = mainDoorX + mainDoorWidth/2;

          const northSeg1Width = mainDoorLeft;
          const northWall1 = new THREE.Mesh(new THREE.BoxGeometry(northSeg1Width, wallHeight, 0.08), wallMat);
          northWall1.position.set(northSeg1Width/2 - centerX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall1);
          networkState.wallMeshes.push(northWall1);

          const northSeg2Width = FLOOR_PLAN_CONFIG.apartmentWidth - mainDoorRight;
          const northSeg2CenterX = (mainDoorRight + FLOOR_PLAN_CONFIG.apartmentWidth) / 2 - centerX;
          const northWall2 = new THREE.Mesh(new THREE.BoxGeometry(northSeg2Width, wallHeight, 0.08), wallMat);
          northWall2.position.set(northSeg2CenterX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall2);
          networkState.wallMeshes.push(northWall2);

          const notch = FLOOR_PLAN_CONFIG.balconyNotch;
          const w2Config = FLOOR_PLAN_CONFIG.windows[1];
          const windowZ = w2Config.z;
          const windowSize = w2Config.size;
          const windowTopZ = windowZ - windowSize / 2;
          const windowBottomZ = windowZ + windowSize / 2;

          const segment1Depth = windowTopZ;
          const segment1CenterZ = (0 + windowTopZ) / 2 - centerZ;
          const westWall1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, wallHeight, segment1Depth),
            wallMat
          );
          westWall1.position.set(-centerX, wallHeight/2, segment1CenterZ);
          networkState.scene.add(westWall1);
          networkState.wallMeshes.push(westWall1);

          const segment2Depth = FLOOR_PLAN_CONFIG.apartmentDepth - windowBottomZ;
          const segment2CenterZ = (windowBottomZ + FLOOR_PLAN_CONFIG.apartmentDepth) / 2 - centerZ;
          const westWall2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, wallHeight, segment2Depth),
            wallMat
          );
          westWall2.position.set(-centerX, wallHeight/2, segment2CenterZ);
          networkState.scene.add(westWall2);
          networkState.wallMeshes.push(westWall2);

          const recessWallMat = new THREE.MeshStandardMaterial({
            color: 0x5A4A30,
            roughness: 0.7,
            transparent: true,
            opacity: 0.7
          });
          const recessedWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, wallHeight, windowSize),
            recessWallMat
          );
          recessedWall.position.set(-centerX, wallHeight/2, windowZ - centerZ);
          networkState.scene.add(recessedWall);
          networkState.wallMeshes.push(recessedWall);

          const southWallZ = FLOOR_PLAN_CONFIG.apartmentDepth;
          const southWallWidth = FLOOR_PLAN_CONFIG.apartmentWidth - notch.width;
          const southWall = new THREE.Mesh(new THREE.BoxGeometry(southWallWidth, wallHeight, 0.08), wallMat);
          southWall.position.set((southWallWidth / 2) - centerX, wallHeight/2, southWallZ - centerZ);
          networkState.scene.add(southWall);
          networkState.wallMeshes.push(southWall);
        },

        createRoom(config) {
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const roomFloor = new THREE.Mesh(
            new THREE.BoxGeometry(config.width, 0.05, config.depth),
            new THREE.MeshStandardMaterial({
              color: config.color,
              transparent: true,
              opacity: 0.3,
              roughness: 0.6,
              metalness: 0.1
            })
          );
          roomFloor.position.set(config.x - centerX, 0.025, config.z - centerZ);
          roomFloor.receiveShadow = true;
          roomFloor.name = 'floor_' + config.id;
          networkState.scene.add(roomFloor);

          const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.25,
            metalness: 0.4,
            roughness: 0.08,
            side: THREE.DoubleSide
          });
          const halfW = config.width / 2, halfD = config.depth / 2;
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;
          const walls = [
            { geo: [config.width, wallHeight, 0.15], pos: [config.x - centerX, wallHeight/2, config.z - centerZ - halfD] },
            { geo: [config.width, wallHeight, 0.15], pos: [config.x - centerX, wallHeight/2, config.z - centerZ + halfD] },
            { geo: [0.15, wallHeight, config.depth], pos: [config.x - centerX - halfW, wallHeight/2, config.z - centerZ] },
            { geo: [0.15, wallHeight, config.depth], pos: [config.x - centerX + halfW, wallHeight/2, config.z - centerZ] }
          ];
          walls.forEach(w => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(...w.geo), wallMaterial);
            wall.position.set(...w.pos);
            wall.castShadow = true;
            networkState.scene.add(wall);
            networkState.wallMeshes.push(wall);
          });
        },

        createDevices() {
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          ZIGBEE_DEVICES.forEach(device => {
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            let color;
            switch (device.type) {
              case 'coordinator': color = 0xFF6B6B; break;
              case 'router': color = 0x4DABF7; break;
              default: color = 0x51CF66;
            }
            const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geometry, material);

            const room = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === device.room);
            if (room) {
              const roomCenterX = room.x - centerX;
              const roomCenterZ = room.z - centerZ;
              mesh.position.set(
                roomCenterX + (device.x - 0.5) * room.width * 0.8,
                0.5,
                roomCenterZ + (device.z - 0.5) * room.depth * 0.8
              );
            }

            mesh.castShadow = true;
            networkState.scene.add(mesh);
            networkState.deviceMeshes[device.id] = { mesh, config: device };
          });
        },

        createLabels(container) {
          Object.values(networkState.labelElements).forEach(el => el?.remove());
          Object.values(networkState.signalElements).forEach(el => el?.remove());
          networkState.labelElements = {};
          networkState.signalElements = {};

          ZIGBEE_DEVICES.forEach(device => {
            const label = document.createElement('div');
            label.className = 'device-label visible';
            label.innerHTML = `
              <div class="device-icon ${device.type}">${device.icon}</div>
              <div class="device-name">${device.name}</div>
            `;
            container.appendChild(label);
            networkState.labelElements[device.id] = label;

            if (device.type === 'coordinator' || device.type === 'router') {
              const signal = document.createElement('div');
              signal.className = `signal-range ${device.type}`;
              signal.style.width = device.type === 'coordinator' ? '200px' : '150px';
              signal.style.height = device.type === 'coordinator' ? '200px' : '150px';
              container.appendChild(signal);
              networkState.signalElements[device.id] = signal;
            }
          });
        },

        updateLabels() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;

          ZIGBEE_DEVICES.forEach(device => {
            const deviceData = networkState.deviceMeshes[device.id];
            const label = networkState.labelElements[device.id];
            const signal = networkState.signalElements[device.id];

            if (!deviceData || !label) return;

            const pos = deviceData.mesh.position.clone();
            pos.y += 0.3;
            pos.project(networkState.camera);

            const x = (pos.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-pos.y * 0.5 + 0.5) * container.clientHeight;

            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.style.display = this.showLabels ? 'flex' : 'none';

            if (signal) {
              signal.style.left = x + 'px';
              signal.style.top = (y + 40) + 'px';
              signal.style.display = this.showSignalRange ? 'block' : 'none';
            }
          });
        },

        setupPanControls(container) {
          container.addEventListener('pointerdown', (e) => {
            if (this.autoRotate) return;
            networkState.isPanning = true;
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
            container.style.cursor = 'grabbing';
          });

          container.addEventListener('pointermove', (e) => {
            if (!networkState.isPanning) return;
            const dx = e.clientX - networkState.lastPanPos.x;
            const dy = e.clientY - networkState.lastPanPos.y;
            networkState.panOffset.x -= dx * 0.02;
            networkState.panOffset.z -= dy * 0.02;
            networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
          });

          container.addEventListener('pointerup', () => {
            networkState.isPanning = false;
            container.style.cursor = 'grab';
          });

          container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.setZoom(this.zoomLevel * delta);
          }, { passive: false });
        },

        setZoom(level) {
          this.zoomLevel = Math.max(0.5, Math.min(3.0, level));
          this.updateCameraZoom();
        },

        updateCameraZoom() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
        },

        zoomIn() { this.setZoom(this.zoomLevel * 1.2); },
        zoomOut() { this.setZoom(this.zoomLevel / 1.2); },

        resetView() {
          this.zoomLevel = 1.0;
          this.autoRotate = false;
          this.rotationAngle = Math.PI / 4;
          networkState.panOffset = { x: 0, z: 0 };
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
          this.updateCameraZoom();
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (this.autoRotate) {
            const pos = networkState.camera.position;
            this.rotationAngle = Math.atan2(pos.x, pos.z);
          }
        },

        animate() {
          const self = this;
          const radius = 17.32;
          const height = 10;

          function loop() {
            networkState.animationId = requestAnimationFrame(loop);

            if (self.autoRotate && networkState.camera) {
              self.rotationAngle += 0.003;
              const x = Math.sin(self.rotationAngle) * radius;
              const z = Math.cos(self.rotationAngle) * radius;
              networkState.camera.position.set(x, height, z);
              networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            }

            self.updateLabels();
            if (networkState.renderer && networkState.scene && networkState.camera) {
              networkState.renderer.render(networkState.scene, networkState.camera);
            }
          }
          loop();
        },

        onResize() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera || !networkState.renderer) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        getZoomPercent() { return Math.round(this.zoomLevel * 100); }
      };
    }

    // Fallback: if Alpine does not hydrate (e.g., CDN blocked), manually mount the view
    document.addEventListener('DOMContentLoaded', () => {
      const el = document.querySelector('.network-view');
      if (!el) return;
      if (el.__networkMounted) return;

      try {
        const view = networkView();
        // Attach Alpine-like refs
        view.$refs = { networkContainer: el.querySelector('[data-network-container]') || el.querySelector('.network-container') };
        // Bind methods
        Object.keys(view).forEach(k => { if (typeof view[k] === 'function') view[k] = view[k].bind(view); });

        // Wire controls
        const bind = (selector, fn) => {
          const btn = el.querySelector(selector);
          if (btn) btn.addEventListener('click', (e) => { e.preventDefault(); fn(); });
        };
        bind('[data-action="signal-range"]', () => { view.showSignalRange = !view.showSignalRange; view.updateLabels?.(); });
        bind('[data-action="labels"]', () => { view.showLabels = !view.showLabels; view.updateLabels?.(); });
        bind('[data-action="autorotate"]', () => { view.toggleAutoRotate?.(); });
        bind('[data-action="wallnumbers"]', () => { view.toggleWallNumbers?.(); });
        bind('[data-action="reset"]', () => { view.resetView?.(); });
        bind('[data-action="zoomin"]', () => { view.zoomIn?.(); });
        bind('[data-action="zoomout"]', () => { view.zoomOut?.(); });

        view.init();
        el.__networkMounted = true;
      } catch (err) {
        console.error('[network-standalone] Failed to initialize', err);
      }
    });
  </script>
</body>
</html>
