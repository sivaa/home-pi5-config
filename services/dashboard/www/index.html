<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Home Climate</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Modularized CSS -->
  <link rel="stylesheet" href="styles/base.css">
  <link rel="stylesheet" href="styles/layout.css">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/views/comfort-score.css">
  <link rel="stylesheet" href="styles/views/bar-compare.css">
  <link rel="stylesheet" href="styles/views/floor-plan.css">
  <link rel="stylesheet" href="styles/views/ambient.css">
  <link rel="stylesheet" href="styles/views/timeline.css">
  <link rel="stylesheet" href="styles/views/classic.css">
  <link rel="stylesheet" href="styles/views/lights.css">
  <link rel="stylesheet" href="styles/views/3d-view.css">
  <link rel="stylesheet" href="styles/views/sensor-config.css">
  <link rel="stylesheet" href="styles/views/co2-view.css">
  <link rel="stylesheet" href="styles/views/isometric.css">
  <link rel="stylesheet" href="styles/views/network.css">

  <!-- Three.js for 3D Floor Plan -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // OrbitControls for Three.js r128 (inline to ensure compatibility)
    THREE.OrbitControls = function(object, domElement) {
      this.object = object;
      this.domElement = domElement;
      this.target = new THREE.Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.autoRotate = false;
      this.autoRotateSpeed = 2.0;

      var scope = this;
      var spherical = new THREE.Spherical();
      var sphericalDelta = new THREE.Spherical();
      var scale = 1;
      var panOffset = new THREE.Vector3();
      var rotateStart = new THREE.Vector2();
      var rotateEnd = new THREE.Vector2();
      var rotateDelta = new THREE.Vector2();
      var panStart = new THREE.Vector2();
      var panEnd = new THREE.Vector2();
      var panDelta = new THREE.Vector2();
      var dollyStart = new THREE.Vector2();
      var dollyEnd = new THREE.Vector2();
      var dollyDelta = new THREE.Vector2();

      var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
      var state = STATE.NONE;

      this.update = function() {
        var offset = new THREE.Vector3();
        var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
        var quatInverse = quat.clone().invert();
        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        return function update() {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state === STATE.NONE) sphericalDelta.theta -= 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping) scope.target.addScaledVector(panOffset, scope.dampingFactor);
          else scope.target.add(panOffset);
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping) {
            sphericalDelta.theta *= (1 - scope.dampingFactor);
            sphericalDelta.phi *= (1 - scope.dampingFactor);
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          return false;
        };
      }();

      function onPointerDown(event) {
        if (event.pointerType === 'touch') {
          // Skip for now - simplified
        } else {
          onMouseDown(event);
        }
      }

      function onPointerMove(event) {
        if (event.pointerType === 'touch') {
          // Skip for now - simplified
        } else {
          onMouseMove(event);
        }
      }

      function onPointerUp(event) {
        state = STATE.NONE;
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener('pointermove', onPointerMove);
        scope.domElement.removeEventListener('pointerup', onPointerUp);
      }

      function onMouseDown(event) {
        event.preventDefault();
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener('pointermove', onPointerMove);
        scope.domElement.addEventListener('pointerup', onPointerUp);
        if (event.button === 0) {
          state = STATE.ROTATE;
          rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === 2) {
          state = STATE.PAN;
          panStart.set(event.clientX, event.clientY);
        }
      }

      function onMouseMove(event) {
        if (state === STATE.ROTATE) {
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(0.005);
          sphericalDelta.theta -= rotateDelta.x;
          sphericalDelta.phi -= rotateDelta.y;
          rotateStart.copy(rotateEnd);
        } else if (state === STATE.PAN) {
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart).multiplyScalar(0.02);
          var v = new THREE.Vector3();
          v.setFromMatrixColumn(scope.object.matrix, 0);
          v.multiplyScalar(-panDelta.x);
          panOffset.add(v);
          v.setFromMatrixColumn(scope.object.matrix, 1);
          v.multiplyScalar(panDelta.y);
          panOffset.add(v);
          panStart.copy(panEnd);
        }
      }

      function onMouseWheel(event) {
        event.preventDefault();
        if (event.deltaY < 0) scale /= 0.95;
        else if (event.deltaY > 0) scale *= 0.95;
      }

      function onContextMenu(event) {
        event.preventDefault();
      }

      this.domElement.addEventListener('pointerdown', onPointerDown);
      this.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
      this.domElement.addEventListener('contextmenu', onContextMenu);

      this.dispose = function() {
        scope.domElement.removeEventListener('pointerdown', onPointerDown);
        scope.domElement.removeEventListener('wheel', onMouseWheel);
        scope.domElement.removeEventListener('contextmenu', onContextMenu);
      };

      this.update();
    };
  </script>
</head>
<body>
  <div class="app-container" x-data="app()" x-init="init()">

    <!-- Header -->
    <header class="app-header">
      <div class="header-content">
        <div class="header-left">
          <h1 class="header-title">Home Climate</h1>
          <div class="status-badge"
               :class="{ 'disconnected': !$store.mqtt.connected && !$store.mqtt.connecting, 'connecting': $store.mqtt.connecting }">
            <span class="loading-indicator loading-sm" x-show="$store.mqtt.connecting"></span>
            <span class="status-dot-header" x-show="!$store.mqtt.connecting" :class="{ 'connected': $store.mqtt.connected }"></span>
            <span x-text="$store.mqtt.connecting ? 'Connecting' : ($store.mqtt.connected ? 'Live' : 'Offline')"></span>
          </div>
        </div>
        <div class="header-right">
          <div class="date-time" x-text="currentDateTime"></div>
          <div class="last-update" x-text="'Last update: ' + lastUpdateText"></div>
        </div>
      </div>
    </header>

    <!-- Navigation Menu -->
    <nav class="nav-container">
      <div class="nav-tabs">
        <button class="nav-tab" :class="{ active: currentView === 'comfort' }"
                @click="setView('comfort')" title="Comfort Score (Press 1)">
          <span class="nav-icon">üéØ</span>
          <span class="nav-label">Score</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'compare' }"
                @click="setView('compare')" title="Room Comparison (Press 2)">
          <span class="nav-icon">üìä</span>
          <span class="nav-label">Compare</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'floor' }"
                @click="setView('floor')" title="Floor Plan (Press 3)">
          <span class="nav-icon">üè†</span>
          <span class="nav-label">Floor Plan</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'ambient' }"
                @click="setView('ambient')" title="Ambient Display (Press 4)">
          <span class="nav-icon">üå°Ô∏è</span>
          <span class="nav-label">Ambient</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'timeline' }"
                @click="setView('timeline')" title="Timeline Story (Press 5)">
          <span class="nav-icon">üìñ</span>
          <span class="nav-label">Timeline</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'classic' }"
                @click="setView('classic')" title="Classic Cards (Press 6)">
          <span class="nav-icon">üÉè</span>
          <span class="nav-label">Classic</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'lights' }"
                @click="setView('lights')" title="Light Control (Press 7)">
          <span class="nav-icon">üí°</span>
          <span class="nav-label">Lights</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === '3d' }"
                @click="setView('3d')" title="3D Floor Plan (Press 8)">
          <span class="nav-icon">üè†</span>
          <span class="nav-label">3D</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'isometric' }"
                @click="setView('isometric')" title="Isometric View (Press I)">
          <span class="nav-icon">üî∑</span>
          <span class="nav-label">Iso</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'config' }"
                @click="setView('config')" title="Sensor Config (Press 9)">
          <span class="nav-icon">‚öôÔ∏è</span>
          <span class="nav-label">Config</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'co2' }"
                @click="setView('co2')" title="CO2 Monitor (Press 0)">
          <span class="nav-icon">üí®</span>
          <span class="nav-label">CO2</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'network' }"
                @click="setView('network')" title="Zigbee Network (Press N)">
          <span class="nav-icon">üì°</span>
          <span class="nav-label">Network</span>
        </button>
      </div>
    </nav>

    <!-- Main Content -->
    <main class="app-main">
      <div class="view-container">

        <!-- Vision 1: Comfort Score -->
        <div x-show="currentView === 'comfort'" x-cloak x-data="comfortScoreView()">
          <div class="comfort-score-view">
            <div class="score-hero" @click="showBreakdown = !showBreakdown">
              <div class="score-label-top">YOUR HOME IS</div>
              <div class="score-circle" :style="{ '--score-color': getColor() }">
                <svg viewBox="0 0 200 200" class="score-ring">
                  <circle cx="100" cy="100" r="90" fill="none" stroke="var(--color-border)" stroke-width="8"/>
                  <circle cx="100" cy="100" r="90" fill="none" :stroke="getColor()" stroke-width="8"
                          stroke-linecap="round" :stroke-dasharray="getScoreArc()"
                          transform="rotate(-90 100 100)" class="score-arc"/>
                </svg>
                <div class="score-content">
                  <span class="score-number" :style="{ color: getColor() }" x-text="homeScore"></span>
                  <span class="score-label" x-text="getLabel()"></span>
                </div>
              </div>
              <div class="score-hint">Tap for breakdown</div>
            </div>

            <div class="score-breakdown" x-show="showBreakdown" x-transition>
              <div class="breakdown-title">Score Components</div>
              <div class="breakdown-item">
                <span class="breakdown-label">Temperature (70%)</span>
                <div class="breakdown-bar">
                  <div class="breakdown-fill" :style="{ width: (homeScore * 0.7) + '%', background: 'var(--color-primary)' }"></div>
                </div>
              </div>
              <div class="breakdown-item">
                <span class="breakdown-label">Humidity (30%)</span>
                <div class="breakdown-bar">
                  <div class="breakdown-fill" :style="{ width: (homeScore * 0.3) + '%', background: 'var(--color-success)' }"></div>
                </div>
              </div>
            </div>

            <div class="room-scores">
              <template x-for="room in roomScores" :key="room.id">
                <button class="room-pill" @click="openRoom(room)" :style="{ '--pill-color': getRoomColor(room.score) }">
                  <span class="pill-icon" x-text="room.icon"></span>
                  <span class="pill-score" :style="{ color: getRoomColor(room.score) }" x-text="room.score"></span>
                  <span class="pill-dot" :style="{ background: getRoomColor(room.score) }"></span>
                </button>
              </template>
            </div>

            <div class="room-labels">
              <template x-for="room in roomScores" :key="room.id + '-label'">
                <span class="room-label-text" x-text="room.name.split(' ')[0]"></span>
              </template>
            </div>

            <div class="comfort-spectrum">
              <div class="spectrum-bar">
                <div class="spectrum-gradient"></div>
                <div class="spectrum-marker" :style="{ left: homeScore + '%' }">
                  <div class="marker-line"></div>
                  <div class="marker-label">You</div>
                </div>
              </div>
              <div class="spectrum-labels">
                <span>Poor</span>
                <span>Okay</span>
                <span>Perfect</span>
              </div>
            </div>

            <div class="suggestions" x-show="suggestions.length > 0">
              <template x-for="(suggestion, index) in suggestions" :key="index">
                <div class="suggestion-card" :class="'suggestion-' + suggestion.type">
                  <span class="suggestion-icon" x-text="suggestion.icon"></span>
                  <div class="suggestion-content">
                    <div class="suggestion-title" x-text="suggestion.title"></div>
                    <div class="suggestion-message" x-text="suggestion.message"></div>
                  </div>
                  <button class="suggestion-dismiss" @click="suggestions.splice(index, 1)">&times;</button>
                </div>
              </template>
            </div>
          </div>
        </div>

        <!-- Vision 2: Bar Compare -->
        <div x-show="currentView === 'compare'" x-cloak x-data="barCompareView()">
          <div class="bar-compare-view">
            <div class="bar-controls">
              <div class="view-toggle">
                <button class="btn btn-secondary" :class="{ active: viewMode === 'temperature' }"
                        @click="setViewMode('temperature')">üå°Ô∏è Temp</button>
                <button class="btn btn-secondary" :class="{ active: viewMode === 'humidity' }"
                        @click="setViewMode('humidity')">üíß Humid</button>
                <button class="btn btn-secondary" :class="{ active: viewMode === 'both' }"
                        @click="setViewMode('both')">Both</button>
              </div>
              <div class="sort-controls">
                <select class="sort-select" x-model="sortBy">
                  <option value="temperature">Sort: Temperature</option>
                  <option value="humidity">Sort: Humidity</option>
                  <option value="name">Sort: Name</option>
                  <option value="score">Sort: Comfort</option>
                </select>
                <button class="sort-direction" @click="sortDirection = sortDirection === 'desc' ? 'asc' : 'desc'">
                  <span x-text="sortDirection === 'desc' ? '‚Üì' : '‚Üë'"></span>
                </button>
              </div>
            </div>

            <div class="charts-container" :class="{ 'single-chart': viewMode !== 'both' }">
              <div class="bar-chart" x-show="viewMode === 'temperature' || viewMode === 'both'">
                <h3 class="chart-title">üå°Ô∏è Temperature</h3>
                <div class="chart-wrapper">
                  <div class="comfort-zone" :style="getComfortZoneStyle('temperature')"></div>
                  <template x-for="room in sortedRooms" :key="room.id + '-temp'">
                    <div class="bar-row" @click="openRoom(room)">
                      <div class="bar-label">
                        <span class="bar-icon" x-text="room.icon"></span>
                        <span class="bar-name" x-text="room.name"></span>
                      </div>
                      <div class="bar-track">
                        <div class="bar-fill" :style="{ width: getBarWidth(room.temperature, 'temperature') + '%', background: getBarColor(room.temperature, 'temperature') }"></div>
                      </div>
                      <div class="bar-value" x-text="room.temperature.toFixed(1) + '¬∞'"></div>
                    </div>
                  </template>
                  <div class="scale-labels">
                    <template x-for="label in getScaleLabels('temperature')" :key="label">
                      <span x-text="label"></span>
                    </template>
                  </div>
                </div>
              </div>

              <div class="bar-chart" x-show="viewMode === 'humidity' || viewMode === 'both'">
                <h3 class="chart-title">üíß Humidity</h3>
                <div class="chart-wrapper">
                  <div class="comfort-zone" :style="getComfortZoneStyle('humidity')"></div>
                  <template x-for="room in sortedRooms" :key="room.id + '-humid'">
                    <div class="bar-row" @click="openRoom(room)">
                      <div class="bar-label">
                        <span class="bar-icon" x-text="room.icon"></span>
                        <span class="bar-name" x-text="room.name"></span>
                      </div>
                      <div class="bar-track">
                        <div class="bar-fill" :style="{ width: getBarWidth(room.humidity, 'humidity') + '%', background: getBarColor(room.humidity, 'humidity') }"></div>
                      </div>
                      <div class="bar-value" x-text="room.humidity.toFixed(0) + '%'"></div>
                    </div>
                  </template>
                  <div class="scale-labels">
                    <template x-for="label in getScaleLabels('humidity')" :key="label">
                      <span x-text="label"></span>
                    </template>
                  </div>
                </div>
              </div>
            </div>

            <div class="insights-section" x-show="insights.length > 0">
              <h3 class="insights-title">üìä Auto-Insights</h3>
              <div class="insights-list">
                <template x-for="insight in insights" :key="insight.message">
                  <div class="insight-card" :class="getInsightClass(insight.type)">
                    <span class="insight-icon" x-text="insight.icon"></span>
                    <div class="insight-content">
                      <div class="insight-title" x-text="insight.title"></div>
                      <div class="insight-message" x-text="insight.message"></div>
                    </div>
                  </div>
                </template>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 3: Floor Plan -->
        <div x-show="currentView === 'floor'" x-cloak x-data="floorPlanView()">
          <div class="floor-plan-view">
            <div class="floor-controls">
              <div class="view-toggle">
                <button class="btn btn-secondary" :class="{ active: viewType === 'temperature' }"
                        @click="setViewType('temperature')">üå°Ô∏è Temperature</button>
                <button class="btn btn-secondary" :class="{ active: viewType === 'humidity' }"
                        @click="setViewType('humidity')">üíß Humidity</button>
              </div>
            </div>

            <div class="floor-plan-container">
              <svg class="floor-plan-svg" :viewBox="'0 0 ' + layout.width + ' ' + layout.height">
                <!-- Compass -->
                <g class="compass" transform="translate(590, 30)">
                  <text font-size="12" fill="var(--color-text-tertiary)" text-anchor="middle">N</text>
                  <line x1="0" y1="8" x2="0" y2="20" stroke="var(--color-text-tertiary)" stroke-width="2"/>
                  <polygon points="-3,8 3,8 0,4" fill="var(--color-text-tertiary)"/>
                </g>

                <!-- Balcony (left of Living Room, west side) -->
                <g class="balcony">
                  <rect x="10" y="50" width="55" height="120" fill="none" stroke="var(--color-success)"
                        stroke-width="2" stroke-dasharray="5,3" rx="4"/>
                  <text x="37" y="115" font-size="10" fill="var(--color-success)" text-anchor="middle">Balcony</text>
                </g>

                <!-- Hallway (center corridor connecting all rooms) -->
                <rect x="295" y="235" width="130" height="100" fill="var(--color-bg)"
                      stroke="var(--color-border)" stroke-width="1" rx="4" opacity="0.5"/>
                <text x="360" y="290" font-size="11" fill="var(--color-text-tertiary)" text-anchor="middle">Hallway</text>

                <!-- Rooms -->
                <template x-for="room in rooms" :key="room.id">
                  <g class="floor-room" @click="openRoom(room)" style="cursor: pointer;">
                    <rect :x="room.x" :y="room.y" :width="room.width" :height="room.height"
                          :fill="room.color" stroke="var(--color-border)" stroke-width="2" rx="8" class="room-rect"/>
                    <text :x="room.x + room.width/2" :y="room.y + room.height/2 - 15"
                          text-anchor="middle" font-size="14" font-weight="500" fill="var(--color-text)"
                          x-text="room.name"></text>
                    <text :x="room.x + room.width/2" :y="room.y + room.height/2 + 10"
                          text-anchor="middle" font-size="24" font-weight="600" fill="var(--color-text)"
                          x-text="getValue(room)"></text>
                    <text :x="room.x + room.width/2" :y="room.y + room.height/2 + 30"
                          text-anchor="middle" font-size="12" fill="var(--color-text-secondary)"
                          x-text="viewType === 'temperature' ? (room.humidity?.toFixed(0) + '%' || '') : (room.temperature?.toFixed(1) + '¬∞' || '')"></text>
                    <text :x="room.x + room.width - 20" :y="room.y + room.height - 15" font-size="16" x-text="room.icon"></text>
                  </g>
                </template>

                <!-- Main Entry Door (east side at Bedroom) -->
                <g transform="translate(595, 80)">
                  <rect x="-10" y="-30" width="14" height="60" fill="var(--color-surface)"
                        stroke="var(--color-primary)" stroke-width="2" rx="3"/>
                  <text x="-3" y="45" font-size="8" fill="var(--color-primary)" text-anchor="middle" font-weight="500">üö™</text>
                </g>

                <!-- Windows indicators -->
                <g class="windows" opacity="0.6">
                  <!-- Living room window (west/left wall, near balcony door) -->
                  <rect x="66" y="130" width="4" height="50" fill="var(--color-info)" rx="2"/>
                  <!-- Bedroom window (east/right wall) -->
                  <rect x="590" y="160" width="4" height="50" fill="var(--color-info)" rx="2"/>
                  <!-- Study window (west/left wall) -->
                  <rect x="16" y="320" width="4" height="50" fill="var(--color-info)" rx="2"/>
                  <!-- Kitchen window (east/right wall) -->
                  <rect x="605" y="270" width="4" height="40" fill="var(--color-info)" rx="2"/>
                  <!-- Bathroom window (east/right wall) -->
                  <rect x="605" y="380" width="4" height="35" fill="var(--color-info)" rx="2"/>
                </g>
              </svg>
            </div>

            <div class="floor-legend">
              <div class="legend-title" x-text="viewType === 'temperature' ? 'Temperature' : 'Humidity'"></div>
              <div class="legend-items">
                <template x-for="item in getLegendItems()" :key="item.label">
                  <div class="legend-item">
                    <div class="legend-color" :style="{ background: item.color }"></div>
                    <span class="legend-label" x-text="item.label"></span>
                  </div>
                </template>
              </div>
            </div>

            <div class="floor-tip">Tap any room for detailed history</div>
          </div>
        </div>

        <!-- Vision 4: Ambient -->
        <div x-show="currentView === 'ambient'" x-cloak x-data="ambientView()">
          <div class="ambient-view" :style="{ background: getBackgroundColor() }" :class="{ 'dark-mode': isDarkMode }"
               @click="showDetailsOverlay()">
            <div class="ambient-main">
              <div class="ambient-temperature">
                <span x-text="currentRoom.temperature?.toFixed(1) || '--'"></span>
                <span class="ambient-unit">¬∞</span>
              </div>
              <div class="ambient-room-name" x-text="currentRoom.name"></div>
              <div class="ambient-humidity">
                <span>üíß</span>
                <span x-text="(currentRoom.humidity?.toFixed(0) || '--') + '%'"></span>
              </div>
            </div>

            <div class="ambient-details" x-show="showDetails" x-transition.opacity>
              <div class="detail-item">
                <span class="detail-label">Today</span>
                <span class="detail-value" x-text="getMinMaxToday()"></span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Trend</span>
                <span class="detail-value trend" x-text="getTrend()"></span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Updated</span>
                <span class="detail-value" x-text="formatLastUpdate()"></span>
              </div>
            </div>

            <div class="ambient-room-dots">
              <template x-for="(room, index) in rooms" :key="room.id">
                <button class="room-dot-btn" :class="{ active: currentRoomIndex === index }"
                        @click.stop="selectRoom(index)">
                  <div class="dot-circle"></div>
                  <div class="dot-label">
                    <span class="dot-temp" x-text="room.temperature?.toFixed(0) + '¬∞'"></span>
                    <span class="dot-name" x-text="room.name.split(' ')[0]"></span>
                  </div>
                </button>
              </template>
            </div>

            <div class="ambient-hint">
              <span>‚Üê swipe to change room ‚Üí</span>
              <span class="hint-secondary" x-show="isDarkMode">Double-tap for light mode</span>
            </div>

            <div class="auto-rotate-indicator" x-show="autoRotate">üîÑ Auto-rotating</div>
          </div>
        </div>

        <!-- Vision 5: Timeline -->
        <div x-show="currentView === 'timeline'" x-cloak x-data="timelineView()">
          <div class="timeline-view">
            <div class="timeline-header">
              <h2 class="timeline-title">üìñ Today's Climate Story</h2>
              <div class="date-selector">
                <button class="btn btn-secondary" :class="{ active: selectedDate === 'today' }"
                        @click="setDate('today')">Today</button>
                <button class="btn btn-secondary" :class="{ active: selectedDate === 'yesterday' }"
                        @click="setDate('yesterday')">Yesterday</button>
                <button class="btn btn-secondary" :class="{ active: selectedDate === 'week' }"
                        @click="setDate('week')">This Week</button>
              </div>
            </div>

            <template x-if="getTodaySummary()">
              <div class="summary-card">
                <div class="summary-title">üìä Summary</div>
                <div class="summary-grid">
                  <div class="summary-item">
                    <span class="summary-label">Temperature Range</span>
                    <span class="summary-value" x-text="getTodaySummary().minTemp + '¬∞ ‚Äî ' + getTodaySummary().maxTemp + '¬∞'"></span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Most Stable</span>
                    <span class="summary-value" x-text="getTodaySummary().mostStable || '--'"></span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Most Variable</span>
                    <span class="summary-value" x-text="getTodaySummary().mostVolatile || '--'"></span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Events Detected</span>
                    <span class="summary-value" x-text="getTodaySummary().eventCount"></span>
                  </div>
                </div>
              </div>
            </template>

            <div class="timeline-content">
              <div class="timeline-now" x-show="selectedDate === 'today'">
                <div class="now-marker">NOW</div>
                <div class="now-line"></div>
              </div>

              <template x-if="events.length === 0 && !loading">
                <div class="no-events">
                  <span class="no-events-icon">üì≠</span>
                  <span class="no-events-text">No significant events detected</span>
                  <span class="no-events-hint">Events appear when temperature changes rapidly or reaches peaks</span>
                </div>
              </template>

              <template x-if="loading">
                <div class="loading-events">
                  <span class="loading-indicator"></span>
                  <span>Analyzing climate data...</span>
                </div>
              </template>

              <div class="timeline-events">
                <template x-for="event in events" :key="event.time + event.room">
                  <div class="timeline-event" :class="getEventClass(event.type)" @click="openRoom(event.room)">
                    <div class="event-time-marker">
                      <span class="event-time" x-text="formatTime(event.time)"></span>
                      <div class="event-dot"></div>
                    </div>
                    <div class="event-card">
                      <div class="event-header">
                        <span class="event-icon" x-text="event.eventIcon"></span>
                        <span class="event-room-icon" x-text="event.icon"></span>
                        <span class="event-title" x-text="event.title"></span>
                      </div>
                      <template x-if="event.cause">
                        <div class="event-cause">
                          <span class="cause-icon">üí°</span>
                          <span class="cause-text" x-text="'Likely: ' + event.cause.text"></span>
                        </div>
                      </template>
                      <template x-if="event.type === 'RAPID_RISE' || event.type === 'RAPID_DROP'">
                        <div class="event-details">
                          <span x-text="event.value.toFixed(1) + '¬∞ ‚Üí ' + event.endValue.toFixed(1) + '¬∞'"></span>
                          <span class="event-duration" x-text="'(' + event.duration + ' min)'"></span>
                        </div>
                      </template>
                    </div>
                  </div>
                </template>
              </div>

              <div class="timeline-midnight" x-show="selectedDate === 'today'">
                <div class="midnight-line"></div>
                <div class="midnight-label">MIDNIGHT</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 6: Classic Cards View -->
        <div x-show="currentView === 'classic'" x-cloak x-data="classicView()">
          <div class="classic-view">
            <!-- Room Grid -->
            <div class="classic-grid">
              <template x-for="room in rooms" :key="room.id">
                <div class="classic-card" :class="{ 'stale': isStale(room) }" @click="openRoom(room)">
                  <div class="classic-comfort" :class="getComfortClass(room.temperature)"></div>

                  <div class="classic-header">
                    <div class="classic-room-info">
                      <div class="classic-icon" x-text="room.icon"></div>
                      <div class="classic-name" x-text="room.name"></div>
                    </div>
                    <div class="classic-updated" x-text="formatUpdate(room.lastSeen)"></div>
                  </div>

                  <div class="classic-values">
                    <div class="classic-temp">
                      <template x-if="room.temperature !== null">
                        <span><span x-text="room.temperature.toFixed(1)"></span><span class="unit">¬∞</span></span>
                      </template>
                      <template x-if="room.temperature === null">
                        <span class="no-data">--</span>
                      </template>
                    </div>
                    <div class="classic-humidity">
                      <span class="humidity-icon">üíß</span>
                      <template x-if="room.humidity !== null">
                        <span x-text="room.humidity.toFixed(0) + '%'"></span>
                      </template>
                      <template x-if="room.humidity === null">
                        <span>--%</span>
                      </template>
                    </div>
                  </div>

                  <div class="classic-sparkline">
                    <svg :id="'classic-spark-' + room.id" class="sparkline-svg" preserveAspectRatio="none"></svg>
                  </div>
                </div>
              </template>
            </div>

            <!-- Average Card -->
            <div class="classic-average">
              <div class="avg-section">
                <div class="avg-label">Home Average Temperature</div>
                <div class="avg-value">
                  <template x-if="avgTemperature !== null">
                    <span><span x-text="avgTemperature.toFixed(1)"></span><span class="avg-unit">¬∞C</span></span>
                  </template>
                  <template x-if="avgTemperature === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider"></div>
              <div class="avg-section">
                <div class="avg-label">Home Average Humidity</div>
                <div class="avg-value">
                  <template x-if="avgHumidity !== null">
                    <span><span x-text="avgHumidity.toFixed(0)"></span><span class="avg-unit">%</span></span>
                  </template>
                  <template x-if="avgHumidity === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider hidden-mobile"></div>
              <div class="avg-chart">
                <svg id="classic-spark-avg" class="sparkline-svg" preserveAspectRatio="none"></svg>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 7: Lights Control -->
        <div x-show="currentView === 'lights'" x-cloak x-data="lightsView()">
          <div class="lights-view">
            <div class="lights-header">
              <h2>üí° Light Control</h2>
              <p class="lights-subtitle">
                Control your IKEA FLOALT panel lights
                <span class="loading-indicator" x-show="$store.lights.initializing && $store.mqtt.connected"></span>
              </p>
            </div>

            <!-- Initializing overlay -->
            <div class="lights-initializing" x-show="$store.lights.initializing && $store.mqtt.connected" x-transition>
              <span class="loading-indicator loading-lg"></span>
              <span>Loading light states...</span>
            </div>

            <!-- Not connected warning -->
            <div class="lights-warning" x-show="!$store.mqtt.connected">
              <span class="loading-indicator"></span>
              <span>Connecting to MQTT...</span>
            </div>

            <!-- Master Control Toggle -->
            <div class="master-control"
                 :class="{
                   'master-on': $store.lights.list.every(l => l.state === 'ON'),
                   'master-syncing': $store.lights.syncing,
                   'master-disabled': !$store.mqtt.connected || $store.lights.initializing
                 }">
              <div class="master-info">
                <span class="master-icon">üí°</span>
                <div class="master-text">
                  <span class="master-label">Master Control</span>
                  <span class="master-status" x-text="$store.lights.lightsOnCount + ' of ' + $store.lights.list.length + ' lights on'"></span>
                </div>
              </div>
              <button class="light-toggle master-toggle"
                      :class="{ 'toggle-on': $store.lights.list.every(l => l.state === 'ON'), 'toggle-syncing': $store.lights.syncing }"
                      @click="$store.lights.toggleAllLights()"
                      :disabled="$store.lights.syncing || !$store.mqtt.connected || $store.lights.initializing">
                <div class="toggle-track">
                  <div class="toggle-thumb"></div>
                </div>
              </button>
            </div>

            <!-- Light Cards -->
            <div class="lights-grid" :class="{ 'lights-disabled': !$store.mqtt.connected || $store.lights.initializing }">
              <template x-for="light in $store.lights.list" :key="light.id">
                <div class="light-card" :class="{ 'light-on': light.state === 'ON' && light.available, 'light-off': light.state === 'OFF' && light.available, 'light-syncing': light.syncing, 'light-unavailable': !light.available }">
                  <!-- Unavailable overlay -->
                  <div class="light-unavailable-overlay" x-show="!light.available" x-transition.opacity>
                    <span class="unavailable-icon">‚ö°</span>
                    <span class="unavailable-text">Offline</span>
                  </div>
                  <!-- Syncing overlay -->
                  <div class="light-syncing-overlay" x-show="light.syncing && light.available" x-transition.opacity>
                    <span class="loading-indicator"></span>
                  </div>

                  <div class="light-header">
                    <div class="light-info">
                      <span class="light-icon" x-text="light.icon"></span>
                      <div class="light-details">
                        <span class="light-name" x-text="light.name"></span>
                        <span class="light-status">
                          <span x-show="!light.available" class="unavailable-status">Offline</span>
                          <span x-show="light.available && light.syncing" class="syncing-text">Syncing...</span>
                          <span x-show="light.available && !light.syncing" x-text="light.state === 'ON' ? 'On' : 'Off'"></span>
                        </span>
                      </div>
                    </div>
                    <button class="light-toggle" :class="{ 'toggle-on': light.state === 'ON' && light.available, 'toggle-syncing': light.syncing, 'toggle-unavailable': !light.available }"
                            @click="$store.lights.toggleLight(light)" :disabled="light.syncing || !light.available">
                      <div class="toggle-track">
                        <div class="toggle-thumb">
                          <span class="loading-indicator loading-sm" x-show="light.syncing"></span>
                        </div>
                      </div>
                    </button>
                  </div>

                  <!-- Brightness Slider -->
                  <div class="light-control" x-show="light.state === 'ON' && light.available" x-transition
                       :class="{ 'control-disabled': !$store.mqtt.connected || $store.lights.initializing || light.syncing }">
                    <div class="control-row">
                      <label class="control-label">
                        <span class="control-icon">üîÜ</span>
                        Brightness
                      </label>
                      <span class="control-value">
                        <span x-show="light.syncing" class="control-syncing">‚ü≥</span>
                      </span>
                    </div>
                    <div class="slider-wrapper">
                      <input type="range" class="slider brightness-slider" min="1" max="254"
                             x-model="light.brightness"
                             :disabled="!$store.mqtt.connected || $store.lights.initializing"
                             @change="$store.lights.setBrightness(light, $event.target.value)"
                             :style="'background: linear-gradient(90deg, rgba(255,220,180,0.8) 0%, rgba(255,240,210,0.6) ' + (light.brightness / 254 * 100) + '%, rgba(245,245,247,1) ' + (light.brightness / 254 * 100) + '%, rgba(245,245,247,1) 100%)'">
                      <span class="slider-percent" x-text="Math.round(light.brightness / 254 * 100) + '%'"></span>
                    </div>
                  </div>

                  <!-- Color Temperature Slider -->
                  <div class="light-control" x-show="light.state === 'ON' && light.available" x-transition
                       :class="{ 'control-disabled': !$store.mqtt.connected || $store.lights.initializing || light.syncing }">
                    <div class="control-row">
                      <label class="control-label">
                        <span class="control-icon">üå°Ô∏è</span>
                        Color Temp
                      </label>
                      <span class="control-value">
                        <span x-show="light.syncing" class="control-syncing">‚ü≥</span>
                        <span x-text="getColorTempLabel(light.colorTemp)"></span>
                      </span>
                    </div>
                    <input type="range" class="slider colortemp-slider" min="250" max="454"
                           x-model="light.colorTemp"
                           :disabled="!$store.mqtt.connected || $store.lights.initializing"
                           @change="$store.lights.setColorTemp(light, $event.target.value)">
                    <div class="colortemp-labels">
                      <span>Cool</span>
                      <span>Warm</span>
                    </div>
                  </div>

                  <!-- Quick Presets -->
                  <div class="light-presets" x-show="light.state === 'ON' && light.available" x-transition>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'reading')" title="Reading">üìñ</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'relax')" title="Relax">üåÖ</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'bright')" title="Bright">‚òÄÔ∏è</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'night')" title="Night">üåô</button>
                  </div>

                  <!-- Link Quality -->
                  <div class="light-meta">
                    <span class="light-availability" :class="{ 'available': light.available, 'unavailable': !light.available }">
                      <span x-text="light.available ? 'üü¢' : 'üî¥'"></span>
                      <span x-text="light.available ? 'Online' : 'Offline'"></span>
                    </span>
                    <span class="light-linkquality" x-show="light.available" :title="'Link Quality: ' + light.linkquality">
                      üì∂ <span x-text="light.linkquality || '--'"></span>
                    </span>
                    <span class="light-update" x-text="formatLastUpdate(light.lastSeen)"></span>
                  </div>
                </div>
              </template>
            </div>

            <!-- Scene Buttons -->
            <div class="lights-scenes" :class="{ 'lights-disabled': !$store.mqtt.connected || $store.lights.initializing }">
              <h3 class="scenes-title">Quick Scenes</h3>
              <div class="scenes-grid">
                <button class="scene-btn" @click="$store.lights.applyScene('movie')">
                  <span class="scene-icon">üé¨</span>
                  <span class="scene-name">Movie</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('work')">
                  <span class="scene-icon">üíº</span>
                  <span class="scene-name">Work</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('evening')">
                  <span class="scene-icon">üåÜ</span>
                  <span class="scene-name">Evening</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('goodnight')">
                  <span class="scene-icon">üò¥</span>
                  <span class="scene-name">Goodnight</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 8: 3D Floor Plan -->
        <div x-show="currentView === '3d'" x-cloak x-data="threeDView()" x-init="init()">
          <div class="three-d-view">
            <!-- Controls -->
            <div class="three-controls">
              <div class="view-toggle">
                <button class="btn btn-secondary" :class="{ active: viewMode === 'temperature' }"
                        @click="setViewMode('temperature')">üå°Ô∏è Temperature</button>
                <button class="btn btn-secondary" :class="{ active: viewMode === 'humidity' }"
                        @click="setViewMode('humidity')">üíß Humidity</button>
              </div>
            </div>

            <!-- Three.js Container -->
            <div class="three-container" x-ref="threeContainer"></div>

            <!-- View Control Buttons -->
            <div class="three-controls-bar">
              <button class="three-control-btn" :class="{ active: viewMode3D === '3d' }"
                      @click="set3DView()">
                üéÆ 3D View
              </button>
              <button class="three-control-btn" :class="{ active: viewMode3D === 'top' }"
                      @click="setTopView()">
                üìê Top View
              </button>
              <button class="three-control-btn" :class="{ active: !wallsVisible }"
                      @click="toggleWalls()">
                üß± <span x-text="wallsVisible ? 'Hide Walls' : 'Show Walls'"></span>
              </button>
              <button class="three-control-btn" :class="{ active: autoRotate }"
                      @click="toggleAutoRotate()">
                üîÑ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
              </button>
              <button class="three-control-btn" :class="{ active: darkTheme }"
                      @click="toggleDarkTheme()">
                üåô Dark
              </button>
              <div class="zoom-controls">
                <button class="three-control-btn zoom-btn" @click="zoomIn()">‚ûï</button>
                <button class="three-control-btn zoom-btn" @click="zoomOut()">‚ûñ</button>
              </div>
            </div>

            <!-- Legend -->
            <div class="three-legend">
              <div class="legend-title" x-text="viewMode === 'temperature' ? 'Temperature' : 'Humidity'"></div>
              <div class="legend-items">
                <template x-for="item in getLegendItems()" :key="item.label">
                  <div class="legend-item">
                    <div class="legend-color" :style="{ background: item.color }"></div>
                    <span class="legend-label" x-text="item.label"></span>
                  </div>
                </template>
              </div>
            </div>

            <!-- Tip -->
            <div class="three-tip">
              üè† Interactive 3D view of your home ‚Ä¢ Drag to rotate, scroll to zoom
            </div>
          </div>
        </div>

        <!-- Isometric Floor Plan View -->
        <div x-show="currentView === 'isometric'" x-cloak x-data="isometricView()" x-init="init()">
          <div class="isometric-view">
            <!-- Controls -->
            <div class="iso-controls">
              <div class="iso-view-toggle">
                <button class="iso-control-btn" :class="{ active: viewMode === 'temperature' }"
                        @click="setViewMode('temperature')">üå°Ô∏è Temp</button>
                <button class="iso-control-btn" :class="{ active: viewMode === 'humidity' }"
                        @click="setViewMode('humidity')">üíß Humid</button>
              </div>
              <button class="iso-control-btn" :class="{ active: !wallsVisible }"
                      @click="toggleWalls()">
                üß± <span x-text="wallsVisible ? 'Hide Walls' : 'Show Walls'"></span>
              </button>
              <button class="iso-control-btn" :class="{ active: darkTheme }"
                      @click="toggleDarkTheme()">
                üåô Dark
              </button>
              <button class="iso-control-btn" :class="{ active: autoRotate }"
                      @click="toggleAutoRotate()">
                üîÑ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
              </button>
              <button class="iso-control-btn" @click="resetView()">
                üéØ Reset
              </button>
              <div class="iso-zoom-controls">
                <button class="iso-control-btn iso-zoom-btn" @click="zoomOut()">‚ûñ</button>
                <span class="iso-zoom-indicator" x-text="getZoomPercent() + '%'"></span>
                <button class="iso-control-btn iso-zoom-btn" @click="zoomIn()">‚ûï</button>
              </div>
            </div>

            <!-- Isometric Canvas Container -->
            <div class="iso-container" x-ref="isoContainer"></div>

            <!-- Legend -->
            <div class="iso-legend">
              <span class="iso-legend-label" x-text="viewMode === 'temperature' ? 'Cold' : 'Dry'"></span>
              <div class="iso-legend-gradient" :class="{ humidity: viewMode === 'humidity' }"></div>
              <span class="iso-legend-label" x-text="viewMode === 'temperature' ? 'Hot' : 'Humid'"></span>
            </div>

            <!-- Tip -->
            <div class="iso-tip">
              üî∑ Isometric view ‚Ä¢ Drag to pan, scroll to zoom ‚Ä¢ Press I for quick access
            </div>
          </div>
        </div>

        <!-- Vision 9: Sensor Configuration -->
        <div x-show="currentView === 'config'" x-cloak x-data="sensorConfigView()" x-init="init()">
          <div class="sensor-config-container">
            <!-- Sensor Palette (Left Panel) -->
            <div class="sensor-palette">
              <div class="palette-header">
                <span class="palette-title">‚öôÔ∏è Sensors</span>
                <span class="palette-count" x-text="placedCount + '/' + totalCount + ' placed'"></span>
              </div>

              <!-- Search Box -->
              <div class="palette-search">
                <input type="text" placeholder="üîç Search sensors..." x-model="searchQuery">
              </div>

              <!-- Loading State -->
              <div class="palette-loading" x-show="loading">
                <div class="loading-spinner"></div>
                <span>Discovering sensors...</span>
              </div>

              <!-- Empty State -->
              <div class="palette-empty" x-show="!loading && totalCount === 0">
                <span class="empty-icon">üì°</span>
                <span>No sensors found</span>
                <span>Check MQTT connection</span>
              </div>

              <!-- Sensor Groups by Type -->
              <template x-for="(typeSensors, sensorType) in sensorsByType" :key="sensorType">
                <div class="sensor-type-group" x-show="typeSensors.length > 0">
                  <div class="type-header" @click="expandedTypes[sensorType] = !expandedTypes[sensorType]">
                    <span class="type-icon" x-text="getTypeIcon(sensorType)"></span>
                    <span class="type-label" x-text="getTypeLabel(sensorType)"></span>
                    <span class="type-count" x-text="typeSensors.length"></span>
                  </div>
                  <div class="sensor-list" x-show="expandedTypes[sensorType]">
                    <template x-for="sensor in typeSensors" :key="sensor.ieee_address">
                      <div class="sensor-card"
                           :class="{
                             placed: isPlaced(sensor.ieee_address),
                             selected: selectedSensor?.ieee_address === sensor.ieee_address,
                             stale: isStale(sensor.ieee_address)
                           }"
                           draggable="true"
                           @dragstart="startDrag($event, sensor)"
                           @click="selectSensor(sensor)">
                        <div class="sensor-icon"
                             :style="'background-color: ' + getTypeColor(sensor.sensorType)">
                          <span x-text="getTypeIcon(sensor.sensorType)"></span>
                        </div>
                        <div class="sensor-info">
                          <div class="sensor-name" x-text="sensor.friendly_name"></div>
                          <div class="sensor-value" x-text="formatLiveValue(sensor)"></div>
                          <div class="sensor-status">
                            <span class="placed-badge" x-show="isPlaced(sensor.ieee_address)">‚úì Placed</span>
                            <span class="unplaced-badge" x-show="!isPlaced(sensor.ieee_address)">‚óã Unplaced</span>
                            <span class="stale-badge" x-show="isStale(sensor.ieee_address)">‚ö† Stale</span>
                          </div>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </template>

              <!-- Coverage Toggle -->
              <label class="coverage-toggle" x-show="hasCoverageToggle">
                <input type="checkbox" x-model="showCoverage">
                <span>Show motion coverage zones</span>
              </label>
            </div>

            <!-- 3D Canvas -->
            <div class="config-canvas"
                 x-ref="configCanvas"
                 @dragover.prevent="onDragOver($event)"
                 @drop.prevent="onDrop($event)">

              <!-- Control Buttons -->
              <div class="config-controls">
                <button class="control-btn" @click="resetView()" title="Reset View">üîÑ</button>
                <button class="control-btn" @click="toggleTopView()" :class="{ active: isTopView }" title="Top View">üìê</button>
                <button class="control-btn" @click="zoomIn()" title="Zoom In">‚ûï</button>
                <button class="control-btn" @click="zoomOut()" title="Zoom Out">‚ûñ</button>
              </div>

              <!-- Tooltip -->
              <div class="config-tooltip"
                   x-show="tooltip.visible"
                   :style="'left: ' + tooltip.x + 'px; top: ' + tooltip.y + 'px'"
                   x-text="tooltip.text">
              </div>
            </div>

            <!-- Status Bar -->
            <div class="config-status">
              <div class="status-item">
                <span class="status-label">Placed:</span>
                <span class="status-value" x-text="placedCount + '/' + totalCount"></span>
              </div>
              <div class="status-divider"></div>
              <div class="status-item" x-show="selectedSensor">
                <span class="status-label">Selected:</span>
                <span class="status-value" x-text="selectedSensor?.friendly_name || 'None'"></span>
              </div>
              <div class="status-divider" x-show="selectedSensor && selectedRoom"></div>
              <div class="status-item" x-show="selectedRoom">
                <span class="status-label">Room:</span>
                <span class="status-value" x-text="selectedRoom || '-'"></span>
              </div>
              <div style="flex: 1;"></div>
              <button class="reset-btn" @click="resetAllPositions()" title="Remove all sensor placements">
                üóëÔ∏è Reset All
              </button>
              <button class="help-btn" @click="showHelp = !showHelp" title="Help">‚ùì</button>
            </div>
          </div>
        </div>

        <!-- Vision 10: CO2 Monitor -->
        <div x-show="currentView === 'co2'" x-cloak x-data="co2View()" x-init="init()">
          <div class="co2-view">

            <!-- Giant Circular Gauge -->
            <div class="co2-gauge-section">
              <div class="co2-gauge-header">AIR QUALITY</div>
              <div class="co2-gauge">
                <svg viewBox="0 0 200 200" class="co2-gauge-ring">
                  <circle cx="100" cy="100" r="90" class="co2-gauge-bg"/>
                  <circle cx="100" cy="100" r="90"
                          class="co2-gauge-arc"
                          :class="{ pulse: !isStale }"
                          :stroke="co2Color"
                          :stroke-dasharray="gaugeArc"
                          transform="rotate(-90 100 100)"/>
                </svg>
                <div class="co2-gauge-content">
                  <span class="co2-value" :style="{ color: co2Color }" x-text="co2Value ?? '--'"></span>
                  <span class="co2-unit">ppm</span>
                  <span class="co2-status" :style="{ color: co2Color }" x-text="airQualityLevel"></span>
                  <div class="co2-trend" :class="trendDirection" x-show="trendDirection !== 'stable'">
                    <span class="co2-trend-arrow" x-text="trendArrow"></span>
                    <span x-text="trendValue + ' ppm'"></span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Air Quality Dashboard (3 Cards) -->
            <div class="air-quality-dashboard">
              <!-- CO2 Card -->
              <div class="air-quality-card highlight">
                <div class="air-quality-icon">üí®</div>
                <div class="air-quality-label">CO2</div>
                <div class="air-quality-value" :style="{ color: co2Color }" x-text="(co2Value ?? '--') + ' ppm'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: co2Percent + '%', background: co2Color }"></div>
                </div>
                <div class="air-quality-status" x-text="airQualityLevel"></div>
              </div>

              <!-- Temperature Card -->
              <div class="air-quality-card">
                <div class="air-quality-icon">üå°Ô∏è</div>
                <div class="air-quality-label">Temperature</div>
                <div class="air-quality-value" :style="{ color: tempColor }" x-text="temperature !== null ? temperature.toFixed(1) + '¬∞C' : '--'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: tempPercent + '%', background: tempColor }"></div>
                </div>
                <div class="air-quality-status" x-text="tempLevel"></div>
              </div>

              <!-- Humidity Card -->
              <div class="air-quality-card">
                <div class="air-quality-icon">üíß</div>
                <div class="air-quality-label">Humidity</div>
                <div class="air-quality-value" :style="{ color: humidityColor }" x-text="humidity !== null ? Math.round(humidity) + '%' : '--'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: humidityPercent + '%', background: humidityColor }"></div>
                </div>
                <div class="air-quality-status" x-text="humidityLevel"></div>
              </div>
            </div>

            <!-- History Chart -->
            <div class="co2-chart-section">
              <div class="chart-header">
                <div class="chart-title">CO2 History</div>
                <div class="time-range-selector">
                  <template x-for="range in timeRanges" :key="range">
                    <button class="time-range-btn"
                            :class="{ active: timeRange === range }"
                            @click="setTimeRange(range)"
                            x-text="range"></button>
                  </template>
                </div>
              </div>

              <div class="co2-chart-container">
                <div class="chart-loading" x-show="loading">
                  <span class="loading-indicator"></span>
                  Loading history...
                </div>
                <div class="chart-no-data" x-show="!loading && co2History.length === 0">
                  No data in this time range
                </div>
                <svg id="co2-history-chart" class="co2-chart" x-show="!loading && co2History.length > 0"></svg>
              </div>

              <!-- Chart Stats -->
              <div class="chart-stats" x-show="co2History.length > 0">
                <div class="chart-stat">
                  <div class="chart-stat-label">Min</div>
                  <div class="chart-stat-value" x-text="minMax.min + ' ppm'"></div>
                </div>
                <div class="chart-stat">
                  <div class="chart-stat-label">Avg</div>
                  <div class="chart-stat-value" x-text="avgCo2 + ' ppm'"></div>
                </div>
                <div class="chart-stat">
                  <div class="chart-stat-label">Max</div>
                  <div class="chart-stat-value" x-text="minMax.max + ' ppm'"></div>
                </div>
              </div>
            </div>

            <!-- Legend -->
            <div class="co2-legend">
              <div class="legend-item">
                <div class="legend-dot" style="background: #34C759;"></div>
                <span>Excellent (&lt;600)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #30D158;"></div>
                <span>Good (600-1000)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FFD60A;"></div>
                <span>Moderate (1000-1500)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FF9500;"></div>
                <span>Poor (1500-2000)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FF3B30;"></div>
                <span>Bad (&gt;2000)</span>
              </div>
            </div>

            <!-- Footer -->
            <div class="co2-footer">
              <div class="co2-footer-item" :class="{ 'stale-indicator': isStale }">
                <span x-text="isStale ? '‚ö†Ô∏è' : '‚úì'"></span>
                <span x-text="'Last update: ' + formatLastUpdate()"></span>
              </div>
              <div class="co2-footer-item">
                <span>üìç</span>
                <span x-text="sensorRoom"></span>
              </div>
              <div class="co2-footer-item" x-show="co2History.length > 0">
                <span>üìä</span>
                <span x-text="co2History.length + ' readings'"></span>
              </div>
            </div>

            <!-- Ambient Mode Toggle Button -->
            <button class="ambient-toggle" @click="toggleAmbient()">
              üåô Ambient Mode
            </button>

            <!-- Ambient Mode Overlay -->
            <div class="co2-ambient-overlay" :class="{ hidden: !ambientMode }" @click="ambientMode = false">
              <div class="ambient-co2-value" :style="{ color: co2Color }" x-text="co2Value ?? '--'"></div>
              <div class="ambient-co2-unit">ppm</div>
              <div class="ambient-status" :style="{ color: co2Color }" x-text="airQualityLevel"></div>
              <div class="ambient-trend" x-text="trendArrow"></div>
              <div class="ambient-room" x-text="sensorRoom"></div>
              <div class="ambient-hint">Tap anywhere to exit</div>
            </div>

          </div>
        </div>

        <!-- Zigbee Network View -->
        <div x-show="currentView === 'network'" x-cloak x-data="networkView()" x-init="init()">
          <div class="network-view">
            <!-- Controls -->
            <div class="network-controls">
              <button class="network-control-btn" :class="{ active: showSignalRange }"
                      @click="showSignalRange = !showSignalRange">
                üì∂ <span x-text="showSignalRange ? 'Hide Range' : 'Show Range'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: showLabels }"
                      @click="showLabels = !showLabels">
                üè∑Ô∏è <span x-text="showLabels ? 'Hide Labels' : 'Show Labels'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: autoRotate }"
                      @click="toggleAutoRotate()">
                üîÑ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
              </button>
              <button class="network-control-btn" @click="resetView()">
                üéØ Reset
              </button>
              <div class="network-zoom-controls">
                <button class="network-control-btn network-zoom-btn" @click="zoomOut()">‚ûñ</button>
                <span class="network-zoom-indicator" x-text="getZoomPercent() + '%'"></span>
                <button class="network-control-btn network-zoom-btn" @click="zoomIn()">‚ûï</button>
              </div>
            </div>

            <!-- Network Canvas Container -->
            <div class="network-container" x-ref="networkContainer"></div>

            <!-- Legend -->
            <div class="network-legend">
              <div class="legend-item">
                <div class="legend-badge coordinator">Z</div>
                <span>Zigbee Coordinator</span>
              </div>
              <div class="legend-item">
                <div class="legend-badge router">R</div>
                <span>Zigbee Router</span>
              </div>
              <div class="legend-item">
                <div class="legend-badge end-device">E</div>
                <span>Zigbee End Device</span>
              </div>
            </div>

            <!-- Stats -->
            <div class="network-stats">
              <div class="network-stat">
                <span>üì°</span>
                <span x-text="deviceCount + ' devices'"></span>
              </div>
              <div class="network-stat">
                <span>üîó</span>
                <span x-text="routerCount + ' routers'"></span>
              </div>
              <div class="network-stat">
                <span>üìç</span>
                <span x-text="endDeviceCount + ' end devices'"></span>
              </div>
            </div>
          </div>
        </div>

      </div>
    </main>

    <!-- Footer -->
    <footer class="app-footer" x-show="currentView !== 'ambient'">
      <span class="footer-status">
        <span class="loading-indicator" x-show="$store.mqtt.connecting"></span>
        <span class="status-dot" :class="{ 'connected': $store.mqtt.connected, 'disconnected': !$store.mqtt.connected }" x-show="!$store.mqtt.connecting"></span>
        <span x-text="$store.mqtt.connecting ? 'Connecting...' : ($store.mqtt.connected ? 'Connected' : 'Reconnecting...')"></span>
      </span>
      <span> ‚Ä¢ </span>
      <span x-show="$store.rooms.loading" class="footer-status">
        <span class="loading-indicator"></span>
        <span>Loading history...</span>
      </span>
      <span x-show="!$store.rooms.loading" x-text="$store.rooms.historyCount + ' data points'"></span>
      <span x-show="$store.lights.syncing"> ‚Ä¢ <span class="loading-indicator"></span> Syncing lights...</span>
    </footer>

    <!-- Room Detail Modal -->
    <template x-if="$store.roomDetail.selectedRoom">
      <div class="modal-overlay" @click.self="$store.roomDetail.close()" @keydown.escape.window="$store.roomDetail.close()">
        <div class="modal">
          <div class="modal-header">
            <div class="modal-title">
              <span class="icon" x-text="$store.roomDetail.selectedRoom.icon"></span>
              <h2 x-text="$store.roomDetail.selectedRoom.name"></h2>
            </div>
            <button class="modal-close" @click="$store.roomDetail.close()">&times;</button>
          </div>
          <div class="modal-body">
            <div class="time-range-selector">
              <template x-for="range in $store.roomDetail.timeRanges" :key="range">
                <button class="btn btn-secondary" :class="{ active: $store.roomDetail.timeRange === range }"
                        @click="$store.roomDetail.setTimeRange(range)" x-text="range"></button>
              </template>
              <span x-show="$store.roomDetail.loading" class="loading-indicator"></span>
            </div>

            <div class="modal-stats">
              <div class="modal-stat">
                <div class="modal-stat-label">Temperature</div>
                <div class="modal-stat-value temp"
                     x-text="$store.roomDetail.selectedRoom.temperature !== null
                       ? $store.roomDetail.selectedRoom.temperature.toFixed(1) + '¬∞C' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Humidity</div>
                <div class="modal-stat-value humid"
                     x-text="$store.roomDetail.selectedRoom.humidity !== null
                       ? $store.roomDetail.selectedRoom.humidity.toFixed(0) + '%' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Min / Max</div>
                <div class="modal-stat-value minmax" x-text="$store.roomDetail.getMinMax()"></div>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Temperature History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-temp">
                <template x-if="$store.roomDetail.tempHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-temp" x-show="$store.roomDetail.tempHistory.length > 0"></svg>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Humidity History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-humid">
                <template x-if="$store.roomDetail.humidHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-humid" x-show="$store.roomDetail.humidHistory.length > 0"></svg>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <span x-text="'Last updated: ' + $store.roomDetail.formatUpdate($store.roomDetail.selectedRoom.lastSeen)"></span>
            <span> ‚Ä¢ </span>
            <span x-text="$store.roomDetail.tempHistory.length + ' temperature readings, ' + $store.roomDetail.humidHistory.length + ' humidity readings'"></span>
          </div>
        </div>
      </div>
    </template>

  </div>

  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <!-- Stub for co2View - provides initial state and reactive getters -->
  <script>
    window.co2View = function() {
      return {
        // CO2 Thresholds (ppm)
        thresholds: { excellent: 600, good: 1000, moderate: 1500, poor: 2000 },

        // State
        timeRange: '6h',
        timeRanges: ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d'],
        loading: false,
        co2History: [],
        tempHistory: [],
        humidHistory: [],
        trendDirection: 'stable',
        trendValue: 0,
        ambientMode: false,
        _moduleLoaded: false,

        // Reactive getters that access the store directly
        get co2Sensor() {
          const sensors = this.$store?.sensors;
          if (!sensors?.devices) return null;
          return sensors.devices.find(d =>
            d.friendly_name?.toLowerCase().includes('co2') && d.sensorType === 'co2'
          );
        },
        get liveData() {
          if (!this.co2Sensor) return null;
          return this.$store?.sensors?.getLiveData?.(this.co2Sensor.ieee_address) ?? null;
        },
        get co2Value() { return this.liveData?.co2 ?? null; },
        get temperature() { return this.liveData?.temperature ?? null; },
        get humidity() { return this.liveData?.humidity ?? null; },
        get airQualityLevel() {
          const co2 = this.co2Value;
          if (co2 === null) return 'unknown';
          if (co2 < this.thresholds.excellent) return 'excellent';
          if (co2 < this.thresholds.good) return 'good';
          if (co2 < this.thresholds.moderate) return 'moderate';
          if (co2 < this.thresholds.poor) return 'poor';
          return 'bad';
        },
        get co2Color() {
          const colors = { excellent: '#34C759', good: '#30D158', moderate: '#FFD60A', poor: '#FF9500', bad: '#FF3B30', unknown: '#AEAEB2' };
          return colors[this.airQualityLevel];
        },
        get gaugeArc() {
          const maxPPM = 2500;
          const value = Math.min(this.co2Value || 0, maxPPM);
          const percent = value / maxPPM;
          const circumference = 2 * Math.PI * 90;
          return `${percent * circumference} ${circumference}`;
        },
        get tempLevel() {
          const temp = this.temperature;
          if (temp === null) return 'unknown';
          if (temp < 18) return 'cold';
          if (temp < 20) return 'cool';
          if (temp <= 26) return 'comfortable';
          if (temp <= 28) return 'warm';
          return 'hot';
        },
        get tempColor() {
          const colors = { cold: '#90CAF9', cool: '#A5D6A7', comfortable: '#81C784', warm: '#FFE082', hot: '#EF5350', unknown: '#AEAEB2' };
          return colors[this.tempLevel];
        },
        get humidityLevel() {
          const h = this.humidity;
          if (h === null) return 'unknown';
          if (h < 30) return 'dry';
          if (h < 40) return 'low';
          if (h <= 60) return 'optimal';
          if (h <= 70) return 'high';
          return 'humid';
        },
        get humidityColor() {
          const colors = { dry: '#FFCC80', low: '#A5D6A7', optimal: '#81C784', high: '#90CAF9', humid: '#5C6BC0', unknown: '#AEAEB2' };
          return colors[this.humidityLevel];
        },
        get isStale() {
          if (!this.co2Sensor) return true;
          return this.$store?.sensors?.isStale?.(this.co2Sensor.ieee_address) ?? true;
        },
        get trendArrow() {
          if (this.trendDirection === 'rising') return '\u2191';
          if (this.trendDirection === 'falling') return '\u2193';
          return '\u2192';
        },
        get sensorRoom() {
          if (!this.co2Sensor) return 'Unknown';
          const name = this.co2Sensor.friendly_name || '';
          const match = name.match(/\[([^\]]+)\]/);
          return match ? match[1] + ' Room' : 'Room';
        },
        get minMax() {
          if (this.co2History.length === 0) return { min: '--', max: '--' };
          const values = this.co2History.map(d => d.value);
          return { min: Math.round(Math.min(...values)), max: Math.round(Math.max(...values)) };
        },
        get avgCo2() {
          if (this.co2History.length === 0) return '--';
          const sum = this.co2History.reduce((acc, d) => acc + d.value, 0);
          return Math.round(sum / this.co2History.length);
        },
        get co2Percent() { return Math.min(100, ((this.co2Value || 0) / 2500) * 100); },
        get tempPercent() { return Math.min(100, Math.max(0, ((this.temperature || 20) - 15) / 20 * 100)); },
        get humidityPercent() { return Math.min(100, Math.max(0, this.humidity || 0)); },

        // Methods
        init() {
          console.log('[co2-view] Stub initialized, waiting for module...');
          window._co2ViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          if (window._co2ViewMethods && !this._moduleLoaded) {
            console.log('[co2-view] Module methods available, enhancing...');
            this._moduleLoaded = true;
            // Only copy methods, not getters (getters are already defined above)
            const methods = window._co2ViewMethods;
            if (methods.loadHistoricalData) this.loadHistoricalData = methods.loadHistoricalData.bind(this);
            if (methods.queryInflux) this.queryInflux = methods.queryInflux.bind(this);
            if (methods.setTimeRange) this.setTimeRange = methods.setTimeRange.bind(this);
            if (methods.drawChart) this.drawChart = methods.drawChart.bind(this);
            if (methods.drawThresholdZones) this.drawThresholdZones = methods.drawThresholdZones.bind(this);
            if (methods.formatTimeLabel) this.formatTimeLabel = methods.formatTimeLabel.bind(this);
            if (methods.calculateTrend) this.calculateTrend = methods.calculateTrend.bind(this);
            if (methods.formatLastUpdate) this.formatLastUpdate = methods.formatLastUpdate.bind(this);
            // Load historical data now
            this.loadHistoricalData();
          } else if (!this._moduleLoaded) {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        loadHistoricalData() { console.log('[co2-view] Stub loadHistoricalData (waiting for module)'); },
        setTimeRange(range) { this.timeRange = range; },
        drawChart() {},
        calculateTrend() {},
        formatLastUpdate() { return 'No data'; },
        toggleAmbient() { this.ambientMode = !this.ambientMode; },
        destroy() {}
      };
    };
  </script>

  <!-- Stub for sensorConfigView - reactive stub that pulls from Alpine store -->
  <script>
    window.sensorConfigView = function() {
      return {
        searchQuery: '',
        expandedTypes: { climate: true, co2: true, motion: true, contact: true },
        showHelp: false,
        isTopView: false,
        showCoverage: false,
        tooltip: { text: '', visible: false, x: 0, y: 0 },
        selectedSensor: null,

        init() {
          console.log('[sensor-config] Stub initialized, waiting for Three.js module...');
          // Store reference for module to find and enhance
          window._sensorConfigComponent = this;
          this._checkForThreeJS();
        },

        _checkForThreeJS() {
          if (window._initSensorConfigThreeJS) {
            console.log('[sensor-config] Three.js module ready, initializing 3D view...');
            window._initSensorConfigThreeJS(this);
          } else {
            // Keep checking until module loads
            setTimeout(() => this._checkForThreeJS(), 100);
          }
        },

        // Reactive getters that pull from sensors store
        get loading() { return Alpine.store('sensors')?.loading ?? true; },
        get placedCount() { return Alpine.store('sensors')?.placedCount ?? 0; },
        get totalCount() { return Alpine.store('sensors')?.totalCount ?? 0; },
        get sensors() { return Alpine.store('sensors')?.devices ?? []; },
        get positions() { return Alpine.store('sensors')?.positions ?? {}; },
        get selectedRoom() {
          if (!this.selectedSensor) return null;
          return Alpine.store('sensors')?.getPosition(this.selectedSensor.ieee_address)?.roomId || null;
        },
        get hasCoverageToggle() {
          return this.sensors.some(s => s.sensorType === 'motion');
        },
        get sensorsByType() {
          const sensors = this.sensors;
          const grouped = { climate: [], co2: [], motion: [], contact: [] };
          sensors.forEach(sensor => {
            const type = sensor.sensorType || 'climate';
            if (grouped[type]) {
              if (!this.searchQuery ||
                  sensor.friendly_name.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                  type.includes(this.searchQuery.toLowerCase())) {
                grouped[type].push(sensor);
              }
            }
          });
          return grouped;
        },

        // Helper methods
        getTypeIcon(type) { return { climate: 'üå°Ô∏è', co2: 'üí®', motion: 'üëÅÔ∏è', contact: 'üö™' }[type] || 'üì°'; },
        getTypeLabel(type) { return { climate: 'Temperature & Humidity', co2: 'CO‚ÇÇ Sensors', motion: 'Motion Sensors', contact: 'Contact Sensors' }[type] || 'Unknown'; },
        getTypeColor(type) { return { climate: '#34d399', co2: '#ff6b6b', motion: '#ffd93d', contact: '#38bdf8' }[type] || '#888'; },

        formatLiveValue(sensor) {
          const data = Alpine.store('sensors')?.getLiveData(sensor.ieee_address);
          if (!data) return '--';
          switch (sensor.sensorType) {
            case 'climate':
              const temp = data.temperature !== undefined ? `${data.temperature.toFixed(1)}¬∞` : '--';
              const hum = data.humidity !== undefined ? `${Math.round(data.humidity)}%` : '';
              return `${temp} ${hum}`.trim();
            case 'co2': return data.co2 !== undefined ? `${data.co2} ppm` : '--';
            case 'motion': return data.occupancy !== undefined ? (data.occupancy ? 'üî¥ Motion' : '‚ö™ Clear') : '--';
            case 'contact': return data.contact !== undefined ? (data.contact ? 'üîí Closed' : 'üîì Open') : '--';
            default: return '--';
          }
        },
        isPlaced(ieee) { return Alpine.store('sensors')?.isPlaced(ieee) || false; },
        isStale(ieee) { return Alpine.store('sensors')?.isStale(ieee) || false; },

        selectSensor(sensor) {
          this.selectedSensor = this.selectedSensor?.ieee_address === sensor.ieee_address ? null : sensor;
          if (window._sensorConfigController) {
            window._sensorConfigController.selectedSensor = this.selectedSensor?.ieee_address;
          }
        },
        startDrag(e, sensor) {
          e.dataTransfer?.setData('sensor-ieee', sensor.ieee_address);
          this.selectedSensor = sensor;
          // Start drag in Three.js controller
          if (window._sensorConfigController?.startDragFromPalette) {
            window._sensorConfigController.startDragFromPalette(sensor.ieee_address);
          }
        },
        onDragOver(e) {
          e.preventDefault();
          // Check if dragging a sensor
          if (!e.dataTransfer?.types?.includes('sensor-ieee')) return;

          const controller = window._sensorConfigController;
          const container = e.currentTarget;
          if (!controller || !container) return;

          // Calculate normalized mouse position
          const rect = container.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

          // Update preview position
          if (controller.updateDragPreview) {
            controller.updateDragPreview(x, y);
          }
        },
        onDragLeave(e) {
          // Hide preview when leaving canvas
          const threeState = window._configThreeState;
          if (threeState?.dragPreview) {
            threeState.dragPreview.visible = false;
          }
        },
        onDrop(e) {
          e.preventDefault();
          const ieee = e.dataTransfer?.getData('sensor-ieee');
          if (!ieee) return;

          const controller = window._sensorConfigController;
          const container = e.currentTarget;
          if (!controller || !container) return;

          // Calculate normalized mouse position for raycasting
          const rect = container.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

          // Use controller to handle the drop
          if (controller.handlePaletteDrop) {
            controller.handlePaletteDrop(ieee, x, y);
          }
        },
        resetView() {
          if (window._sensorConfigController?.onResize) {
            window._sensorConfigController.onResize();
          }
        },
        toggleTopView() {
          this.isTopView = !this.isTopView;
          // Could adjust camera angle via controller
        },
        zoomIn() {
          // Zoom via Three.js camera if available
          console.log('[stub] zoomIn');
        },
        zoomOut() {
          console.log('[stub] zoomOut');
        },
        resetAllPositions() { Alpine.store('sensors')?.resetAllPositions(); },
        toggleCoverage() {
          this.showCoverage = !this.showCoverage;
          if (window._sensorConfigController?.toggleCoverage) {
            window._sensorConfigController.toggleCoverage();
          }
        }
      };
    };
  </script>

  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <!-- CO2 Monitor Module - enhances the stub with methods -->
  <script type="module">
    import { co2View } from './views/co2-monitor.js?v=3';

    // Get the module object and extract only the methods (not getters)
    const moduleObj = co2View();
    window._co2ViewMethods = {
      loadHistoricalData: moduleObj.loadHistoricalData,
      queryInflux: moduleObj.queryInflux,
      setTimeRange: moduleObj.setTimeRange,
      drawChart: moduleObj.drawChart,
      drawThresholdZones: moduleObj.drawThresholdZones,
      formatTimeLabel: moduleObj.formatTimeLabel,
      calculateTrend: moduleObj.calculateTrend,
      formatLastUpdate: moduleObj.formatLastUpdate
    };
    console.log('[co2-monitor] Module loaded, methods ready');

    // If stub component exists, trigger enhancement
    if (window._co2ViewComponent && !window._co2ViewComponent._moduleLoaded) {
      console.log('[co2-monitor] Stub found, enhancing with methods...');
      window._co2ViewComponent._checkForModule();
    }
  </script>

  <!-- Sensor Config Module - loads after Alpine, enhances the stub -->
  <script type="module">
    import { sensorConfigView } from './views/sensor-config.js?v=3';
    import { initSensorsStore } from './js/stores/sensors-store.js';
    import { FLOOR_PLAN_CONFIG, SENSOR_VISUALS } from './js/config.js';

    // Create a Three.js controller that will manage the 3D view
    // This is separate from Alpine's reactive system to avoid proxy issues
    const threeJSController = sensorConfigView(FLOOR_PLAN_CONFIG, SENSOR_VISUALS, THREE.OrbitControls);

    // Store controller globally for stub access
    window._sensorConfigThreeJS = threeJSController;

    // Expose initialization function for stub to call
    // Guard against multiple initializations
    let initializationComplete = false;

    window._initSensorConfigThreeJS = function(alpineComponent) {
      // Prevent multiple initializations
      if (initializationComplete) {
        console.log('[sensor-config] Already initialized, skipping');
        return;
      }
      console.log('[sensor-config] Initializing Three.js controller...');

      // The controller needs access to Alpine component for $refs
      const container = alpineComponent.$refs?.configCanvas;
      if (!container) {
        console.error('[sensor-config] Container ref not found, retrying...');
        setTimeout(() => window._initSensorConfigThreeJS(alpineComponent), 100);
        return;
      }

      // Create proxy object that gives controller access to container
      const controllerContext = {
        $refs: { configCanvas: container },
        tooltip: alpineComponent.tooltip,
        selectedSensor: null,
        showMotionCoverage: false
      };

      // Bind all controller methods to the proxy context
      Object.keys(threeJSController).forEach(key => {
        if (typeof threeJSController[key] === 'function') {
          controllerContext[key] = threeJSController[key].bind(controllerContext);
        }
      });

      // Store the bound controller for stub methods to use
      window._sensorConfigController = controllerContext;

      // Add custom drop handler for palette drops
      controllerContext.handlePaletteDrop = function(ieee, mouseX, mouseY) {
        const threeState = window._configThreeState;

        // Hide drag preview
        if (threeState?.dragPreview) {
          threeState.dragPreview.visible = false;
        }

        // Re-enable controls
        if (threeState?.controls) {
          threeState.controls.enabled = true;
        }

        if (!threeState?.raycaster || !threeState?.camera || !threeState?.floorPlane) {
          console.error('[sensor-config] Three.js state not ready for drop', {
            raycaster: !!threeState?.raycaster,
            camera: !!threeState?.camera,
            floorPlane: !!threeState?.floorPlane
          });
          return;
        }

        // Set mouse position for raycaster
        const mouse = new THREE.Vector2(mouseX, mouseY);
        threeState.raycaster.setFromCamera(mouse, threeState.camera);

        // Raycast to floor plane
        const intersects = threeState.raycaster.intersectObject(threeState.floorPlane);
        if (intersects.length === 0) {
          console.log('[sensor-config] Drop missed floor plane');
          return;
        }

        const point = intersects[0].point;
        const sensor = Alpine.store('sensors').getSensor(ieee);
        if (!sensor) {
          console.error('[sensor-config] Sensor not found:', ieee);
          return;
        }

        const visuals = window.SENSOR_VISUALS?.[sensor.sensorType] || window.SENSOR_VISUALS?.climate;
        const position = {
          x: point.x,
          y: visuals?.heightAboveFloor || 1.5,
          z: point.z
        };

        // Detect which room using bound detectRoom method
        const roomId = controllerContext.detectRoom ? controllerContext.detectRoom(point.x, point.z) : null;

        // Save position to store (persists via MQTT)
        Alpine.store('sensors').savePosition(ieee, position, roomId);
        console.log('[sensor-config] Sensor placed:', ieee, 'at', position, 'in', roomId);
      };

      // Update preview position during drag-over
      controllerContext.updateDragPreview = function(mouseX, mouseY) {
        const threeState = window._configThreeState;
        if (!threeState?.raycaster || !threeState?.camera || !threeState?.floorPlane) return;

        // Raycast to floor plane
        const mouse = new THREE.Vector2(mouseX, mouseY);
        threeState.raycaster.setFromCamera(mouse, threeState.camera);
        const intersects = threeState.raycaster.intersectObject(threeState.floorPlane);

        if (intersects.length === 0) {
          // Hide preview if not over floor
          if (threeState.dragPreview) threeState.dragPreview.visible = false;
          return;
        }

        const point = intersects[0].point;

        // Create preview sphere if not exists
        if (!threeState.dragPreview) {
          const geometry = new THREE.SphereGeometry(0.15, 16, 16);
          const material = new THREE.MeshBasicMaterial({
            color: 0x34d399,  // Green
            transparent: true,
            opacity: 0.8
          });
          threeState.dragPreview = new THREE.Mesh(geometry, material);
          threeState.scene.add(threeState.dragPreview);
        }

        // Update preview position
        threeState.dragPreview.visible = true;
        threeState.dragPreview.position.set(point.x, 1.5, point.z);

        // Color based on validity (green = valid room, red = invalid)
        const roomId = controllerContext.detectRoom ? controllerContext.detectRoom(point.x, point.z) : null;
        threeState.dragPreview.material.color.setHex(roomId ? 0x34d399 : 0xff6b6b);
      };

      // Custom initialization that waits for container to be visible
      function initThreeJS() {
        const c = container;
        if (!c || c.clientWidth === 0 || c.clientHeight === 0) {
          // Container not visible yet (view hidden), retry
          setTimeout(initThreeJS, 200);
          return;
        }

        console.log('[sensor-config] Container ready, initializing Three.js...');
        try {
          controllerContext.initScene();
          controllerContext.initCamera(c, THREE.OrbitControls);
          controllerContext.initRenderer(c);
          controllerContext.initLighting();
          controllerContext.initRaycaster();
          controllerContext.buildFloorPlan();
          controllerContext.setupEventListeners(c);
          controllerContext.animate();
          initializationComplete = true;
          console.log('[sensor-config] Three.js initialization complete!');
        } catch (e) {
          console.error('[sensor-config] Three.js init error:', e);
        }
      }

      initThreeJS();
    };
    console.log('[sensor-config] Module loaded, _initSensorConfigThreeJS ready');

    // Replace stub for any future component creations
    window.sensorConfigView = function() {
      return sensorConfigView(FLOOR_PLAN_CONFIG, SENSOR_VISUALS, THREE.OrbitControls);
    };

    // Initialize sensors store
    function initSensors() {
      const CONFIG = window.CONFIG;
      if (typeof Alpine !== 'undefined' && CONFIG) {
        if (!Alpine.store('sensors')) {
          initSensorsStore(Alpine, CONFIG);
          console.log('[sensor-config] Sensors store initialized');
        }
        // Initialize MQTT subscriptions
        setTimeout(() => {
          const sensorsStore = Alpine.store('sensors');
          if (sensorsStore && Alpine.store('mqtt')?.client) {
            sensorsStore.init();
            console.log('[sensor-config] Sensors MQTT subscriptions initialized');
          }
        }, 2000);
      }
    }

    // Try to initialize
    if (typeof Alpine !== 'undefined') {
      initSensors();
    } else {
      document.addEventListener('alpine:init', () => {
        initSensorsStore(Alpine, window.CONFIG);
      });
      document.addEventListener('DOMContentLoaded', initSensors);
    }
  </script>

  <script>
    // ========================================
    // CONFIGURATION
    // ========================================
    const CONFIG = {
      mqttUrl: 'ws://' + window.location.hostname + ':9001',
      baseTopic: 'zigbee2mqtt',
      influxUrl: '/api/influx',
      influxDb: 'homeassistant',
      rooms: [
        { id: 'living', name: 'Living Room', icon: 'üõãÔ∏è', sensor: '[Living] Temperature & Humidity', entityId: 'sensor.living_temperature_humidity' },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', sensor: '[Bed] Temperature & Humidity Sensor', entityId: 'sensor.bed_temperature_humidity_sensor' },
        { id: 'study', name: 'Study', icon: 'üìö', sensor: '[Study] Temperature & Humidity', entityId: 'sensor.study_temperature_humidity' },
        { id: 'kitchen', name: 'Kitchen', icon: 'üç≥', sensor: '[Kitchen] Temperature & Humidity', entityId: 'sensor.kitchen_temperature_humidity' },
        { id: 'bathroom', name: 'Bathroom', icon: 'üöø', sensor: '[Bath] Temperature & Humidity', entityId: 'sensor.bath_temperature_humidity' },
        { id: 'balcony', name: 'Balcony', icon: 'üåø', sensor: '[Balcony] Temperature & Humidity', entityId: 'sensor.balcony_temperature_humidity' }
      ],
      staleThreshold: 5 * 60 * 1000,
      maxHistoryPoints: 500,
      historyHours: 6
    };
    // Make CONFIG globally available for modules
    window.CONFIG = CONFIG;

    // ========================================
    // ALPINE STORES
    // ========================================
    document.addEventListener('alpine:init', () => {

      // Config store
      Alpine.store('config', CONFIG);

      // MQTT connection store
      Alpine.store('mqtt', {
        connected: false,
        connecting: true,
        client: null,

        connect() {
          this.connecting = true;

          this.client = mqtt.connect(CONFIG.mqttUrl, {
            clientId: 'climate-' + Math.random().toString(16).substr(2, 8),
            reconnectPeriod: 3000,
            connectTimeout: 10000
          });

          this.client.on('connect', () => {
            this.connected = true;
            this.connecting = false;

            // Subscribe to room sensors
            CONFIG.rooms.forEach(room => {
              this.client.subscribe(`${CONFIG.baseTopic}/${room.sensor}`, { qos: 0 });
            });

            // Subscribe to light topics (state and availability)
            Alpine.store('lights').list.forEach(light => {
              this.client.subscribe(`${CONFIG.baseTopic}/${light.topic}`, { qos: 0 });
              this.client.subscribe(`${CONFIG.baseTopic}/${light.topic}/availability`, { qos: 0 });
            });
          });

          this.client.on('message', (topic, message) => {
            try {
              const msgStr = message.toString();
              const deviceName = topic.replace(`${CONFIG.baseTopic}/`, '');

              // Check if it's an availability message
              if (topic.endsWith('/availability')) {
                const lightTopic = deviceName.replace('/availability', '');
                // Handle both JSON {"state":"online"} and plain string "online"
                let isOnline;
                try {
                  const data = JSON.parse(msgStr);
                  isOnline = data.state === 'online';
                } catch {
                  isOnline = msgStr === 'online';
                }
                Alpine.store('lights').setAvailability(lightTopic, isOnline);
                return;
              }

              const data = JSON.parse(msgStr);

              // Check if it's a room sensor
              const roomConfig = CONFIG.rooms.find(r => r.sensor === deviceName);
              if (roomConfig) {
                Alpine.store('rooms').updateRoom(deviceName, data);
                return;
              }

              // Check if it's a light
              Alpine.store('lights').updateLight(deviceName, data);
            } catch (e) {
              console.error('MQTT parse error:', e);
            }
          });

          this.client.on('error', (err) => console.error('MQTT Error:', err));
          this.client.on('close', () => { this.connected = false; this.connecting = true; });
          this.client.on('reconnect', () => { this.connecting = true; });
        }
      });

      // Rooms data store
      Alpine.store('rooms', {
        list: CONFIG.rooms.map(r => ({
          ...r,
          temperature: null,
          humidity: null,
          lastSeen: null,
          stale: false,
          tempHistory: [],
          humidHistory: []
        })),
        lastUpdate: null,
        loading: false,

        get historyCount() {
          return this.list.reduce((sum, r) => sum + r.tempHistory.length + r.humidHistory.length, 0);
        },

        updateRoom(sensorName, data) {
          const roomIndex = this.list.findIndex(r => r.sensor === sensorName);
          if (roomIndex === -1) return;

          const room = this.list[roomIndex];
          const now = Date.now();

          let sensorTime = now;
          if (data.last_seen) {
            sensorTime = typeof data.last_seen === 'number' ? data.last_seen : new Date(data.last_seen).getTime();
          }

          if (data.temperature !== undefined) {
            room.temperature = data.temperature;
            room.tempHistory.push({ time: sensorTime, value: data.temperature });
            if (room.tempHistory.length > CONFIG.maxHistoryPoints) room.tempHistory.shift();
          }

          if (data.humidity !== undefined) {
            room.humidity = data.humidity;
            room.humidHistory.push({ time: sensorTime, value: data.humidity });
            if (room.humidHistory.length > CONFIG.maxHistoryPoints) room.humidHistory.shift();
          }

          room.lastSeen = sensorTime;
          room.stale = false;
          this.lastUpdate = now;
        },

        async loadHistorical() {
          this.loading = true;
          for (const room of this.list) {
            try {
              const tempQuery = `SELECT value FROM "¬∞C" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_temperature' AND time > now() - ${CONFIG.historyHours}h ORDER BY time ASC`;
              const tempUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(tempQuery)}`;
              const tempRes = await fetch(tempUrl);
              const tempData = await tempRes.json();

              if (tempData.results?.[0]?.series?.[0]?.values) {
                const values = tempData.results[0].series[0].values;
                room.tempHistory = values.map(v => ({ time: new Date(v[0]).getTime(), value: v[1] }));
                room.temperature = values[values.length - 1][1];
                room.lastSeen = new Date(values[values.length - 1][0]).getTime();
              }

              const humidQuery = `SELECT value FROM "%" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_humidity' AND time > now() - ${CONFIG.historyHours}h ORDER BY time ASC`;
              const humidUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(humidQuery)}`;
              const humidRes = await fetch(humidUrl);
              const humidData = await humidRes.json();

              if (humidData.results?.[0]?.series?.[0]?.values) {
                const values = humidData.results[0].series[0].values;
                room.humidHistory = values.map(v => ({ time: new Date(v[0]).getTime(), value: v[1] }));
                room.humidity = values[values.length - 1][1];
              }
            } catch (e) {
              console.error(`Failed to load history for ${room.name}:`, e);
            }
          }
          this.lastUpdate = Date.now();
          this.loading = false;
        },

        checkStale() {
          const now = Date.now();
          this.list.forEach(room => {
            if (room.lastSeen && (now - room.lastSeen) > CONFIG.staleThreshold) {
              room.stale = true;
            }
          });
        }
      });

      // Lights store
      Alpine.store('lights', {
        list: [
          {
            id: 'study_light',
            name: 'Study Light',
            icon: 'üìö',
            topic: '[Study] IKEA Light',
            state: 'OFF',
            brightness: 254,
            colorTemp: 370,
            linkquality: null,
            lastSeen: null,
            syncing: false,
            available: true
          },
          {
            id: 'living_light',
            name: 'Living Room Light',
            icon: 'üõãÔ∏è',
            topic: '[Living] IKEA Light',
            state: 'OFF',
            brightness: 254,
            colorTemp: 370,
            linkquality: null,
            lastSeen: null,
            syncing: false,
            available: true
          }
        ],
        syncing: false,
        initializing: true,

        get anyLightSyncing() {
          return this.list.some(l => l.syncing);
        },

        get lightsOnCount() {
          return this.list.filter(l => l.state === 'ON').length;
        },

        presets: {
          reading: { brightness: 254, colorTemp: 300 },
          relax: { brightness: 150, colorTemp: 400 },
          bright: { brightness: 254, colorTemp: 250 },
          night: { brightness: 30, colorTemp: 454 }
        },

        scenes: {
          movie: { state: 'ON', brightness: 50, colorTemp: 400 },
          work: { state: 'ON', brightness: 254, colorTemp: 280 },
          evening: { state: 'ON', brightness: 150, colorTemp: 380 },
          goodnight: { state: 'OFF' }
        },

        updateLight(topic, data) {
          const light = this.list.find(l => l.topic === topic);
          if (light) {
            if (data.state !== undefined) light.state = data.state;
            if (data.brightness !== undefined) light.brightness = data.brightness;
            if (data.color_temp !== undefined) light.colorTemp = data.color_temp;
            if (data.linkquality !== undefined) light.linkquality = data.linkquality;
            light.lastSeen = Date.now();
            light.syncing = false;
            this.initializing = false;
            this.syncing = this.anyLightSyncing;
          }
        },

        setAvailability(topic, isOnline) {
          const light = this.list.find(l => l.topic === topic);
          if (light) {
            light.available = isOnline;
            console.log(`Light ${light.name} availability: ${isOnline ? 'online' : 'offline'}`);
          }
        },

        publishCommand(light, payload) {
          const client = Alpine.store('mqtt').client;
          if (!client || !Alpine.store('mqtt').connected) {
            console.error('MQTT not connected');
            return;
          }

          // Set syncing state
          light.syncing = true;
          this.syncing = true;

          const topic = `zigbee2mqtt/${light.topic}/set`;
          client.publish(topic, JSON.stringify(payload), { qos: 0 }, (err) => {
            if (err) {
              console.error('Failed to publish:', err);
              light.syncing = false;
              this.syncing = this.anyLightSyncing;
            } else {
              // Syncing will be cleared when we receive the state update
              // Set a timeout to clear syncing if no response
              setTimeout(() => {
                if (light.syncing) {
                  light.syncing = false;
                  this.syncing = this.anyLightSyncing;
                }
              }, 3000);
            }
          });
        },

        toggleLight(light) {
          const newState = light.state === 'ON' ? 'OFF' : 'ON';
          this.publishCommand(light, { state: newState });
          light.state = newState; // Optimistic update
        },

        toggleAllLights() {
          const allOn = this.list.every(l => l.state === 'ON');
          const newState = allOn ? 'OFF' : 'ON';
          this.list.forEach(light => {
            this.publishCommand(light, { state: newState });
            light.state = newState;
          });
        },

        setBrightness(light, value) {
          const brightness = parseInt(value);
          this.publishCommand(light, { brightness });
          // Local state already updated by x-model
        },

        setColorTemp(light, value) {
          const colorTemp = parseInt(value);
          this.publishCommand(light, { color_temp: colorTemp });
          // Local state already updated by x-model
        },

        applyPreset(light, presetName) {
          const preset = this.presets[presetName];
          if (preset) {
            this.publishCommand(light, {
              brightness: preset.brightness,
              color_temp: preset.colorTemp
            });
            light.brightness = preset.brightness;
            light.colorTemp = preset.colorTemp;
          }
        },

        applyScene(sceneName) {
          const scene = this.scenes[sceneName];
          if (scene) {
            this.list.forEach(light => {
              this.publishCommand(light, scene);
              if (scene.state !== undefined) light.state = scene.state;
              if (scene.brightness !== undefined) light.brightness = scene.brightness;
              if (scene.colorTemp !== undefined) light.colorTemp = scene.colorTemp;
            });
          }
        }
      });

      // Room detail modal store
      Alpine.store('roomDetail', {
        selectedRoom: null,
        timeRange: '6h',
        loading: false,
        tempHistory: [],
        humidHistory: [],
        timeRanges: ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d'],

        open(room) {
          this.selectedRoom = room;
          this.timeRange = '6h';
          this.loadData();
        },

        close() {
          this.selectedRoom = null;
        },

        async setTimeRange(range) {
          this.timeRange = range;
          await this.loadData();
        },

        async loadData() {
          if (!this.selectedRoom) return;
          this.loading = true;

          try {
            const room = this.selectedRoom;

            const tempQuery = `SELECT value FROM "¬∞C" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_temperature' AND time > now() - ${this.timeRange} ORDER BY time ASC`;
            const tempUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(tempQuery)}`;
            const tempRes = await fetch(tempUrl);
            const tempData = await tempRes.json();

            if (tempData.results?.[0]?.series?.[0]?.values) {
              this.tempHistory = tempData.results[0].series[0].values.map(v => ({
                time: new Date(v[0]).getTime(),
                value: v[1]
              }));
            } else {
              this.tempHistory = [];
            }

            const humidQuery = `SELECT value FROM "%" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_humidity' AND time > now() - ${this.timeRange} ORDER BY time ASC`;
            const humidUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(humidQuery)}`;
            const humidRes = await fetch(humidUrl);
            const humidData = await humidRes.json();

            if (humidData.results?.[0]?.series?.[0]?.values) {
              this.humidHistory = humidData.results[0].series[0].values.map(v => ({
                time: new Date(v[0]).getTime(),
                value: v[1]
              }));
            } else {
              this.humidHistory = [];
            }

            console.log(`Loaded ${this.tempHistory.length} temp, ${this.humidHistory.length} humid points for ${this.timeRange}`);
          } catch (e) {
            console.error('Failed to load modal data:', e);
          }

          this.loading = false;
          setTimeout(() => this.drawCharts(), 50);
        },

        drawCharts() {
          this.drawChart('modal-chart-temp', this.tempHistory, '¬∞C', 'var(--color-primary)');
          this.drawChart('modal-chart-humid', this.humidHistory, '%', 'var(--color-success)');
        },

        drawChart(id, data, unit, color) {
          const svg = document.getElementById(id);
          if (!svg || data.length === 0) return;

          const width = svg.clientWidth || 700;
          const height = svg.clientHeight || 180;
          const padding = { top: 20, right: 50, bottom: 30, left: 50 };
          const chartWidth = width - padding.left - padding.right;
          const chartHeight = height - padding.top - padding.bottom;

          const values = data.map(d => d.value);
          const times = data.map(d => d.time);
          const minVal = Math.floor(Math.min(...values) - 1);
          const maxVal = Math.ceil(Math.max(...values) + 1);
          const minTime = Math.min(...times);
          const maxTime = Math.max(...times);
          const valueRange = maxVal - minVal || 1;
          const timeRange = maxTime - minTime || 1;

          let svgContent = '';

          const ySteps = 5;
          for (let i = 0; i <= ySteps; i++) {
            const y = padding.top + (i / ySteps) * chartHeight;
            const val = maxVal - (i / ySteps) * valueRange;
            svgContent += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="#e0e0e0" stroke-dasharray="3,3"/>`;
            svgContent += `<text x="${padding.left - 8}" y="${y + 4}" text-anchor="end" fill="var(--color-text-tertiary)" font-size="10">${val.toFixed(1)}${unit}</text>`;
          }

          const xSteps = Math.min(6, data.length);
          for (let i = 0; i <= xSteps; i++) {
            const x = padding.left + (i / xSteps) * chartWidth;
            const time = new Date(minTime + (i / xSteps) * timeRange);
            const label = time.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
            svgContent += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" stroke="#e0e0e0" stroke-dasharray="3,3"/>`;
            svgContent += `<text x="${x}" y="${height - 8}" text-anchor="middle" fill="var(--color-text-tertiary)" font-size="10">${label}</text>`;
          }

          svgContent += `<line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" stroke="var(--color-text-tertiary)"/>`;
          svgContent += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" stroke="var(--color-text-tertiary)"/>`;

          if (data.length >= 2) {
            const points = data.map(d => {
              const x = padding.left + ((d.time - minTime) / timeRange) * chartWidth;
              const y = padding.top + ((maxVal - d.value) / valueRange) * chartHeight;
              return `${x},${y}`;
            }).join(' ');

            const areaPoints = `${padding.left},${height - padding.bottom} ${points} ${width - padding.right},${height - padding.bottom}`;
            svgContent += `<polygon fill="${color}" opacity="0.15" points="${areaPoints}"/>`;
            svgContent += `<polyline fill="none" stroke="${color}" stroke-width="2.5" points="${points}"/>`;

            const lastPoint = data[data.length - 1];
            const lastX = padding.left + ((lastPoint.time - minTime) / timeRange) * chartWidth;
            const lastY = padding.top + ((maxVal - lastPoint.value) / valueRange) * chartHeight;
            svgContent += `<circle cx="${lastX}" cy="${lastY}" r="5" fill="${color}"/>`;
          }

          svg.innerHTML = svgContent;
        },

        getMinMax() {
          if (!this.tempHistory.length) return '--';
          const temps = this.tempHistory.map(d => d.value);
          return `${Math.min(...temps).toFixed(1)}¬∞ / ${Math.max(...temps).toFixed(1)}¬∞`;
        },

        formatUpdate(lastSeen) {
          if (!lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - lastSeen) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      });
    });

    // ========================================
    // MAIN APP COMPONENT
    // ========================================
    function app() {
      return {
        currentView: 'comfort',
        currentDateTime: '',
        now: Date.now(),

        get lastUpdateText() {
          const lastUpdate = Alpine.store('rooms').lastUpdate;
          if (!lastUpdate) return 'Waiting...';
          const seconds = Math.floor((this.now - lastUpdate) / 1000);
          if (seconds < 5) return 'Just now';
          if (seconds < 60) return `${seconds}s ago`;
          return `${Math.floor(seconds / 60)}m ago`;
        },

        init() {
          // Restore last view
          const saved = localStorage.getItem('dashboard-view');
          if (saved) this.currentView = saved;

          // Update time
          this.updateDateTime();
          setInterval(() => {
            this.updateDateTime();
            this.now = Date.now();
          }, 1000);

          // Check stale
          setInterval(() => Alpine.store('rooms').checkStale(), 10000);

          // Load historical data and connect MQTT
          Alpine.store('rooms').loadHistorical();
          Alpine.store('mqtt').connect();

          // Keyboard shortcuts for view switching
          document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) return;
            // 'I' key for isometric view
            if (e.key === 'i' || e.key === 'I') {
              this.setView('isometric');
              return;
            }
            // '0' key for CO2 view
            if (e.key === '0') {
              this.setView('co2');
              return;
            }
            // 'N' key for network view
            if (e.key === 'n' || e.key === 'N') {
              this.setView('network');
              return;
            }
            // 1-9 keys for other views
            if (e.key >= '1' && e.key <= '9') {
              const views = ['comfort', 'compare', 'floor', 'ambient', 'timeline', 'classic', 'lights', '3d', 'config'];
              this.setView(views[parseInt(e.key) - 1]);
            }
          });
        },

        setView(view) {
          this.currentView = view;
          localStorage.setItem('dashboard-view', view);
        },

        updateDateTime() {
          const now = new Date();
          this.currentDateTime = now.toLocaleDateString('en-AU', {
            weekday: 'short', month: 'short', day: 'numeric',
            hour: 'numeric', minute: '2-digit', hour12: true
          });
        }
      };
    }

    // ========================================
    // COMFORT SCORE VIEW (Vision 1)
    // ========================================
    function comfortScoreView() {
      return {
        homeScore: 0,
        roomScores: [],
        suggestions: [],
        showBreakdown: false,

        init() {
          this.updateScores();
          this.$watch('$store.rooms.list', () => this.updateScores());
        },

        updateScores() {
          const rooms = this.$store.rooms.list;

          this.roomScores = rooms
            .filter(r => r.temperature !== null && r.humidity !== null)
            .map(room => ({
              ...room,
              score: this.calculateComfort(room.temperature, room.humidity)
            }))
            .sort((a, b) => b.score - a.score);

          this.homeScore = this.calculateHomeScore(rooms);
          this.suggestions = this.generateSuggestions(rooms).slice(0, 2);
        },

        calculateComfort(temp, humidity) {
          if (temp === null || humidity === null) return 0;
          let tempScore = 70;
          if (temp < 20) tempScore = Math.max(0, 70 - (20 - temp) * 10);
          else if (temp > 26) tempScore = Math.max(0, 70 - (temp - 26) * 10);
          else tempScore = 70 - Math.abs(temp - 23) * 2;

          let humidScore = 30;
          if (humidity < 40) humidScore = Math.max(0, 30 - (40 - humidity));
          else if (humidity > 60) humidScore = Math.max(0, 30 - (humidity - 60) * 1.5);
          else humidScore = 30 - Math.abs(humidity - 50) * 0.3;

          return Math.round(Math.max(0, Math.min(100, tempScore + humidScore)));
        },

        calculateHomeScore(rooms) {
          const weights = { 'Living Room': 1.5, 'Bedroom': 1.3, 'Study': 1.0, 'Kitchen': 0.8, 'Bathroom': 0.5 };
          const valid = rooms.filter(r => r.temperature !== null);
          if (valid.length === 0) return 0;

          let sum = 0, total = 0;
          valid.forEach(r => {
            const w = weights[r.name] || 1;
            sum += this.calculateComfort(r.temperature, r.humidity) * w;
            total += w;
          });
          return Math.round(sum / total);
        },

        generateSuggestions(rooms) {
          const valid = rooms.filter(r => r.temperature !== null && r.humidity !== null);
          if (valid.length === 0) return [];

          const suggestions = [];
          const hottest = valid.reduce((a, b) => a.temperature > b.temperature ? a : b);
          const mostHumid = valid.reduce((a, b) => a.humidity > b.humidity ? a : b);

          if (mostHumid.humidity > 65) {
            suggestions.push({ type: 'action', icon: 'üí®', title: 'Improve ventilation',
              message: `${mostHumid.name} humidity is high (${mostHumid.humidity}%)` });
          }
          if (hottest.temperature > 28) {
            const coldest = valid.reduce((a, b) => a.temperature < b.temperature ? a : b);
            suggestions.push({ type: 'tip', icon: 'üèÉ', title: 'Go to cooler room',
              message: `${coldest.name} is ${(hottest.temperature - coldest.temperature).toFixed(1)}¬∞ cooler` });
          }
          return suggestions;
        },

        getLabel() {
          if (this.homeScore >= 90) return 'Perfect';
          if (this.homeScore >= 75) return 'Comfortable';
          if (this.homeScore >= 60) return 'Okay';
          if (this.homeScore >= 40) return 'Uncomfortable';
          return 'Poor';
        },

        getColor() {
          if (this.homeScore >= 90) return '#34C759';
          if (this.homeScore >= 75) return '#30D158';
          if (this.homeScore >= 60) return '#FFD60A';
          if (this.homeScore >= 40) return '#FF9500';
          return '#FF3B30';
        },

        getRoomColor(score) {
          if (score >= 75) return 'var(--color-success)';
          if (score >= 50) return 'var(--color-warning)';
          return 'var(--color-danger)';
        },

        getScoreArc() {
          const percent = this.homeScore / 100;
          const circumference = 2 * Math.PI * 90;
          return `${percent * circumference} ${circumference}`;
        },

        openRoom(room) { this.$store.roomDetail.open(room); }
      };
    }

    // ========================================
    // BAR COMPARE VIEW (Vision 2)
    // ========================================
    function barCompareView() {
      return {
        sortBy: 'temperature',
        sortDirection: 'desc',
        viewMode: 'both',
        insights: [],
        tempScale: { min: 18, max: 32 },
        humidityScale: { min: 0, max: 100 },
        comfortZone: { temp: { min: 22, max: 26 }, humidity: { min: 40, max: 60 } },

        init() {
          const saved = localStorage.getItem('bar-sort');
          if (saved) this.sortBy = saved;
          const savedView = localStorage.getItem('bar-view');
          if (savedView) this.viewMode = savedView;
          this.updateInsights();
          this.$watch('$store.rooms.list', () => this.updateInsights());
        },

        get rooms() { return this.$store.rooms.list.filter(r => r.temperature !== null); },

        get sortedRooms() {
          return [...this.rooms].sort((a, b) => {
            let cmp = 0;
            if (this.sortBy === 'temperature') cmp = a.temperature - b.temperature;
            else if (this.sortBy === 'humidity') cmp = a.humidity - b.humidity;
            else if (this.sortBy === 'name') cmp = a.name.localeCompare(b.name);
            return this.sortDirection === 'desc' ? -cmp : cmp;
          });
        },

        updateInsights() {
          const rooms = this.rooms;
          if (rooms.length === 0) { this.insights = []; return; }

          const insights = [];
          const temps = rooms.map(r => r.temperature);
          const spread = Math.max(...temps) - Math.min(...temps);

          if (spread >= 2) {
            const hottest = rooms.find(r => r.temperature === Math.max(...temps));
            const coldest = rooms.find(r => r.temperature === Math.min(...temps));
            insights.push({ type: spread > 4 ? 'warning' : 'info', icon: 'üî∫', title: 'TEMPERATURE GAP',
              message: `${hottest.name} is ${spread.toFixed(1)}¬∞ warmer than ${coldest.name}` });
          }

          rooms.forEach(r => {
            if (r.humidity > 70) {
              insights.push({ type: 'alert', icon: 'üíß', title: 'HIGH HUMIDITY',
                message: `${r.name} at ${r.humidity}% ‚Äî risk of mold` });
            }
          });

          const comfortable = rooms.filter(r => r.temperature >= 22 && r.temperature <= 26 && r.humidity >= 40 && r.humidity <= 60);
          if (comfortable.length > 0) {
            insights.push({ type: 'success', icon: '‚úì', title: 'COMFORT ZONES',
              message: `${comfortable.map(r => r.name).join(', ')} ${comfortable.length === 1 ? 'is' : 'are'} comfortable` });
          }

          this.insights = insights.slice(0, 4);
        },

        setViewMode(mode) { this.viewMode = mode; localStorage.setItem('bar-view', mode); },

        getBarWidth(value, type) {
          const scale = type === 'temperature' ? this.tempScale : this.humidityScale;
          return Math.max(0, Math.min(100, ((value - scale.min) / (scale.max - scale.min)) * 100));
        },

        getBarColor(value, type) {
          const zone = type === 'temperature' ? this.comfortZone.temp : this.comfortZone.humidity;
          if (type === 'temperature') {
            if (value < zone.min) return 'var(--color-cold)';
            if (value > zone.max) return 'var(--color-hot)';
            return 'var(--color-comfortable)';
          } else {
            if (value < zone.min) return 'var(--color-warning)';
            if (value > zone.max) return 'var(--color-info)';
            return 'var(--color-comfortable)';
          }
        },

        getComfortZoneStyle(type) {
          const scale = type === 'temperature' ? this.tempScale : this.humidityScale;
          const zone = type === 'temperature' ? this.comfortZone.temp : this.comfortZone.humidity;
          const left = ((zone.min - scale.min) / (scale.max - scale.min)) * 100;
          const width = ((zone.max - zone.min) / (scale.max - scale.min)) * 100;
          return { left: left + '%', width: width + '%' };
        },

        getScaleLabels(type) {
          const scale = type === 'temperature' ? this.tempScale : this.humidityScale;
          const unit = type === 'temperature' ? '¬∞' : '%';
          return [scale.min + unit, ((scale.min + scale.max) / 2) + unit, scale.max + unit];
        },

        getInsightClass(type) {
          return { success: 'insight-success', warning: 'insight-warning', alert: 'insight-alert', info: 'insight-info' }[type] || 'insight-info';
        },

        openRoom(room) { this.$store.roomDetail.open(room); }
      };
    }

    // ========================================
    // FLOOR PLAN VIEW (Vision 3)
    // ========================================
    function floorPlanView() {
      return {
        viewType: 'temperature',
        // Layout based on actual floor plan measurements
        // Scale: ~55px per meter for good visualization
        layout: {
          width: 620, height: 470,
          rooms: [
            // Top row: Living Room (left with balcony) + Bedroom (right with main door)
            { id: 'living', x: 70, y: 20, width: 260, height: 200 },      // 4.75m √ó 3.968m
            { id: 'bedroom', x: 340, y: 20, width: 250, height: 200 },    // 4.489m √ó 3.378m
            // Bottom row: Study (left) + Kitchen/Bathroom (right), Hallway in center
            { id: 'study', x: 20, y: 235, width: 216, height: 220 },      // 3.908m √ó 3.697m (20% reduced)
            { id: 'kitchen', x: 430, y: 235, width: 175, height: 115 },   // 3.203m √ó 2.138m
            { id: 'bathroom', x: 430, y: 355, width: 175, height: 95 }    // 3.15m √ó 1.424m
          ]
        },
        tempColors: [
          { value: 18, color: '#90CAF9' }, { value: 22, color: '#A5D6A7' },
          { value: 24, color: '#81C784' }, { value: 26, color: '#FFE082' },
          { value: 28, color: '#FFAB91' }, { value: 32, color: '#EF5350' }
        ],
        humidityColors: [
          { value: 30, color: '#FFCC80' }, { value: 40, color: '#A5D6A7' },
          { value: 50, color: '#81C784' }, { value: 60, color: '#A5D6A7' },
          { value: 70, color: '#90CAF9' }, { value: 85, color: '#5C6BC0' }
        ],

        get rooms() {
          const roomsList = this.$store.rooms.list;
          return this.layout.rooms.map(lr => {
            const dr = roomsList.find(r => r.id === lr.id);
            return { ...lr, ...dr, color: this.getRoomColor(dr) };
          });
        },

        setViewType(type) { this.viewType = type; },

        getRoomColor(room) {
          if (!room || room.temperature === null) return '#E0E0E0';
          const value = this.viewType === 'temperature' ? room.temperature : room.humidity;
          const scale = this.viewType === 'temperature' ? this.tempColors : this.humidityColors;
          return this.interpolateColor(value, scale);
        },

        interpolateColor(value, scale) {
          if (value < scale[0].value) return scale[0].color;
          if (value > scale[scale.length - 1].value) return scale[scale.length - 1].color;

          let lower = scale[0], upper = scale[scale.length - 1];
          for (let i = 0; i < scale.length - 1; i++) {
            if (value >= scale[i].value && value <= scale[i + 1].value) {
              lower = scale[i]; upper = scale[i + 1]; break;
            }
          }

          const factor = (value - lower.value) / (upper.value - lower.value);
          const lRGB = this.hexToRgb(lower.color), uRGB = this.hexToRgb(upper.color);
          const r = Math.round(lRGB.r + factor * (uRGB.r - lRGB.r));
          const g = Math.round(lRGB.g + factor * (uRGB.g - lRGB.g));
          const b = Math.round(lRGB.b + factor * (uRGB.b - lRGB.b));
          return `rgb(${r},${g},${b})`;
        },

        hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 200, g: 200, b: 200 };
        },

        getLegendItems() {
          return this.viewType === 'temperature'
            ? [{ label: '< 20¬∞', color: '#90CAF9' }, { label: '20-24¬∞', color: '#81C784' }, { label: '24-28¬∞', color: '#FFE082' }, { label: '> 28¬∞', color: '#EF5350' }]
            : [{ label: '< 40%', color: '#FFCC80' }, { label: '40-60%', color: '#81C784' }, { label: '60-70%', color: '#90CAF9' }, { label: '> 70%', color: '#5C6BC0' }];
        },

        getValue(room) {
          if (!room) return '--';
          return this.viewType === 'temperature'
            ? (room.temperature !== null ? room.temperature.toFixed(1) + '¬∞' : '--')
            : (room.humidity !== null ? room.humidity.toFixed(0) + '%' : '--');
        },

        openRoom(room) { this.$store.roomDetail.open(room); }
      };
    }

    // ========================================
    // AMBIENT VIEW (Vision 4)
    // ========================================
    function ambientView() {
      return {
        currentRoomIndex: 0,
        isDarkMode: false,
        autoRotate: false,
        showDetails: false,
        detailsTimeout: null,
        touchStartX: 0,

        init() {
          const hour = new Date().getHours();
          this.isDarkMode = hour >= 22 || hour < 6;

          this.$el.addEventListener('touchstart', (e) => { this.touchStartX = e.touches[0].clientX; }, { passive: true });
          this.$el.addEventListener('touchend', (e) => {
            const deltaX = e.changedTouches[0].clientX - this.touchStartX;
            if (Math.abs(deltaX) > 50) deltaX > 0 ? this.previousRoom() : this.nextRoom();
          }, { passive: true });

          let lastTap = 0;
          this.$el.addEventListener('touchend', () => {
            const now = Date.now();
            if (now - lastTap < 300) this.isDarkMode = !this.isDarkMode;
            lastTap = now;
          }, { passive: true });
        },

        get rooms() { return this.$store.rooms.list.filter(r => r.temperature !== null); },

        get currentRoom() {
          return this.rooms.length > 0 ? this.rooms[this.currentRoomIndex % this.rooms.length]
            : { name: 'Loading...', temperature: 0, humidity: 0, icon: 'üè†' };
        },

        nextRoom() { this.currentRoomIndex = (this.currentRoomIndex + 1) % this.rooms.length; },
        previousRoom() { this.currentRoomIndex = (this.currentRoomIndex - 1 + this.rooms.length) % this.rooms.length; },
        selectRoom(index) { this.currentRoomIndex = index; },

        showDetailsOverlay() {
          this.showDetails = true;
          if (this.detailsTimeout) clearTimeout(this.detailsTimeout);
          this.detailsTimeout = setTimeout(() => { this.showDetails = false; }, 5000);
        },

        getBackgroundColor() {
          if (this.isDarkMode) return '#000000';
          const temp = this.currentRoom.temperature;
          if (temp < 20) return '#E3F2FD';
          if (temp < 23) return '#E8F5E9';
          if (temp < 26) return '#FFFFFF';
          if (temp < 28) return '#FFF8E1';
          return '#FFEBEE';
        },

        getMinMaxToday() {
          const room = this.currentRoom;
          if (!room.tempHistory || room.tempHistory.length === 0) return '--';
          const today = new Date(); today.setHours(0, 0, 0, 0);
          const todayHistory = room.tempHistory.filter(h => h.time >= today.getTime());
          if (todayHistory.length === 0) return '--';
          const temps = todayHistory.map(h => h.value);
          return `${Math.min(...temps).toFixed(1)}¬∞ / ${Math.max(...temps).toFixed(1)}¬∞`;
        },

        getTrend() {
          const room = this.currentRoom;
          if (!room.tempHistory || room.tempHistory.length < 2) return '‚Üí';
          const recent = room.tempHistory.slice(-10);
          const diff = recent[recent.length - 1].value - recent[0].value;
          if (diff > 0.5) return '‚Üë';
          if (diff < -0.5) return '‚Üì';
          return '‚Üí';
        },

        formatLastUpdate() {
          if (!this.currentRoom.lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - this.currentRoom.lastSeen) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      };
    }

    // ========================================
    // TIMELINE VIEW (Vision 5)
    // ========================================
    function timelineView() {
      return {
        events: [],
        selectedDate: 'today',
        loading: false,

        init() {
          this.loadEvents();
          this.$watch('$store.rooms.list', () => this.loadEvents());
        },

        loadEvents() {
          this.loading = true;
          const rooms = this.$store.rooms.list;
          const allEvents = [];

          const now = Date.now();
          let startTime;
          if (this.selectedDate === 'yesterday') {
            const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); yesterday.setHours(0, 0, 0, 0);
            startTime = yesterday.getTime();
          } else if (this.selectedDate === 'week') {
            startTime = now - 7 * 24 * 60 * 60 * 1000;
          } else {
            const today = new Date(); today.setHours(0, 0, 0, 0);
            startTime = today.getTime();
          }

          rooms.forEach(room => {
            if (room.tempHistory && room.tempHistory.length > 0) {
              const filtered = room.tempHistory.filter(h => h.time >= startTime);
              allEvents.push(...this.detectEvents(filtered, room.name, room.icon));
            }
          });

          this.events = allEvents.sort((a, b) => b.time - a.time).slice(0, 20);
          this.loading = false;
        },

        detectEvents(history, roomName, roomIcon) {
          if (history.length < 10) return [];
          const events = [];
          const sorted = [...history].sort((a, b) => a.time - b.time);

          // Detect rapid changes
          for (let i = 0; i < sorted.length - 1; i++) {
            const windowMs = 30 * 60 * 1000;
            const start = sorted[i];
            const endIdx = sorted.findIndex(p => p.time >= start.time + windowMs && p.time <= start.time + windowMs * 1.2);
            if (endIdx === -1) continue;

            const end = sorted[endIdx];
            const delta = end.value - start.value;

            if (Math.abs(delta) >= 3) {
              events.push({
                type: delta > 0 ? 'RAPID_RISE' : 'RAPID_DROP',
                time: start.time, room: roomName, icon: roomIcon,
                value: start.value, endValue: end.value, delta: Math.abs(delta),
                duration: Math.round((end.time - start.time) / 60000),
                eventIcon: delta > 0 ? 'üî•' : '‚ùÑÔ∏è',
                title: `${roomName} ${delta > 0 ? 'rose' : 'dropped'} ${Math.abs(delta).toFixed(1)}¬∞ in ${Math.round((end.time - start.time) / 60000)} mins`,
                cause: this.inferCause(delta > 0 ? 'RAPID_RISE' : 'RAPID_DROP', roomName, start.time)
              });
            }
          }

          // Detect peaks
          const windowSize = 6;
          for (let i = windowSize; i < sorted.length - windowSize; i++) {
            const point = sorted[i];
            const before = sorted.slice(i - windowSize, i);
            const after = sorted.slice(i + 1, i + windowSize + 1);
            const maxBefore = Math.max(...before.map(p => p.value));
            const maxAfter = Math.max(...after.map(p => p.value));

            if (point.value > maxBefore && point.value > maxAfter && point.value - Math.min(maxBefore, maxAfter) >= 2) {
              events.push({
                type: 'PEAK', time: point.time, room: roomName, icon: roomIcon,
                value: point.value, eventIcon: 'üìà',
                title: `${roomName} peaked at ${point.value.toFixed(1)}¬∞`,
                cause: this.inferCause('PEAK', roomName, point.time)
              });
            }
          }

          return events;
        },

        inferCause(type, roomName, time) {
          const hour = new Date(time).getHours();
          const room = roomName.toLowerCase();

          if (room.includes('bathroom') && type === 'PEAK' && hour >= 6 && hour <= 9)
            return { text: 'Morning shower' };
          if (room.includes('kitchen') && type === 'RAPID_RISE' && hour >= 18 && hour <= 21)
            return { text: 'Cooking dinner' };
          if (type === 'RAPID_RISE' && hour >= 10 && hour <= 15)
            return { text: 'Sun exposure' };
          return null;
        },

        setDate(date) { this.selectedDate = date; this.loadEvents(); },

        formatTime(timestamp) {
          return new Date(timestamp).toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
        },

        getEventClass(type) {
          return { 'PEAK': 'event-peak', 'VALLEY': 'event-valley', 'RAPID_RISE': 'event-rise', 'RAPID_DROP': 'event-drop' }[type] || '';
        },

        getTodaySummary() {
          const rooms = this.$store.rooms.list.filter(r => r.tempHistory && r.tempHistory.length > 0);
          if (rooms.length === 0) return null;

          const today = new Date(); today.setHours(0, 0, 0, 0);
          let allTemps = [], mostStable = null, minVar = Infinity, mostVolatile = null, maxVar = 0;

          rooms.forEach(room => {
            const todayHistory = room.tempHistory.filter(h => h.time >= today.getTime());
            if (todayHistory.length < 2) return;
            const temps = todayHistory.map(h => h.value);
            allTemps.push(...temps);
            const variation = Math.max(...temps) - Math.min(...temps);
            if (variation < minVar) { minVar = variation; mostStable = room.name; }
            if (variation > maxVar) { maxVar = variation; mostVolatile = room.name; }
          });

          if (allTemps.length === 0) return null;
          return {
            minTemp: Math.min(...allTemps).toFixed(1),
            maxTemp: Math.max(...allTemps).toFixed(1),
            mostStable, mostVolatile,
            eventCount: this.events.length
          };
        },

        openRoom(roomName) {
          const room = this.$store.rooms.list.find(r => r.name === roomName);
          if (room) this.$store.roomDetail.open(room);
        }
      };
    }

    // ========================================
    // VISION 6: CLASSIC CARDS VIEW
    // ========================================
    function classicView() {
      return {
        sparklineUpdateInterval: null,

        get rooms() {
          return this.$store.rooms.list;
        },

        get avgTemperature() {
          return this.$store.rooms.avgTemperature;
        },

        get avgHumidity() {
          return this.$store.rooms.avgHumidity;
        },

        init() {
          // Initial sparkline render
          this.$nextTick(() => this.updateSparklines());

          // Update sparklines every 5 seconds
          this.sparklineUpdateInterval = setInterval(() => this.updateSparklines(), 5000);

          // Watch for room changes
          this.$watch('$store.rooms.list', () => {
            this.$nextTick(() => this.updateSparklines());
          });
        },

        destroy() {
          if (this.sparklineUpdateInterval) {
            clearInterval(this.sparklineUpdateInterval);
          }
        },

        isStale(room) {
          if (!room.lastSeen) return true;
          return Date.now() - room.lastSeen > 5 * 60 * 1000;
        },

        getComfortClass(temp) {
          if (temp === null || temp === undefined) return '';
          if (temp < 20) return 'cold';
          if (temp < 23) return 'cool';
          if (temp <= 26) return 'good';
          if (temp <= 28) return 'warm';
          return 'hot';
        },

        formatUpdate(lastSeen) {
          if (!lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - lastSeen) / 1000);
          if (seconds < 5) return 'Just now';
          if (seconds < 60) return `${seconds}s ago`;
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return `${minutes}m ago`;
          const hours = Math.floor(minutes / 60);
          return `${hours}h ${minutes % 60}m ago`;
        },

        openRoom(room) {
          this.$store.roomDetail.open(room);
        },

        updateSparklines() {
          // Update room sparklines
          this.rooms.forEach(room => {
            const svg = document.getElementById(`classic-spark-${room.id}`);
            if (svg && room.tempHistory && room.tempHistory.length > 1) {
              this.drawSparkline(svg, room.tempHistory.slice(-50));
            }
          });

          // Update average sparkline
          const avgSvg = document.getElementById('classic-spark-avg');
          const avgHistory = this.$store.rooms.avgHistory;
          if (avgSvg && avgHistory && avgHistory.length > 1) {
            this.drawSparkline(avgSvg, avgHistory.slice(-50), true);
          }
        },

        drawSparkline(svg, data, isDark = false) {
          const width = svg.clientWidth || 200;
          const height = svg.clientHeight || 40;

          if (data.length < 2 || width === 0) return;

          const values = data.map(d => d.value);
          const min = Math.min(...values);
          const max = Math.max(...values);
          const range = max - min || 1;

          const points = data.map((d, i) => {
            const x = (i / (data.length - 1)) * width;
            const y = height - ((d.value - min) / range) * (height - 4) - 2;
            return `${x},${y}`;
          }).join(' ');

          const lineColor = isDark ? 'rgba(255,255,255,0.8)' : 'var(--color-primary)';
          const areaColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0, 122, 255, 0.1)';

          svg.innerHTML = `
            <polyline
              points="${points}"
              fill="none"
              stroke="${lineColor}"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <polygon
              points="0,${height} ${points} ${width},${height}"
              fill="${areaColor}"
            />
          `;
        }
      };
    }

    // ========================================
    // VISION 7: LIGHTS CONTROL VIEW
    // ========================================
    function lightsView() {
      return {
        // Helper function for color temperature label
        getColorTempLabel(colorTemp) {
          if (colorTemp <= 280) return 'Cool White';
          if (colorTemp <= 350) return 'Neutral';
          if (colorTemp <= 400) return 'Warm White';
          return 'Warm';
        },

        // Helper function for last update formatting
        formatLastUpdate(timestamp) {
          if (!timestamp) return 'No data';
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      };
    }

    // ========================================
    // VISION 8: 3D FLOOR PLAN VIEW
    // ========================================

    // Store Three.js objects OUTSIDE Alpine to avoid proxy conflicts
    const threeState = {
      scene: null,
      camera: null,
      renderer: null,
      controls: null,
      roomMeshes: {},
      wallMeshes: [],
      labelElements: {},
      animationId: null,
      isInitialized: false
    };

    // Isometric view state (separate from 3D view)
    const isoState = {
      scene: null,
      camera: null,
      renderer: null,
      roomMeshes: {},
      wallMeshes: [],
      labelElements: {},
      animationId: null,
      isInitialized: false,
      panOffset: { x: 0, z: 0 },
      isPanning: false,
      lastPanPos: { x: 0, y: 0 }
    };

    // Floor plan configuration - exact dimensions from floor map
    const FLOOR_PLAN_CONFIG = {
      apartmentWidth: 9.239,
      apartmentDepth: 7.665,
      wallHeight: 2.0,
      wallThickness: 0.15,
      // Room positions are center coordinates (mirrored layout)
      rooms: [
        { id: 'study', name: 'Study', icon: 'üìö', x: 7.285, z: 1.8485, width: 3.908, depth: 3.697, color: 0x60a5fa, labelY: 3 },
        { id: 'living', name: 'Living Room', icon: 'üõãÔ∏è', x: 6.864, z: 5.681, width: 4.750, depth: 3.968, color: 0x34d399, labelY: 3 },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', x: 2.2445, z: 5.976, width: 4.489, depth: 3.378, color: 0xfbbf24, labelY: 4 },
        { id: 'kitchen', name: 'Kitchen', icon: 'üç≥', x: 1.6655, z: 3.218, width: 3.331, depth: 2.138, color: 0xf87171, labelY: 3 },
        { id: 'bathroom', name: 'Bathroom', icon: 'üöø', x: 1.6985, z: 1.0745, width: 3.397, depth: 2.149, color: 0xa78bfa, labelY: 2 }
      ],
      balcony: { x: 9.764, z: 7.065, width: 1.050, depth: 1.200, color: 0x93c5fd },
      hallway: { x: 3.839, z: 2.0, width: 1.5, depth: 2.5, color: 0x94a3b8 },
      doors: [
        { x: 9.239, z: 6.465, rotation: Math.PI/2, type: 'french', swingDirection: 'inward' },  // Balcony ‚Üî Living (double glass French doors at east wall)
        { x: 3.706, z: 3.697, rotation: 0, swingDirection: 'south' },           // Living ‚Üî Hallway
        { x: 4.354, z: 1.848, rotation: Math.PI/2, swingDirection: 'east' },    // Study ‚Üî Hallway
        { x: 3.134, z: 3.697, rotation: 0, swingDirection: 'south' },           // Bedroom ‚Üî Hallway
        { x: 3.331, z: 2.818, rotation: Math.PI/2, swingDirection: 'east' },    // Hallway ‚Üî Kitchen
        { x: 3.331, z: 1.338, rotation: Math.PI/2, swingDirection: 'east' },    // Hallway ‚Üî Bathroom
        { x: 0, z: 4.8, rotation: Math.PI/2, type: 'entry', swingDirection: 'east' }  // Main entry door (west wall in mirrored layout)
      ],
      windows: [
        { x: 9.239, z: 1.848, rotation: Math.PI/2, size: 2.5 },   // Study right (mirrored)
        { x: 9.239, z: 5.681, rotation: Math.PI/2, size: 2.5 },   // Living right (mirrored)
        { x: 0, z: 5.976, rotation: Math.PI/2, size: 2.5 },       // Bedroom left (mirrored)
        { x: 0, z: 3.218, rotation: Math.PI/2, size: 1.8 },       // Kitchen left (mirrored)
        { x: 0, z: 1.487, rotation: Math.PI/2, size: 1.2 }        // Bathroom left (mirrored)
      ],
      furniture: [
        { type: 'bed', room: 'bedroom', width: 1.8, depth: 2.0, height: 0.6 }
      ]
    };

    // Calculate center for positioning
    const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
    const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

    // Color scales
    const TEMP_COLORS = [
      { value: 18, color: 0x90CAF9 },
      { value: 22, color: 0xA5D6A7 },
      { value: 24, color: 0x81C784 },
      { value: 26, color: 0xFFE082 },
      { value: 28, color: 0xFFAB91 },
      { value: 32, color: 0xEF5350 }
    ];

    const HUMIDITY_COLORS = [
      { value: 30, color: 0xFFCC80 },
      { value: 40, color: 0xA5D6A7 },
      { value: 50, color: 0x81C784 },
      { value: 60, color: 0xA5D6A7 },
      { value: 70, color: 0x90CAF9 },
      { value: 85, color: 0x5C6BC0 }
    ];

    function threeDView() {
      return {
        // Reactive state for UI
        viewMode: 'temperature',
        viewMode3D: 'top',
        wallsVisible: true,
        autoRotate: false,
        darkTheme: false,

        init() {
          // Wait for container to become visible and have dimensions
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.threeContainer;

          // If container doesn't exist or has no dimensions, retry
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          // If already initialized, ensure canvas is in container and resize
          if (threeState.isInitialized && threeState.renderer) {
            // Re-attach canvas if it's not in the container
            if (!container.contains(threeState.renderer.domElement)) {
              container.appendChild(threeState.renderer.domElement);
            }
            this.createLabels(container);  // Recreate labels
            this.onResize();
            return;
          }

          // Clean up any existing Three.js objects
          if (threeState.renderer) {
            threeState.renderer.dispose();
          }
          if (threeState.scene) {
            threeState.scene.clear();
          }
          if (threeState.animationId) {
            cancelAnimationFrame(threeState.animationId);
          }

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.createLabels(container);
          this.animate();
          threeState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          threeState.scene = new THREE.Scene();
          threeState.scene.background = new THREE.Color(0xE8E8EA);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;

          // Use PerspectiveCamera for 3D viewing
          threeState.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
          // Default to top view - zoomed to fill screen, rotated 180¬∞ (scene is centered at 0,0,0)
          threeState.camera.position.set(0, 14, -0.1);
          threeState.camera.lookAt(0, 0, 0);

          // Add OrbitControls for interactive camera
          threeState.controls = new THREE.OrbitControls(threeState.camera, container);
          threeState.controls.enableDamping = true;
          threeState.controls.dampingFactor = 0.05;
          threeState.controls.maxPolarAngle = Math.PI / 2.1;  // Prevent camera below floor
          threeState.controls.minDistance = 5;
          threeState.controls.maxDistance = 40;
          threeState.controls.target.set(0, 0, 0);
          threeState.controls.update();
        },

        initRenderer(container) {
          threeState.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
          });
          threeState.renderer.setSize(container.clientWidth, container.clientHeight);
          threeState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          threeState.renderer.shadowMap.enabled = true;
          threeState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(threeState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.6);
          threeState.scene.add(ambient);

          const directional = new THREE.DirectionalLight(0xffffff, 0.8);
          directional.position.set(15, 20, 15);
          directional.castShadow = true;
          directional.shadow.mapSize.width = 1024;
          directional.shadow.mapSize.height = 1024;
          directional.shadow.camera.near = 0.5;
          directional.shadow.camera.far = 50;
          directional.shadow.camera.left = -15;
          directional.shadow.camera.right = 15;
          directional.shadow.camera.top = 15;
          directional.shadow.camera.bottom = -15;
          threeState.scene.add(directional);

          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          threeState.scene.add(fill);
        },

        buildFloorPlan() {
          // Clear wall meshes array for fresh build
          threeState.wallMeshes = [];

          // Base floor - uses apartment dimensions, centered at origin
          const apW = FLOOR_PLAN_CONFIG.apartmentWidth;
          const apD = FLOOR_PLAN_CONFIG.apartmentDepth;
          const floorGeometry = new THREE.PlaneGeometry(apW + 2, apD + 2);
          const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xC0C0C2,
            roughness: 0.8
          });
          const floor = new THREE.Mesh(floorGeometry, floorMaterial);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(0, -0.01, 0);
          floor.receiveShadow = true;
          threeState.scene.add(floor);

          // Build each room
          FLOOR_PLAN_CONFIG.rooms.forEach(roomConfig => {
            const roomGroup = this.createRoom(roomConfig);
            threeState.roomMeshes[roomConfig.id] = roomGroup;
            threeState.scene.add(roomGroup);
          });

          // Hallway floor (centered coordinates)
          const hw = FLOOR_PLAN_CONFIG.hallway;
          const hallwayGeometry = new THREE.PlaneGeometry(hw.width, hw.depth);
          const hallwayMaterial = new THREE.MeshStandardMaterial({
            color: 0xD0D0D0,
            roughness: 0.7
          });
          const hallway = new THREE.Mesh(hallwayGeometry, hallwayMaterial);
          hallway.rotation.x = -Math.PI / 2;
          hallway.position.set(hw.x - centerX, 0.005, hw.z - centerZ);
          hallway.receiveShadow = true;
          threeState.scene.add(hallway);

          // Balcony floor
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const balconyGeometry = new THREE.PlaneGeometry(bal.width, bal.depth);
          const balconyMaterial = new THREE.MeshStandardMaterial({
            color: 0x93c5fd,
            roughness: 0.5
          });
          const balcony = new THREE.Mesh(balconyGeometry, balconyMaterial);
          balcony.rotation.x = -Math.PI / 2;
          balcony.position.set(bal.x - centerX, 0.003, bal.z - centerZ);
          balcony.receiveShadow = true;
          threeState.scene.add(balcony);

          // Add doors
          FLOOR_PLAN_CONFIG.doors.forEach(door => this.createDoor(door));

          // Add windows
          FLOOR_PLAN_CONFIG.windows.forEach(win => this.createWindow(win));

          // Add balcony railing
          this.createBalconyRailing();

          // Add furniture
          this.createFurniture();
        },

        createRoom(config) {
          const group = new THREE.Group();
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;

          // Room floor - colored transparent box matching room color
          const floorGeometry = new THREE.BoxGeometry(config.width, 0.05, config.depth);
          const floorMaterial = new THREE.MeshStandardMaterial({
            color: config.color,
            transparent: true,
            opacity: 0.3,
            roughness: 0.6,
            metalness: 0.1
          });
          const roomFloor = new THREE.Mesh(floorGeometry, floorMaterial);
          roomFloor.position.set(config.x - centerX, 0.025, config.z - centerZ);
          roomFloor.receiveShadow = true;
          roomFloor.name = 'floor_' + config.id;
          group.add(roomFloor);

          // Glassy wall material - semi-transparent for elegant look
          const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.25,
            metalness: 0.4,
            roughness: 0.08,
            side: THREE.DoubleSide
          });

          // Calculate room boundaries
          const halfW = config.width / 2;
          const halfD = config.depth / 2;
          const rx = config.x - centerX;  // room center X (relative)
          const rz = config.z - centerZ;  // room center Z (relative)

          // Back wall (north)
          const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(config.width, wallHeight, 0.15),
            wallMaterial
          );
          backWall.position.set(rx, wallHeight/2, rz - halfD);
          backWall.castShadow = true;
          group.add(backWall);
          threeState.wallMeshes.push(backWall);

          // Front wall (south) - full height for immersive 3D
          const frontWall = new THREE.Mesh(
            new THREE.BoxGeometry(config.width, wallHeight, 0.15),
            wallMaterial
          );
          frontWall.position.set(rx, wallHeight/2, rz + halfD);
          frontWall.castShadow = true;
          group.add(frontWall);
          threeState.wallMeshes.push(frontWall);

          // Left wall (west)
          const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, wallHeight, config.depth),
            wallMaterial
          );
          leftWall.position.set(rx - halfW, wallHeight/2, rz);
          leftWall.castShadow = true;
          group.add(leftWall);
          threeState.wallMeshes.push(leftWall);

          // Right wall (east)
          const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, wallHeight, config.depth),
            wallMaterial
          );
          rightWall.position.set(rx + halfW, wallHeight/2, rz);
          rightWall.castShadow = true;
          group.add(rightWall);
          threeState.wallMeshes.push(rightWall);

          return group;
        },

        // Create door with handle and swing arc
        createDoor(doorConfig) {
          const doorWidth = 0.9;
          const doorHeight = FLOOR_PLAN_CONFIG.wallHeight * 0.85;
          const posX = doorConfig.x - centerX;
          const posZ = doorConfig.z - centerZ;

          // Check door type
          if (doorConfig.type === 'french') {
            // French doors - double glass doors opening inward
            this.createFrenchDoor(doorConfig, posX, posZ, doorWidth, doorHeight);
            return;
          }

          // Standard door material (brown wood)
          const doorMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            roughness: 0.7,
            metalness: 0.1
          });

          const door = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth, doorHeight, 0.08),
            doorMaterial
          );
          door.position.set(posX, doorHeight / 2, posZ);
          door.rotation.y = doorConfig.rotation || 0;
          door.castShadow = true;
          threeState.scene.add(door);

          // Door handle
          const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.9,
            roughness: 0.2
          });
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.15, 16),
            handleMaterial
          );

          // Position handle based on door rotation
          const handleOffsetX = 0.3 * Math.cos(doorConfig.rotation || 0);
          const handleOffsetZ = 0.3 * Math.sin(doorConfig.rotation || 0);
          handle.position.set(
            posX + handleOffsetX,
            doorHeight * 0.45,
            posZ + handleOffsetZ
          );
          handle.rotation.z = Math.PI / 2;
          threeState.scene.add(handle);

          // Add swing arc on floor
          this.createSwingArc(doorConfig, posX, posZ, doorWidth);
        },

        // Create French doors (double glass doors)
        createFrenchDoor(doorConfig, posX, posZ, doorWidth, doorHeight) {
          const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB,
            transparent: true,
            opacity: 0.4,
            roughness: 0.1,
            metalness: 0.3
          });

          const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x2c3e50,
            roughness: 0.5,
            metalness: 0.2
          });

          // Total width for double doors
          const totalWidth = doorWidth * 2;
          const gap = 0.05;  // Small gap between doors

          // Left door panel
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth - gap/2, doorHeight, 0.06),
            glassMaterial
          );

          // Right door panel
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth - gap/2, doorHeight, 0.06),
            glassMaterial
          );

          // Position based on rotation
          const rot = doorConfig.rotation || 0;
          const offsetLeft = (doorWidth/2 + gap/4) * Math.cos(rot + Math.PI/2);
          const offsetLeftZ = (doorWidth/2 + gap/4) * Math.sin(rot + Math.PI/2);
          const offsetRight = (doorWidth/2 + gap/4) * Math.cos(rot - Math.PI/2);
          const offsetRightZ = (doorWidth/2 + gap/4) * Math.sin(rot - Math.PI/2);

          leftDoor.position.set(posX + offsetLeft, doorHeight/2, posZ + offsetLeftZ);
          leftDoor.rotation.y = rot;
          rightDoor.position.set(posX + offsetRight, doorHeight/2, posZ + offsetRightZ);
          rightDoor.rotation.y = rot;

          threeState.scene.add(leftDoor);
          threeState.scene.add(rightDoor);

          // Add door frames
          const frameThickness = 0.05;

          // Vertical frame divider in center
          const centerFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, doorHeight, 0.08),
            frameMaterial
          );
          centerFrame.position.set(posX, doorHeight/2, posZ);
          centerFrame.rotation.y = rot;
          threeState.scene.add(centerFrame);

          // Add TWO swing arcs (one for each door, opening inward)
          this.createSwingArc({ ...doorConfig, swingDirection: 'inward-left' }, posX + offsetLeft, posZ + offsetLeftZ, doorWidth);
          this.createSwingArc({ ...doorConfig, swingDirection: 'inward-right' }, posX + offsetRight, posZ + offsetRightZ, doorWidth);
        },

        // Create swing arc on floor showing door opening direction
        createSwingArc(doorConfig, posX, posZ, doorWidth) {
          const arcRadius = doorWidth;
          const arcSegments = 32;

          // Determine arc angles based on swing direction
          let startAngle, endAngle;
          const rot = doorConfig.rotation || 0;
          const swing = doorConfig.swingDirection || 'south';

          if (swing === 'inward-left') {
            startAngle = rot;
            endAngle = rot + Math.PI/2;
          } else if (swing === 'inward-right') {
            startAngle = rot - Math.PI/2;
            endAngle = rot;
          } else if (swing === 'south') {
            startAngle = rot;
            endAngle = rot + Math.PI/2;
          } else if (swing === 'north') {
            startAngle = rot + Math.PI/2;
            endAngle = rot + Math.PI;
          } else if (swing === 'east') {
            startAngle = rot - Math.PI/2;
            endAngle = rot;
          } else if (swing === 'west') {
            startAngle = rot + Math.PI;
            endAngle = rot + Math.PI * 1.5;
          } else {
            startAngle = rot;
            endAngle = rot + Math.PI/2;
          }

          // Create arc curve
          const curve = new THREE.EllipseCurve(
            0, 0,           // center
            arcRadius, arcRadius,  // xRadius, yRadius
            startAngle, endAngle,  // start and end angles
            false,          // clockwise
            0               // rotation
          );

          const points = curve.getPoints(arcSegments);
          const geometry = new THREE.BufferGeometry().setFromPoints(points);

          // Arc line material
          const arcMaterial = new THREE.LineBasicMaterial({
            color: 0x333333,
            transparent: true,
            opacity: 0.6
          });

          const arc = new THREE.Line(geometry, arcMaterial);
          arc.rotation.x = -Math.PI / 2;  // Lay flat on floor
          arc.position.set(posX, 0.02, posZ);  // Slightly above floor

          threeState.scene.add(arc);
        },

        // Create window with glass pane
        createWindow(winConfig) {
          const winWidth = winConfig.size || 2.0;
          const winHeight = 1.3;
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;

          // Window frame
          const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x2c3e50,
            roughness: 0.5,
            metalness: 0.2
          });
          const frame = new THREE.Mesh(
            new THREE.BoxGeometry(winWidth, winHeight, 0.15),
            frameMaterial
          );
          frame.position.set(
            winConfig.x - centerX,
            wallHeight * 0.55,
            winConfig.z - centerZ
          );
          frame.rotation.y = winConfig.rotation || 0;
          threeState.scene.add(frame);

          // Window glass
          const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB,
            metalness: 0.3,
            roughness: 0.1,
            transparent: true,
            opacity: 0.4
          });
          const glass = new THREE.Mesh(
            new THREE.BoxGeometry(winWidth * 0.9, winHeight * 0.85, 0.06),
            glassMaterial
          );
          glass.position.set(
            winConfig.x - centerX,
            wallHeight * 0.55,
            winConfig.z - centerZ
          );
          glass.rotation.y = winConfig.rotation || 0;
          threeState.scene.add(glass);
        },

        // Create balcony railing
        createBalconyRailing() {
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const railingHeight = 1.0;
          const railingMaterial = new THREE.MeshStandardMaterial({
            color: 0x374151,
            metalness: 0.7,
            roughness: 0.3
          });

          // Front railing (facing outward)
          const frontRailing = new THREE.Mesh(
            new THREE.BoxGeometry(bal.width, railingHeight, 0.05),
            railingMaterial
          );
          frontRailing.position.set(
            bal.x - centerX,
            railingHeight / 2,
            bal.z - centerZ + bal.depth / 2
          );
          threeState.scene.add(frontRailing);

          // Left railing
          const leftRailing = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, railingHeight, bal.depth),
            railingMaterial
          );
          leftRailing.position.set(
            bal.x - centerX - bal.width / 2,
            railingHeight / 2,
            bal.z - centerZ
          );
          threeState.scene.add(leftRailing);

          // Vertical posts (glass panel supports)
          const postMaterial = new THREE.MeshStandardMaterial({
            color: 0x374151,
            metalness: 0.8,
            roughness: 0.2
          });

          const postPositions = [
            { x: bal.x - bal.width / 2, z: bal.z + bal.depth / 2 },
            { x: bal.x + bal.width / 2, z: bal.z + bal.depth / 2 },
            { x: bal.x, z: bal.z + bal.depth / 2 }
          ];

          postPositions.forEach(pos => {
            const post = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, railingHeight, 8),
              postMaterial
            );
            post.position.set(
              pos.x - centerX,
              railingHeight / 2,
              pos.z - centerZ
            );
            threeState.scene.add(post);
          });

          // Glass panel for railing
          const glassRailing = new THREE.MeshStandardMaterial({
            color: 0xccf0ff,
            transparent: true,
            opacity: 0.3,
            metalness: 0.2,
            roughness: 0.1
          });
          const glassPanel = new THREE.Mesh(
            new THREE.BoxGeometry(bal.width, railingHeight * 0.7, 0.02),
            glassRailing
          );
          glassPanel.position.set(
            bal.x - centerX,
            railingHeight * 0.4,
            bal.z - centerZ + bal.depth / 2
          );
          threeState.scene.add(glassPanel);
        },

        // Create furniture
        createFurniture() {
          const furnitureMaterial = new THREE.MeshStandardMaterial({
            color: 0x64748b,
            roughness: 0.6,
            metalness: 0.1
          });

          FLOOR_PLAN_CONFIG.furniture.forEach(item => {
            const roomConfig = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === item.room);
            if (!roomConfig) return;

            const mesh = new THREE.Mesh(
              new THREE.BoxGeometry(item.width, item.height, item.depth),
              furnitureMaterial
            );
            mesh.position.set(
              roomConfig.x - centerX,
              item.height / 2,
              roomConfig.z - centerZ
            );
            mesh.castShadow = true;
            threeState.scene.add(mesh);

            // Add bedding for bed
            if (item.type === 'bed') {
              const beddingMaterial = new THREE.MeshStandardMaterial({
                color: 0x94a3b8,
                roughness: 0.8
              });
              const bedding = new THREE.Mesh(
                new THREE.BoxGeometry(item.width * 0.95, 0.1, item.depth * 0.8),
                beddingMaterial
              );
              bedding.position.set(
                roomConfig.x - centerX,
                item.height + 0.05,
                roomConfig.z - centerZ
              );
              threeState.scene.add(bedding);
            }
          });
        },

        createLabels(container) {
          // Clear any existing labels first
          Object.values(threeState.labelElements).forEach(label => {
            if (label && label.parentNode) {
              label.parentNode.removeChild(label);
            }
          });
          threeState.labelElements = {};

          // Also remove any orphaned labels
          container.querySelectorAll('.room-3d-label').forEach(el => el.remove());

          FLOOR_PLAN_CONFIG.rooms.forEach(roomConfig => {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'room-3d-label';
            labelDiv.innerHTML = `
              <div class="label-icon">${roomConfig.icon}</div>
              <div class="label-name">${roomConfig.name}</div>
              <div class="label-value" data-room="${roomConfig.id}">--</div>
              <div class="label-secondary" data-room-secondary="${roomConfig.id}">--</div>
            `;
            container.appendChild(labelDiv);
            threeState.labelElements[roomConfig.id] = labelDiv;
          });
        },

        updateLabels() {
          const container = this.$refs.threeContainer;
          if (!container || !threeState.camera) return;

          const rooms = Alpine.store('rooms')?.list || [];
          const viewMode = this.viewMode;
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;

          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const label = threeState.labelElements[config.id];
            if (!label) return;

            const roomData = rooms.find(r => r.id === config.id);
            const valueEl = label.querySelector(`[data-room="${config.id}"]`);
            const secondaryEl = label.querySelector(`[data-room-secondary="${config.id}"]`);

            if (valueEl && roomData) {
              if (viewMode === 'temperature') {
                valueEl.textContent = roomData.temperature !== null
                  ? `${roomData.temperature.toFixed(1)}¬∞` : '--';
                if (secondaryEl) {
                  secondaryEl.textContent = roomData.humidity !== null
                    ? `${roomData.humidity.toFixed(0)}%` : '';
                }
              } else {
                valueEl.textContent = roomData.humidity !== null
                  ? `${roomData.humidity.toFixed(0)}%` : '--';
                if (secondaryEl) {
                  secondaryEl.textContent = roomData.temperature !== null
                    ? `${roomData.temperature.toFixed(1)}¬∞` : '';
                }
              }
            }

            // Project 3D to 2D - use labelY offset to prevent overlap
            // config.x, config.z are center coordinates; convert to world space
            const position = new THREE.Vector3(
              config.x - centerX,
              config.labelY || 3,
              config.z - centerZ
            );
            position.project(threeState.camera);

            const x = (position.x * 0.5 + 0.5) * containerWidth;
            const y = (-position.y * 0.5 + 0.5) * containerHeight;

            label.style.left = `${x}px`;
            label.style.top = `${y}px`;

            // Only show label if within container bounds and container is visible
            const margin = 20;
            const isVisible = containerWidth > 0 && containerHeight > 0 &&
                              x > margin && x < containerWidth - margin &&
                              y > margin && y < containerHeight - margin;

            if (isVisible) {
              label.classList.add('visible');
            } else {
              label.classList.remove('visible');
            }
          });
        },

        updateRoomColors() {
          const rooms = Alpine.store('rooms')?.list || [];
          const viewMode = this.viewMode;

          rooms.forEach(roomData => {
            const meshGroup = threeState.roomMeshes[roomData.id];
            if (!meshGroup) return;

            // Find floor mesh directly in children
            const floorMesh = meshGroup.children.find(child =>
              child.name === 'floor_' + roomData.id
            );

            if (floorMesh && floorMesh.material) {
              const color = this.getRoomColor(roomData, viewMode);
              floorMesh.material.color.setHex(color);
            }
          });
        },

        getRoomColor(room, viewMode) {
          if (!room) return 0xE0E0E0;

          const value = viewMode === 'temperature' ? room.temperature : room.humidity;
          if (value === null || value === undefined) return 0xE0E0E0;

          const scale = viewMode === 'temperature' ? TEMP_COLORS : HUMIDITY_COLORS;
          return this.interpolateColor(value, scale);
        },

        interpolateColor(value, scale) {
          if (value <= scale[0].value) return scale[0].color;
          if (value >= scale[scale.length - 1].value) return scale[scale.length - 1].color;

          let lower = scale[0], upper = scale[scale.length - 1];
          for (let i = 0; i < scale.length - 1; i++) {
            if (value >= scale[i].value && value <= scale[i + 1].value) {
              lower = scale[i];
              upper = scale[i + 1];
              break;
            }
          }

          const factor = (value - lower.value) / (upper.value - lower.value);

          const lowerColor = new THREE.Color(lower.color);
          const upperColor = new THREE.Color(upper.color);
          const result = new THREE.Color();
          result.lerpColors(lowerColor, upperColor, factor);

          return result.getHex();
        },

        animate() {
          const self = this;
          function loop() {
            threeState.animationId = requestAnimationFrame(loop);

            // Update OrbitControls (required for damping)
            if (threeState.controls) {
              threeState.controls.update();
            }

            self.updateRoomColors();
            self.updateLabels();

            if (threeState.renderer && threeState.scene && threeState.camera) {
              threeState.renderer.render(threeState.scene, threeState.camera);
            }
          }
          loop();
        },

        onResize() {
          const container = this.$refs.threeContainer;
          if (!container || !threeState.camera || !threeState.renderer) return;

          const aspect = container.clientWidth / container.clientHeight;

          // Update PerspectiveCamera aspect ratio
          threeState.camera.aspect = aspect;
          threeState.camera.updateProjectionMatrix();

          threeState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        setViewMode(mode) {
          this.viewMode = mode;
        },

        // View control functions
        set3DView() {
          this.viewMode3D = '3d';
          if (threeState.camera && threeState.controls) {
            threeState.camera.position.set(12, 12, 12);
            threeState.controls.target.set(0, 0, 0);
            threeState.controls.update();
          }
        },

        setTopView() {
          this.viewMode3D = 'top';
          if (threeState.camera && threeState.controls) {
            threeState.camera.position.set(0, 14, -0.1);
            threeState.controls.target.set(0, 0, 0);
            threeState.controls.update();
          }
        },

        toggleWalls() {
          this.wallsVisible = !this.wallsVisible;
          threeState.wallMeshes.forEach(wall => {
            wall.visible = this.wallsVisible;
          });
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (threeState.controls) {
            threeState.controls.autoRotate = this.autoRotate;
            threeState.controls.autoRotateSpeed = 2.0;
          }
        },

        toggleDarkTheme() {
          this.darkTheme = !this.darkTheme;
          if (this.darkTheme) {
            threeState.scene.background = new THREE.Color(0x0f172a);
            threeState.scene.fog = new THREE.Fog(0x0f172a, 10, 50);
          } else {
            threeState.scene.background = new THREE.Color(0xE8E8EA);
            threeState.scene.fog = null;
          }
        },

        zoomIn() {
          if (threeState.camera && threeState.controls) {
            const direction = new THREE.Vector3();
            direction.subVectors(threeState.controls.target, threeState.camera.position).normalize();
            threeState.camera.position.addScaledVector(direction, 2);
            threeState.controls.update();
          }
        },

        zoomOut() {
          if (threeState.camera && threeState.controls) {
            const direction = new THREE.Vector3();
            direction.subVectors(threeState.controls.target, threeState.camera.position).normalize();
            threeState.camera.position.addScaledVector(direction, -2);
            threeState.controls.update();
          }
        },

        getLegendItems() {
          if (this.viewMode === 'temperature') {
            return [
              { label: '< 20¬∞', color: '#90CAF9' },
              { label: '20-24¬∞', color: '#81C784' },
              { label: '24-28¬∞', color: '#FFE082' },
              { label: '> 28¬∞', color: '#EF5350' }
            ];
          } else {
            return [
              { label: '< 40%', color: '#FFCC80' },
              { label: '40-60%', color: '#81C784' },
              { label: '60-70%', color: '#90CAF9' },
              { label: '> 70%', color: '#5C6BC0' }
            ];
          }
        }
      };
    }

    // ========================================
    // ISOMETRIC FLOOR PLAN VIEW
    // ========================================
    function isometricView() {
      const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
      const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

      return {
        viewMode: 'temperature',
        zoomLevel: 1.0,
        wallsVisible: true,
        darkTheme: false,
        autoRotate: false,
        rotationAngle: 0,

        init() {
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.isoContainer;
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          if (isoState.isInitialized && isoState.renderer) {
            if (!container.contains(isoState.renderer.domElement)) {
              container.appendChild(isoState.renderer.domElement);
            }
            this.createLabels(container);
            this.onResize();
            return;
          }

          if (isoState.renderer) isoState.renderer.dispose();
          if (isoState.scene) isoState.scene.clear();
          if (isoState.animationId) cancelAnimationFrame(isoState.animationId);

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.createLabels(container);
          this.setupPanControls(container);
          this.animate();
          isoState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          isoState.scene = new THREE.Scene();
          isoState.scene.background = new THREE.Color(0xE8E8EA);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15;
          isoState.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2, 0.1, 1000
          );
          isoState.camera.position.set(10, 10, 10);
          isoState.camera.lookAt(0, 0, 0);
        },

        initRenderer(container) {
          isoState.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          isoState.renderer.setSize(container.clientWidth, container.clientHeight);
          isoState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          isoState.renderer.shadowMap.enabled = true;
          isoState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(isoState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.6);
          isoState.scene.add(ambient);
          const directional = new THREE.DirectionalLight(0xffffff, 0.8);
          directional.position.set(15, 20, 15);
          directional.castShadow = true;
          isoState.scene.add(directional);
          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          isoState.scene.add(fill);
        },

        buildFloorPlan() {
          isoState.wallMeshes = [];
          const apW = FLOOR_PLAN_CONFIG.apartmentWidth;
          const apD = FLOOR_PLAN_CONFIG.apartmentDepth;

          // Base floor
          const floorGeometry = new THREE.PlaneGeometry(apW + 2, apD + 2);
          const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xC0C0C2, roughness: 0.8 });
          const floor = new THREE.Mesh(floorGeometry, floorMaterial);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(0, -0.01, 0);
          floor.receiveShadow = true;
          isoState.scene.add(floor);

          // Rooms
          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const roomGroup = this.createRoom(config);
            isoState.roomMeshes[config.id] = roomGroup;
            isoState.scene.add(roomGroup);
          });

          // Hallway
          const hw = FLOOR_PLAN_CONFIG.hallway;
          const hallway = new THREE.Mesh(
            new THREE.PlaneGeometry(hw.width, hw.depth),
            new THREE.MeshStandardMaterial({ color: 0xD0D0D0, roughness: 0.7 })
          );
          hallway.rotation.x = -Math.PI / 2;
          hallway.position.set(hw.x - centerX, 0.005, hw.z - centerZ);
          isoState.scene.add(hallway);

          // Balcony
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const balcony = new THREE.Mesh(
            new THREE.PlaneGeometry(bal.width, bal.depth),
            new THREE.MeshStandardMaterial({ color: 0x93c5fd, roughness: 0.5 })
          );
          balcony.rotation.x = -Math.PI / 2;
          balcony.position.set(bal.x - centerX, 0.003, bal.z - centerZ);
          isoState.scene.add(balcony);

          // Doors, windows, railing, furniture
          FLOOR_PLAN_CONFIG.doors.forEach(door => this.createDoor(door));
          FLOOR_PLAN_CONFIG.windows.forEach(win => this.createWindow(win));
          this.createBalconyRailing();
          this.createFurniture();
        },

        createRoom(config) {
          const group = new THREE.Group();
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;
          const halfW = config.width / 2, halfD = config.depth / 2;
          const rx = config.x - centerX, rz = config.z - centerZ;

          // Floor
          const floorMaterial = new THREE.MeshStandardMaterial({
            color: config.color, transparent: true, opacity: 0.3, roughness: 0.6, metalness: 0.1
          });
          const roomFloor = new THREE.Mesh(new THREE.BoxGeometry(config.width, 0.05, config.depth), floorMaterial);
          roomFloor.position.set(rx, 0.025, rz);
          roomFloor.receiveShadow = true;
          roomFloor.name = 'floor_' + config.id;
          group.add(roomFloor);

          // Walls
          const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff, transparent: true, opacity: 0.25, metalness: 0.4, roughness: 0.08, side: THREE.DoubleSide
          });
          const walls = [
            { geo: [config.width, wallHeight, 0.15], pos: [rx, wallHeight/2, rz - halfD] },
            { geo: [config.width, wallHeight, 0.15], pos: [rx, wallHeight/2, rz + halfD] },
            { geo: [0.15, wallHeight, config.depth], pos: [rx - halfW, wallHeight/2, rz] },
            { geo: [0.15, wallHeight, config.depth], pos: [rx + halfW, wallHeight/2, rz] }
          ];
          walls.forEach(w => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(...w.geo), wallMaterial);
            wall.position.set(...w.pos);
            wall.castShadow = true;
            group.add(wall);
            isoState.wallMeshes.push(wall);
          });
          return group;
        },

        createDoor(doorConfig) {
          const doorWidth = 0.9, doorHeight = FLOOR_PLAN_CONFIG.wallHeight * 0.85;
          const posX = doorConfig.x - centerX, posZ = doorConfig.z - centerZ;

          if (doorConfig.type === 'french') {
            const glassMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4 });
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const rot = doorConfig.rotation || 0;
            const offset = doorWidth/2 + 0.01;

            [-1, 1].forEach(side => {
              const door = new THREE.Mesh(new THREE.BoxGeometry(doorWidth - 0.02, doorHeight, 0.06), glassMaterial);
              const ox = offset * Math.cos(rot + side * Math.PI/2);
              const oz = offset * Math.sin(rot + side * Math.PI/2);
              door.position.set(posX + ox, doorHeight/2, posZ + oz);
              door.rotation.y = rot;
              isoState.scene.add(door);
            });
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.05, doorHeight, 0.08), frameMaterial);
            frame.position.set(posX, doorHeight/2, posZ);
            frame.rotation.y = rot;
            isoState.scene.add(frame);
          } else {
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const door = new THREE.Mesh(new THREE.BoxGeometry(doorWidth, doorHeight, 0.08), doorMaterial);
            door.position.set(posX, doorHeight/2, posZ);
            door.rotation.y = doorConfig.rotation || 0;
            isoState.scene.add(door);
          }
        },

        createWindow(winConfig) {
          const winWidth = winConfig.size || 2.0, winHeight = 1.3;
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;
          const posX = winConfig.x - centerX, posZ = winConfig.z - centerZ;

          const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.5 });
          const glassMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4 });

          const frame = new THREE.Mesh(new THREE.BoxGeometry(winWidth, winHeight, 0.15), frameMaterial);
          frame.position.set(posX, wallHeight * 0.55, posZ);
          frame.rotation.y = winConfig.rotation || 0;
          isoState.scene.add(frame);

          const glass = new THREE.Mesh(new THREE.BoxGeometry(winWidth * 0.9, winHeight * 0.85, 0.06), glassMaterial);
          glass.position.set(posX, wallHeight * 0.55, posZ);
          glass.rotation.y = winConfig.rotation || 0;
          isoState.scene.add(glass);
        },

        createBalconyRailing() {
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const railingHeight = 1.0;
          const railingMaterial = new THREE.MeshStandardMaterial({ color: 0x374151, metalness: 0.7 });

          const front = new THREE.Mesh(new THREE.BoxGeometry(bal.width, railingHeight, 0.05), railingMaterial);
          front.position.set(bal.x - centerX, railingHeight/2, bal.z - centerZ + bal.depth/2);
          isoState.scene.add(front);

          const left = new THREE.Mesh(new THREE.BoxGeometry(0.05, railingHeight, bal.depth), railingMaterial);
          left.position.set(bal.x - centerX - bal.width/2, railingHeight/2, bal.z - centerZ);
          isoState.scene.add(left);

          const glassMaterial = new THREE.MeshStandardMaterial({ color: 0xccf0ff, transparent: true, opacity: 0.3 });
          const glassPanel = new THREE.Mesh(new THREE.BoxGeometry(bal.width, railingHeight * 0.7, 0.02), glassMaterial);
          glassPanel.position.set(bal.x - centerX, railingHeight * 0.4, bal.z - centerZ + bal.depth/2);
          isoState.scene.add(glassPanel);
        },

        createFurniture() {
          const furnitureMaterial = new THREE.MeshStandardMaterial({ color: 0x64748b, roughness: 0.6 });
          FLOOR_PLAN_CONFIG.furniture.forEach(item => {
            const roomConfig = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === item.room);
            if (!roomConfig) return;
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(item.width, item.height, item.depth), furnitureMaterial);
            mesh.position.set(roomConfig.x - centerX, item.height/2, roomConfig.z - centerZ);
            mesh.castShadow = true;
            isoState.scene.add(mesh);
            if (item.type === 'bed') {
              const bedding = new THREE.Mesh(
                new THREE.BoxGeometry(item.width * 0.95, 0.1, item.depth * 0.8),
                new THREE.MeshStandardMaterial({ color: 0x94a3b8, roughness: 0.8 })
              );
              bedding.position.set(roomConfig.x - centerX, item.height + 0.05, roomConfig.z - centerZ);
              isoState.scene.add(bedding);
            }
          });
        },

        setupPanControls(container) {
          container.addEventListener('pointerdown', (e) => {
            isoState.isPanning = true;
            isoState.lastPanPos = { x: e.clientX, y: e.clientY };
            container.setPointerCapture(e.pointerId);
            container.style.cursor = 'grabbing';
          });
          container.addEventListener('pointermove', (e) => {
            if (!isoState.isPanning) return;
            const dx = e.clientX - isoState.lastPanPos.x;
            const dy = e.clientY - isoState.lastPanPos.y;
            const panSpeed = 0.02 / this.zoomLevel;
            isoState.panOffset.x -= (dx - dy) * panSpeed * 0.7;
            isoState.panOffset.z -= (dx + dy) * panSpeed * 0.7;
            isoState.camera.lookAt(isoState.panOffset.x, 0, isoState.panOffset.z);
            isoState.lastPanPos = { x: e.clientX, y: e.clientY };
          });
          container.addEventListener('pointerup', (e) => {
            isoState.isPanning = false;
            container.releasePointerCapture(e.pointerId);
            container.style.cursor = 'grab';
          });
          container.addEventListener('pointerleave', () => {
            isoState.isPanning = false;
            container.style.cursor = 'grab';
          });
          container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
            this.setZoom(this.zoomLevel * zoomDelta);
          }, { passive: false });
        },

        setZoom(level) {
          this.zoomLevel = Math.max(0.5, Math.min(3.0, level));
          this.updateCameraZoom();
        },

        updateCameraZoom() {
          const container = this.$refs.isoContainer;
          if (!container || !isoState.camera) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          isoState.camera.left = frustumSize * aspect / -2;
          isoState.camera.right = frustumSize * aspect / 2;
          isoState.camera.top = frustumSize / 2;
          isoState.camera.bottom = frustumSize / -2;
          isoState.camera.updateProjectionMatrix();
        },

        zoomIn() { this.setZoom(this.zoomLevel * 1.2); },
        zoomOut() { this.setZoom(this.zoomLevel / 1.2); },

        resetView() {
          this.zoomLevel = 1.0;
          this.autoRotate = false;
          this.rotationAngle = Math.PI / 4; // 45 degrees (default isometric angle)
          isoState.panOffset = { x: 0, z: 0 };
          isoState.camera.position.set(10, 10, 10);
          isoState.camera.lookAt(0, 0, 0);
          this.updateCameraZoom();
        },

        createLabels(container) {
          Object.values(isoState.labelElements).forEach(label => {
            if (label && label.parentNode) label.parentNode.removeChild(label);
          });
          isoState.labelElements = {};
          container.querySelectorAll('.iso-label').forEach(el => el.remove());

          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'iso-label';
            labelDiv.innerHTML = `
              <div class="label-name">${config.icon} ${config.name}</div>
              <div class="label-value" data-room="${config.id}">--</div>
              <div class="label-secondary" data-room-secondary="${config.id}">--</div>
            `;
            container.appendChild(labelDiv);
            isoState.labelElements[config.id] = labelDiv;
          });
        },

        updateLabels() {
          const container = this.$refs.isoContainer;
          if (!container || !isoState.camera) return;
          const rooms = Alpine.store('rooms')?.list || [];
          const viewMode = this.viewMode;

          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const label = isoState.labelElements[config.id];
            if (!label) return;
            const roomData = rooms.find(r => r.id === config.id);
            const valueEl = label.querySelector(`[data-room="${config.id}"]`);
            const secondaryEl = label.querySelector(`[data-room-secondary="${config.id}"]`);

            if (valueEl && roomData) {
              if (viewMode === 'temperature') {
                valueEl.textContent = roomData.temperature !== null ? `${roomData.temperature.toFixed(1)}¬∞` : '--';
                if (secondaryEl) secondaryEl.textContent = roomData.humidity !== null ? `${roomData.humidity.toFixed(0)}%` : '';
              } else {
                valueEl.textContent = roomData.humidity !== null ? `${roomData.humidity.toFixed(0)}%` : '--';
                if (secondaryEl) secondaryEl.textContent = roomData.temperature !== null ? `${roomData.temperature.toFixed(1)}¬∞` : '';
              }
            }

            const position = new THREE.Vector3(config.x - centerX, config.labelY || 3, config.z - centerZ);
            position.project(isoState.camera);
            const x = (position.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-position.y * 0.5 + 0.5) * container.clientHeight;
            label.style.left = `${x}px`;
            label.style.top = `${y}px`;

            const margin = 20;
            const isVisible = container.clientWidth > 0 && x > margin && x < container.clientWidth - margin && y > margin && y < container.clientHeight - margin;
            label.classList.toggle('visible', isVisible);
          });
        },

        updateRoomColors() {
          const rooms = Alpine.store('rooms')?.list || [];
          rooms.forEach(roomData => {
            const meshGroup = isoState.roomMeshes[roomData.id];
            if (!meshGroup) return;
            const floorMesh = meshGroup.children.find(child => child.name === 'floor_' + roomData.id);
            if (floorMesh && floorMesh.material) {
              floorMesh.material.color.setHex(this.getRoomColor(roomData, this.viewMode));
            }
          });
        },

        getRoomColor(room, viewMode) {
          if (!room) return 0xE0E0E0;
          const value = viewMode === 'temperature' ? room.temperature : room.humidity;
          if (value === null || value === undefined) return 0xE0E0E0;
          const scale = viewMode === 'temperature' ? TEMP_COLORS : HUMIDITY_COLORS;
          return this.interpolateColor(value, scale);
        },

        interpolateColor(value, scale) {
          if (value <= scale[0].value) return scale[0].color;
          if (value >= scale[scale.length - 1].value) return scale[scale.length - 1].color;
          let lower = scale[0], upper = scale[scale.length - 1];
          for (let i = 0; i < scale.length - 1; i++) {
            if (value >= scale[i].value && value <= scale[i + 1].value) {
              lower = scale[i];
              upper = scale[i + 1];
              break;
            }
          }
          const factor = (value - lower.value) / (upper.value - lower.value);
          const lowerColor = new THREE.Color(lower.color);
          const upperColor = new THREE.Color(upper.color);
          const result = new THREE.Color();
          result.lerpColors(lowerColor, upperColor, factor);
          return result.getHex();
        },

        toggleWalls() {
          this.wallsVisible = !this.wallsVisible;
          isoState.wallMeshes.forEach(wall => { wall.visible = this.wallsVisible; });
        },

        toggleDarkTheme() {
          this.darkTheme = !this.darkTheme;
          if (this.darkTheme) {
            isoState.scene.background = new THREE.Color(0x0f172a);
            isoState.scene.fog = new THREE.Fog(0x0f172a, 10, 50);
          } else {
            isoState.scene.background = new THREE.Color(0xE8E8EA);
            isoState.scene.fog = null;
          }
        },

        animate() {
          const self = this;
          const radius = 17.32; // Distance from center (sqrt(10^2 + 10^2 + 10^2) ‚âà 17.32)
          const height = 10;    // Camera height

          function loop() {
            isoState.animationId = requestAnimationFrame(loop);

            // Auto-rotate camera around the center
            if (self.autoRotate && isoState.camera) {
              self.rotationAngle += 0.005; // ~0.3 degrees per frame
              const x = Math.sin(self.rotationAngle) * radius;
              const z = Math.cos(self.rotationAngle) * radius;
              isoState.camera.position.set(x, height, z);
              isoState.camera.lookAt(isoState.panOffset.x, 0, isoState.panOffset.z);
            }

            self.updateRoomColors();
            self.updateLabels();
            if (isoState.renderer && isoState.scene && isoState.camera) {
              isoState.renderer.render(isoState.scene, isoState.camera);
            }
          }
          loop();
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (this.autoRotate) {
            // Calculate current angle from camera position
            const pos = isoState.camera.position;
            this.rotationAngle = Math.atan2(pos.x, pos.z);
          }
        },

        onResize() {
          const container = this.$refs.isoContainer;
          if (!container || !isoState.camera || !isoState.renderer) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          isoState.camera.left = frustumSize * aspect / -2;
          isoState.camera.right = frustumSize * aspect / 2;
          isoState.camera.top = frustumSize / 2;
          isoState.camera.bottom = frustumSize / -2;
          isoState.camera.updateProjectionMatrix();
          isoState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        setViewMode(mode) { this.viewMode = mode; },
        getZoomPercent() { return Math.round(this.zoomLevel * 100); }
      };
    }

    // ========================================
    // ZIGBEE NETWORK VIEW
    // Warm beige monochromatic visualization
    // ========================================

    const networkState = {
      scene: null,
      camera: null,
      renderer: null,
      roomMeshes: {},
      wallMeshes: [],
      deviceMeshes: {},
      labelElements: {},
      signalElements: {},
      animationId: null,
      isInitialized: false,
      panOffset: { x: 0, z: 0 },
      isPanning: false,
      lastPanPos: { x: 0, y: 0 }
    };

    // Device configuration with types and icons
    const ZIGBEE_DEVICES = [
      { id: 'coordinator', name: 'ZBBridge-P', type: 'coordinator', icon: 'üì°', room: 'living', x: 0.5, z: 0.4 },
      { id: 'router1', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'study', x: 0.8, z: 0.2 },
      { id: 'router2', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'living', x: 0.3, z: 0.3 },
      { id: 'sensor1', name: 'SNZB-02P', type: 'end-device', icon: 'üå°Ô∏è', room: 'bedroom', x: 0.2, z: 0.15 },
      { id: 'sensor2', name: 'SNZB-03P', type: 'end-device', icon: 'üö∂', room: 'kitchen', x: 0.5, z: 0.1 },
      { id: 'sensor3', name: 'SNZB-04P', type: 'end-device', icon: 'üö™', room: 'bathroom', x: 0.85, z: 0.1 },
      { id: 'trv', name: 'TRVZB', type: 'end-device', icon: 'üî•', room: 'bedroom', x: 0.1, z: 0.25 },
    ];

    function networkView() {
      const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
      const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

      return {
        showSignalRange: true,
        showLabels: true,
        autoRotate: false,
        rotationAngle: 0,
        zoomLevel: 1.0,
        deviceCount: ZIGBEE_DEVICES.length,
        routerCount: ZIGBEE_DEVICES.filter(d => d.type === 'router').length,
        endDeviceCount: ZIGBEE_DEVICES.filter(d => d.type === 'end-device').length,

        init() {
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.networkContainer;
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          if (networkState.isInitialized && networkState.renderer) {
            if (!container.contains(networkState.renderer.domElement)) {
              container.appendChild(networkState.renderer.domElement);
            }
            this.createLabels(container);
            this.onResize();
            return;
          }

          if (networkState.renderer) networkState.renderer.dispose();
          if (networkState.scene) networkState.scene.clear();
          if (networkState.animationId) cancelAnimationFrame(networkState.animationId);

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.createDevices();
          this.createLabels(container);
          this.setupPanControls(container);
          this.animate();
          networkState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          networkState.scene = new THREE.Scene();
          // Warm beige gradient background
          networkState.scene.background = new THREE.Color(0xE8DFD4);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15;
          networkState.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2, 0.1, 1000
          );
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
        },

        initRenderer(container) {
          networkState.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
          networkState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          networkState.renderer.shadowMap.enabled = true;
          networkState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(networkState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.7);
          networkState.scene.add(ambient);
          const directional = new THREE.DirectionalLight(0xffffff, 0.6);
          directional.position.set(15, 20, 15);
          directional.castShadow = true;
          networkState.scene.add(directional);
          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          networkState.scene.add(fill);
        },

        buildFloorPlan() {
          networkState.wallMeshes = [];
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

          // Build rooms with warm tones (each room has its own floor)
          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            this.createRoom(config);
          });

          // Add hallway - extended to align with study/bathroom back walls at z=0
          const hw = FLOOR_PLAN_CONFIG.hallway;
          const wallHeight = 0.8;
          const wallColor = 0xB5A080;
          const hwX = hw.x - centerX;

          // Calculate positions aligned with study/bathroom outer wall at z=0
          const backWallZ = 0 - centerZ;  // z=0 in config = back of apartment
          const frontWallZ = hw.z + hw.depth/2 - centerZ;  // Front of hallway
          const hallwayDepth = frontWallZ - backWallZ;  // Full depth from back to hallway front
          const hallwayCenterZ = (backWallZ + frontWallZ) / 2;

          // Hallway floor - spans from study right edge to bathroom left edge
          const studyRoom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
          const bathroomRoom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');
          const corridorLeft = studyRoom.x + studyRoom.width/2;
          const corridorRight = bathroomRoom.x - bathroomRoom.width/2;
          const corridorWidth = corridorRight - corridorLeft;
          const corridorCenterX = (corridorLeft + corridorRight) / 2 - centerX;
          const hallwayGeom = new THREE.PlaneGeometry(corridorWidth, hallwayDepth);
          const hallwayMat = new THREE.MeshStandardMaterial({ color: 0xD4C4B0, roughness: 0.8 });
          const hallway = new THREE.Mesh(hallwayGeom, hallwayMat);
          hallway.rotation.x = -Math.PI / 2;
          hallway.position.set(corridorCenterX, 0.005, hallwayCenterZ);
          hallway.receiveShadow = true;
          networkState.scene.add(hallway);

          // Add hallway walls
          const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.7 });

          // Hallway west wall - at study's right edge, extends from back to hallway front
          const studyRightEdge = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
          const westWallX = studyRightEdge.x + studyRightEdge.width/2 - centerX;
          const hwWestWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, hallwayDepth), wallMat);
          hwWestWall.position.set(westWallX, wallHeight/2, hallwayCenterZ);
          hwWestWall.castShadow = true;
          networkState.scene.add(hwWestWall);
          networkState.wallMeshes.push(hwWestWall);

          // Hallway north wall - spans from study right edge to bathroom left edge
          const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
          const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');
          const northWallLeft = study.x + study.width/2;  // Study right edge
          const northWallRight = bathroom.x - bathroom.width/2;  // Bathroom left edge
          const northWallWidth = northWallRight - northWallLeft;
          const northWallCenterX = (northWallLeft + northWallRight) / 2 - centerX;
          const hwNorthWall = new THREE.Mesh(new THREE.BoxGeometry(northWallWidth, wallHeight, 0.08), wallMat);
          hwNorthWall.position.set(northWallCenterX, wallHeight/2, backWallZ);
          hwNorthWall.castShadow = true;
          networkState.scene.add(hwNorthWall);
          networkState.wallMeshes.push(hwNorthWall);

          // Hallway south wall (front of corridor) - same width as north wall
          const hwSouthWall = new THREE.Mesh(new THREE.BoxGeometry(northWallWidth, wallHeight, 0.08), wallMat);
          hwSouthWall.position.set(northWallCenterX, wallHeight/2, frontWallZ);
          hwSouthWall.castShadow = true;
          networkState.scene.add(hwSouthWall);
          networkState.wallMeshes.push(hwSouthWall);

          // Add stepped middle wall - bedroom is caved in compared to living room
          // Left side at z=3.697 (study/living boundary)
          // Right side at z=4.287 (kitchen/bedroom boundary)
          const studyFrontZ = studyRoom.z + studyRoom.depth/2;  // 3.697
          const kitchenRoom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'kitchen');
          const kitchenFrontZ = kitchenRoom.z + kitchenRoom.depth/2;  // 4.287

          // Left wall section (study/living boundary) - from left edge to corridor
          const leftWallZ = studyFrontZ - centerZ;
          const leftWallWidth = corridorLeft;  // From x=0 to study right edge
          const leftWallCenterX = corridorLeft/2 - centerX;
          const leftMiddleWall = new THREE.Mesh(new THREE.BoxGeometry(leftWallWidth, wallHeight, 0.08), wallMat);
          leftMiddleWall.position.set(leftWallCenterX, wallHeight/2, leftWallZ);
          leftMiddleWall.castShadow = true;
          networkState.scene.add(leftMiddleWall);
          networkState.wallMeshes.push(leftMiddleWall);

          // Right wall section (kitchen/bedroom boundary) - from corridor to right edge
          const rightWallZ = kitchenFrontZ - centerZ;
          const rightWallWidth = FLOOR_PLAN_CONFIG.apartmentWidth - corridorRight;
          const rightWallCenterX = (corridorRight + FLOOR_PLAN_CONFIG.apartmentWidth)/2 - centerX;
          const rightMiddleWall = new THREE.Mesh(new THREE.BoxGeometry(rightWallWidth, wallHeight, 0.08), wallMat);
          rightMiddleWall.position.set(rightWallCenterX, wallHeight/2, rightWallZ);
          rightMiddleWall.castShadow = true;
          networkState.scene.add(rightMiddleWall);
          networkState.wallMeshes.push(rightMiddleWall);

          // Step wall connecting the two levels (the cave-in)
          const stepDepth = kitchenFrontZ - studyFrontZ;  // 0.59m
          const stepCenterZ = (leftWallZ + rightWallZ) / 2;
          const stepWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, stepDepth), wallMat);
          stepWall.position.set(corridorRight - centerX, wallHeight/2, stepCenterZ);
          stepWall.castShadow = true;
          networkState.scene.add(stepWall);
          networkState.wallMeshes.push(stepWall);
        },

        createRoom(config) {
          const group = new THREE.Group();
          const floorColor = 0xC9B89A;  // Warm beige
          const wallColor = 0xB5A080;
          const wallHeight = 0.8;

          // Correct center coordinates (x,z are already center positions)
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const rx = config.x - centerX;
          const rz = config.z - centerZ;

          // Room floor at correct position
          const floorGeom = new THREE.PlaneGeometry(config.width, config.depth);
          const floorMat = new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 });
          const floor = new THREE.Mesh(floorGeom, floorMat);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(rx, 0.01, rz);
          floor.receiveShadow = true;
          group.add(floor);

          // Create all 4 walls automatically
          const halfW = config.width / 2;
          const halfD = config.depth / 2;
          const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.7 });

          // Back wall (north)
          const backWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
          backWall.position.set(rx, wallHeight/2, rz - halfD);
          backWall.castShadow = true;
          group.add(backWall);
          networkState.wallMeshes.push(backWall);

          // Front wall (south)
          const frontWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
          frontWall.position.set(rx, wallHeight/2, rz + halfD);
          frontWall.castShadow = true;
          group.add(frontWall);
          networkState.wallMeshes.push(frontWall);

          // Left wall (west)
          const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
          leftWall.position.set(rx - halfW, wallHeight/2, rz);
          leftWall.castShadow = true;
          group.add(leftWall);
          networkState.wallMeshes.push(leftWall);

          // Right wall (east)
          const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
          rightWall.position.set(rx + halfW, wallHeight/2, rz);
          rightWall.castShadow = true;
          group.add(rightWall);
          networkState.wallMeshes.push(rightWall);

          // Furniture
          this.createFurniture(group, config, rx, rz);

          networkState.scene.add(group);
          networkState.roomMeshes[config.id] = { group, floor, config };
        },

        createFurniture(group, config, rx, rz) {
          const furnitureColor = 0xBFA98A;
          const furnitureMat = new THREE.MeshStandardMaterial({ color: furnitureColor, roughness: 0.6 });

          if (config.id === 'bedroom') {
            // Bed
            const bedGeom = new THREE.BoxGeometry(1.4, 0.3, 2.0);
            const bed = new THREE.Mesh(bedGeom, furnitureMat);
            bed.position.set(rx - config.width/4, 0.15, rz);
            bed.castShadow = true;
            group.add(bed);
          } else if (config.id === 'living') {
            // Sofa
            const sofaGeom = new THREE.BoxGeometry(2.0, 0.4, 0.8);
            const sofa = new THREE.Mesh(sofaGeom, furnitureMat);
            sofa.position.set(rx, 0.2, rz + config.depth/4);
            sofa.castShadow = true;
            group.add(sofa);
          } else if (config.id === 'study') {
            // Desk
            const deskGeom = new THREE.BoxGeometry(1.2, 0.5, 0.6);
            const desk = new THREE.Mesh(deskGeom, furnitureMat);
            desk.position.set(rx + config.width/4, 0.25, rz - config.depth/4);
            desk.castShadow = true;
            group.add(desk);
          }
        },

        createDevices() {
          networkState.deviceMeshes = {};
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

          ZIGBEE_DEVICES.forEach(device => {
            // Create device marker (sphere)
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            let color;
            switch (device.type) {
              case 'coordinator': color = 0xFF6B6B; break;
              case 'router': color = 0x4DABF7; break;
              default: color = 0x51CF66;
            }
            const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geometry, material);

            // Position based on room (room.x, room.z are center coords)
            const room = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === device.room);
            if (room) {
              const roomCenterX = room.x - centerX;
              const roomCenterZ = room.z - centerZ;  // FIX: use z not y
              mesh.position.set(
                roomCenterX + (device.x - 0.5) * room.width * 0.8,
                0.5,
                roomCenterZ + (device.z - 0.5) * room.depth * 0.8
              );
            }

            mesh.castShadow = true;
            networkState.scene.add(mesh);
            networkState.deviceMeshes[device.id] = { mesh, config: device };
          });
        },

        createLabels(container) {
          // Clear existing labels
          Object.values(networkState.labelElements).forEach(el => el?.remove());
          Object.values(networkState.signalElements).forEach(el => el?.remove());
          networkState.labelElements = {};
          networkState.signalElements = {};

          ZIGBEE_DEVICES.forEach(device => {
            // Device label
            const label = document.createElement('div');
            label.className = 'device-label visible';
            label.innerHTML = `
              <div class="device-icon ${device.type}">${device.icon}</div>
              <div class="device-name">${device.name}</div>
            `;
            container.appendChild(label);
            networkState.labelElements[device.id] = label;

            // Signal range circle (for coordinator and routers)
            if (device.type === 'coordinator' || device.type === 'router') {
              const signal = document.createElement('div');
              signal.className = `signal-range ${device.type}`;
              signal.style.width = device.type === 'coordinator' ? '200px' : '150px';
              signal.style.height = device.type === 'coordinator' ? '200px' : '150px';
              container.appendChild(signal);
              networkState.signalElements[device.id] = signal;
            }
          });
        },

        updateLabels() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;

          ZIGBEE_DEVICES.forEach(device => {
            const deviceData = networkState.deviceMeshes[device.id];
            const label = networkState.labelElements[device.id];
            const signal = networkState.signalElements[device.id];

            if (!deviceData || !label) return;

            const pos = deviceData.mesh.position.clone();
            pos.y += 0.3;
            pos.project(networkState.camera);

            const x = (pos.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-pos.y * 0.5 + 0.5) * container.clientHeight;

            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.style.display = this.showLabels ? 'flex' : 'none';

            if (signal) {
              signal.style.left = x + 'px';
              signal.style.top = (y + 40) + 'px';
              signal.style.display = this.showSignalRange ? 'block' : 'none';
            }
          });
        },

        setupPanControls(container) {
          container.addEventListener('pointerdown', (e) => {
            if (this.autoRotate) return;
            networkState.isPanning = true;
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
            container.style.cursor = 'grabbing';
          });

          container.addEventListener('pointermove', (e) => {
            if (!networkState.isPanning) return;
            const dx = e.clientX - networkState.lastPanPos.x;
            const dy = e.clientY - networkState.lastPanPos.y;
            networkState.panOffset.x -= dx * 0.02;
            networkState.panOffset.z -= dy * 0.02;
            networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
          });

          container.addEventListener('pointerup', () => {
            networkState.isPanning = false;
            container.style.cursor = 'grab';
          });

          container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.setZoom(this.zoomLevel * delta);
          }, { passive: false });
        },

        setZoom(level) {
          this.zoomLevel = Math.max(0.5, Math.min(3.0, level));
          this.updateCameraZoom();
        },

        updateCameraZoom() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
        },

        zoomIn() { this.setZoom(this.zoomLevel * 1.2); },
        zoomOut() { this.setZoom(this.zoomLevel / 1.2); },

        resetView() {
          this.zoomLevel = 1.0;
          this.autoRotate = false;
          this.rotationAngle = Math.PI / 4;
          networkState.panOffset = { x: 0, z: 0 };
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
          this.updateCameraZoom();
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (this.autoRotate) {
            const pos = networkState.camera.position;
            this.rotationAngle = Math.atan2(pos.x, pos.z);
          }
        },

        animate() {
          const self = this;
          const radius = 17.32;
          const height = 10;

          function loop() {
            networkState.animationId = requestAnimationFrame(loop);

            if (self.autoRotate && networkState.camera) {
              self.rotationAngle += 0.003;
              const x = Math.sin(self.rotationAngle) * radius;
              const z = Math.cos(self.rotationAngle) * radius;
              networkState.camera.position.set(x, height, z);
              networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            }

            self.updateLabels();
            if (networkState.renderer && networkState.scene && networkState.camera) {
              networkState.renderer.render(networkState.scene, networkState.camera);
            }
          }
          loop();
        },

        onResize() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera || !networkState.renderer) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        getZoomPercent() { return Math.round(this.zoomLevel * 100); }
      };
    }
  </script>
</body>
</html>
