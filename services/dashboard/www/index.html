<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Home Climate</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Modularized CSS -->
  <link rel="stylesheet" href="styles/base.css">
  <link rel="stylesheet" href="styles/layout.css">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/views/comfort-score.css">
  <link rel="stylesheet" href="styles/views/bar-compare.css">
  <link rel="stylesheet" href="styles/views/floor-plan.css">
  <link rel="stylesheet" href="styles/views/ambient.css">
  <link rel="stylesheet" href="styles/views/timeline.css">
  <link rel="stylesheet" href="styles/views/classic.css">
  <link rel="stylesheet" href="styles/views/lights.css">
  <link rel="stylesheet" href="styles/views/3d-view.css">
  <link rel="stylesheet" href="styles/views/sensor-config.css">
  <link rel="stylesheet" href="styles/views/co2-view.css">
  <link rel="stylesheet" href="styles/views/isometric.css">
  <link rel="stylesheet" href="styles/views/network.css">

  <!-- Three.js for 3D Floor Plan -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls is now loaded via js/three/orbit-controls.js module in app.js -->

  <!-- Main app module (imports Alpine as ES module and starts it) -->
  <script type="module" src="./js/app.js"></script>
</head>
<body>
  <div class="app-container" x-data="app()" x-init="init()">

    <!-- Header -->
    <header class="app-header">
      <div class="header-content">
        <div class="header-left">
          <h1 class="header-title">Home Climate</h1>
          <div class="status-badge"
               :class="{ 'disconnected': !$store.mqtt.connected && !$store.mqtt.connecting, 'connecting': $store.mqtt.connecting }">
            <span class="loading-indicator loading-sm" x-show="$store.mqtt.connecting"></span>
            <span class="status-dot-header" x-show="!$store.mqtt.connecting" :class="{ 'connected': $store.mqtt.connected }"></span>
            <span x-text="$store.mqtt.connecting ? 'Connecting' : ($store.mqtt.connected ? 'Live' : 'Offline')"></span>
          </div>
        </div>
        <div class="header-right">
          <div class="date-time" x-text="currentDateTime"></div>
          <div class="last-update" x-text="'Last update: ' + lastUpdateText"></div>
        </div>
      </div>
    </header>

    <!-- Navigation Menu -->
    <nav class="nav-container">
      <div class="nav-tabs">
        <button class="nav-tab" :class="{ active: currentView === 'comfort' }"
                @click="setView('comfort')" title="Comfort Score (Press 1)">
          <span class="nav-icon">üéØ</span>
          <span class="nav-label">Score</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'compare' }"
                @click="setView('compare')" title="Room Comparison (Press 2)">
          <span class="nav-icon">üìä</span>
          <span class="nav-label">Compare</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'floor' }"
                @click="setView('floor')" title="Floor Plan (Press 3)">
          <span class="nav-icon">üè†</span>
          <span class="nav-label">Floor Plan</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'ambient' }"
                @click="setView('ambient')" title="Ambient Display (Press 4)">
          <span class="nav-icon">üå°Ô∏è</span>
          <span class="nav-label">Ambient</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'timeline' }"
                @click="setView('timeline')" title="Timeline Story (Press 5)">
          <span class="nav-icon">üìñ</span>
          <span class="nav-label">Timeline</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'classic' }"
                @click="setView('classic')" title="Classic Cards (Press 6)">
          <span class="nav-icon">üÉè</span>
          <span class="nav-label">Classic</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'lights' }"
                @click="setView('lights')" title="Light Control (Press 7)">
          <span class="nav-icon">üí°</span>
          <span class="nav-label">Lights</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === '3d' }"
                @click="setView('3d')" title="3D Floor Plan (Press 8)">
          <span class="nav-icon">üè†</span>
          <span class="nav-label">3D</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'isometric' }"
                @click="setView('isometric')" title="Isometric View (Press I)">
          <span class="nav-icon">üî∑</span>
          <span class="nav-label">Iso</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'config' }"
                @click="setView('config')" title="Sensor Config (Press 9)">
          <span class="nav-icon">‚öôÔ∏è</span>
          <span class="nav-label">Config</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'co2' }"
                @click="setView('co2')" title="CO2 Monitor (Press 0)">
          <span class="nav-icon">üí®</span>
          <span class="nav-label">CO2</span>
        </button>
        <button class="nav-tab" :class="{ active: currentView === 'network' }"
                @click="setView('network')" title="Zigbee Network (Press N)">
          <span class="nav-icon">üì°</span>
          <span class="nav-label">Network</span>
        </button>
      </div>
    </nav>

    <!-- Main Content -->
    <main class="app-main">
      <div class="view-container">

        <!-- Vision 1: Comfort Score -->
        <div x-show="currentView === 'comfort'" x-cloak x-data="comfortScoreView()">
          <div class="comfort-score-view">
            <div class="score-hero" @click="showBreakdown = !showBreakdown">
              <div class="score-label-top">YOUR HOME IS</div>
              <div class="score-circle" :style="{ '--score-color': getColor() }">
                <svg viewBox="0 0 200 200" class="score-ring">
                  <circle cx="100" cy="100" r="90" fill="none" stroke="var(--color-border)" stroke-width="8"/>
                  <circle cx="100" cy="100" r="90" fill="none" :stroke="getColor()" stroke-width="8"
                          stroke-linecap="round" :stroke-dasharray="getScoreArc()"
                          transform="rotate(-90 100 100)" class="score-arc"/>
                </svg>
                <div class="score-content">
                  <span class="score-number" :style="{ color: getColor() }" x-text="homeScore"></span>
                  <span class="score-label" x-text="getLabel()"></span>
                </div>
              </div>
              <div class="score-hint">Tap for breakdown</div>
            </div>

            <div class="score-breakdown" x-show="showBreakdown" x-transition>
              <div class="breakdown-title">Score Components</div>
              <div class="breakdown-item">
                <span class="breakdown-label">Temperature (70%)</span>
                <div class="breakdown-bar">
                  <div class="breakdown-fill" :style="{ width: (homeScore * 0.7) + '%', background: 'var(--color-primary)' }"></div>
                </div>
              </div>
              <div class="breakdown-item">
                <span class="breakdown-label">Humidity (30%)</span>
                <div class="breakdown-bar">
                  <div class="breakdown-fill" :style="{ width: (homeScore * 0.3) + '%', background: 'var(--color-success)' }"></div>
                </div>
              </div>
            </div>

            <div class="room-scores">
              <template x-for="room in roomScores" :key="room.id">
                <button class="room-pill" @click="openRoom(room)" :style="{ '--pill-color': getRoomColor(room.score) }">
                  <span class="pill-icon" x-text="room.icon"></span>
                  <span class="pill-score" :style="{ color: getRoomColor(room.score) }" x-text="room.score"></span>
                  <span class="pill-dot" :style="{ background: getRoomColor(room.score) }"></span>
                </button>
              </template>
            </div>

            <div class="room-labels">
              <template x-for="room in roomScores" :key="room.id + '-label'">
                <span class="room-label-text" x-text="room.name.split(' ')[0]"></span>
              </template>
            </div>

            <div class="comfort-spectrum">
              <div class="spectrum-bar">
                <div class="spectrum-gradient"></div>
                <div class="spectrum-marker" :style="{ left: homeScore + '%' }">
                  <div class="marker-line"></div>
                  <div class="marker-label">You</div>
                </div>
              </div>
              <div class="spectrum-labels">
                <span>Poor</span>
                <span>Okay</span>
                <span>Perfect</span>
              </div>
            </div>

            <div class="suggestions" x-show="suggestions.length > 0">
              <template x-for="(suggestion, index) in suggestions" :key="index">
                <div class="suggestion-card" :class="'suggestion-' + suggestion.type">
                  <span class="suggestion-icon" x-text="suggestion.icon"></span>
                  <div class="suggestion-content">
                    <div class="suggestion-title" x-text="suggestion.title"></div>
                    <div class="suggestion-message" x-text="suggestion.message"></div>
                  </div>
                  <button class="suggestion-dismiss" @click="suggestions.splice(index, 1)">&times;</button>
                </div>
              </template>
            </div>
          </div>
        </div>

        <!-- Vision 2: Bar Compare -->
        <div x-show="currentView === 'compare'" x-cloak x-data="barCompareView()">
          <div class="bar-compare-view">
            <div class="bar-controls">
              <div class="view-toggle">
                <button class="btn btn-secondary" :class="{ active: viewMode === 'temperature' }"
                        @click="setViewMode('temperature')">üå°Ô∏è Temp</button>
                <button class="btn btn-secondary" :class="{ active: viewMode === 'humidity' }"
                        @click="setViewMode('humidity')">üíß Humid</button>
                <button class="btn btn-secondary" :class="{ active: viewMode === 'both' }"
                        @click="setViewMode('both')">Both</button>
              </div>
              <div class="sort-controls">
                <select class="sort-select" x-model="sortBy">
                  <option value="temperature">Sort: Temperature</option>
                  <option value="humidity">Sort: Humidity</option>
                  <option value="name">Sort: Name</option>
                  <option value="score">Sort: Comfort</option>
                </select>
                <button class="sort-direction" @click="sortDirection = sortDirection === 'desc' ? 'asc' : 'desc'">
                  <span x-text="sortDirection === 'desc' ? '‚Üì' : '‚Üë'"></span>
                </button>
              </div>
            </div>

            <div class="charts-container" :class="{ 'single-chart': viewMode !== 'both' }">
              <div class="bar-chart" x-show="viewMode === 'temperature' || viewMode === 'both'">
                <h3 class="chart-title">üå°Ô∏è Temperature</h3>
                <div class="chart-wrapper">
                  <div class="comfort-zone" :style="getComfortZoneStyle('temperature')"></div>
                  <template x-for="room in sortedRooms" :key="room.id + '-temp'">
                    <div class="bar-row" @click="openRoom(room)">
                      <div class="bar-label">
                        <span class="bar-icon" x-text="room.icon"></span>
                        <span class="bar-name" x-text="room.name"></span>
                      </div>
                      <div class="bar-track">
                        <div class="bar-fill" :style="{ width: getBarWidth(room.temperature, 'temperature') + '%', background: getBarColor(room.temperature, 'temperature') }"></div>
                      </div>
                      <div class="bar-value" x-text="room.temperature.toFixed(1) + '¬∞'"></div>
                    </div>
                  </template>
                  <div class="scale-labels">
                    <template x-for="label in getScaleLabels('temperature')" :key="label">
                      <span x-text="label"></span>
                    </template>
                  </div>
                </div>
              </div>

              <div class="bar-chart" x-show="viewMode === 'humidity' || viewMode === 'both'">
                <h3 class="chart-title">üíß Humidity</h3>
                <div class="chart-wrapper">
                  <div class="comfort-zone" :style="getComfortZoneStyle('humidity')"></div>
                  <template x-for="room in sortedRooms" :key="room.id + '-humid'">
                    <div class="bar-row" @click="openRoom(room)">
                      <div class="bar-label">
                        <span class="bar-icon" x-text="room.icon"></span>
                        <span class="bar-name" x-text="room.name"></span>
                      </div>
                      <div class="bar-track">
                        <div class="bar-fill" :style="{ width: getBarWidth(room.humidity, 'humidity') + '%', background: getBarColor(room.humidity, 'humidity') }"></div>
                      </div>
                      <div class="bar-value" x-text="room.humidity.toFixed(0) + '%'"></div>
                    </div>
                  </template>
                  <div class="scale-labels">
                    <template x-for="label in getScaleLabels('humidity')" :key="label">
                      <span x-text="label"></span>
                    </template>
                  </div>
                </div>
              </div>
            </div>

            <div class="insights-section" x-show="insights.length > 0">
              <h3 class="insights-title">üìä Auto-Insights</h3>
              <div class="insights-list">
                <template x-for="insight in insights" :key="insight.message">
                  <div class="insight-card" :class="getInsightClass(insight.type)">
                    <span class="insight-icon" x-text="insight.icon"></span>
                    <div class="insight-content">
                      <div class="insight-title" x-text="insight.title"></div>
                      <div class="insight-message" x-text="insight.message"></div>
                    </div>
                  </div>
                </template>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 3: Floor Plan -->
        <div x-show="currentView === 'floor'" x-cloak x-data="floorPlanView()">
          <div class="floor-plan-view">
            <div class="floor-controls">
              <div class="view-toggle">
                <button class="btn btn-secondary" :class="{ active: viewType === 'temperature' }"
                        @click="setViewType('temperature')">üå°Ô∏è Temperature</button>
                <button class="btn btn-secondary" :class="{ active: viewType === 'humidity' }"
                        @click="setViewType('humidity')">üíß Humidity</button>
              </div>
            </div>

            <div class="floor-plan-container">
              <svg class="floor-plan-svg" :viewBox="'0 0 ' + layout.width + ' ' + layout.height">
                <!-- Compass -->
                <g class="compass" transform="translate(590, 30)">
                  <text font-size="12" fill="var(--color-text-tertiary)" text-anchor="middle">N</text>
                  <line x1="0" y1="8" x2="0" y2="20" stroke="var(--color-text-tertiary)" stroke-width="2"/>
                  <polygon points="-3,8 3,8 0,4" fill="var(--color-text-tertiary)"/>
                </g>

                <!-- Balcony (left of Living Room, west side) -->
                <g class="balcony">
                  <rect x="10" y="50" width="55" height="120" fill="none" stroke="var(--color-success)"
                        stroke-width="2" stroke-dasharray="5,3" rx="4"/>
                  <text x="37" y="115" font-size="10" fill="var(--color-success)" text-anchor="middle">Balcony</text>
                </g>

                <!-- Hallway (center corridor connecting all rooms) -->
                <rect x="295" y="235" width="130" height="100" fill="var(--color-bg)"
                      stroke="var(--color-border)" stroke-width="1" rx="4" opacity="0.5"/>
                <text x="360" y="290" font-size="11" fill="var(--color-text-tertiary)" text-anchor="middle">Hallway</text>

                <!-- Rooms -->
                <template x-for="room in rooms" :key="room.id">
                  <g class="floor-room" @click="openRoom(room)" style="cursor: pointer;">
                    <rect :x="room.x" :y="room.y" :width="room.width" :height="room.height"
                          :fill="room.color" stroke="var(--color-border)" stroke-width="2" rx="8" class="room-rect"/>
                    <text :x="room.x + room.width/2" :y="room.y + room.height/2 - 15"
                          text-anchor="middle" font-size="14" font-weight="500" fill="var(--color-text)"
                          x-text="room.name"></text>
                    <text :x="room.x + room.width/2" :y="room.y + room.height/2 + 10"
                          text-anchor="middle" font-size="24" font-weight="600" fill="var(--color-text)"
                          x-text="getValue(room)"></text>
                    <text :x="room.x + room.width/2" :y="room.y + room.height/2 + 30"
                          text-anchor="middle" font-size="12" fill="var(--color-text-secondary)"
                          x-text="viewType === 'temperature' ? (room.humidity?.toFixed(0) + '%' || '') : (room.temperature?.toFixed(1) + '¬∞' || '')"></text>
                    <text :x="room.x + room.width - 20" :y="room.y + room.height - 15" font-size="16" x-text="room.icon"></text>
                  </g>
                </template>

                <!-- Main Entry Door (east side at Bedroom) -->
                <g transform="translate(595, 80)">
                  <rect x="-10" y="-30" width="14" height="60" fill="var(--color-surface)"
                        stroke="var(--color-primary)" stroke-width="2" rx="3"/>
                  <text x="-3" y="45" font-size="8" fill="var(--color-primary)" text-anchor="middle" font-weight="500">üö™</text>
                </g>

                <!-- Windows indicators -->
                <g class="windows" opacity="0.6">
                  <!-- Living room window (west/left wall, near balcony door) -->
                  <rect x="66" y="130" width="4" height="50" fill="var(--color-info)" rx="2"/>
                  <!-- Bedroom window (east/right wall) -->
                  <rect x="590" y="160" width="4" height="50" fill="var(--color-info)" rx="2"/>
                  <!-- Study window (west/left wall) -->
                  <rect x="16" y="320" width="4" height="50" fill="var(--color-info)" rx="2"/>
                  <!-- Kitchen window (east/right wall) -->
                  <rect x="605" y="270" width="4" height="40" fill="var(--color-info)" rx="2"/>
                  <!-- Bathroom window (east/right wall) -->
                  <rect x="605" y="380" width="4" height="35" fill="var(--color-info)" rx="2"/>
                </g>
              </svg>
            </div>

            <div class="floor-legend">
              <div class="legend-title" x-text="viewType === 'temperature' ? 'Temperature' : 'Humidity'"></div>
              <div class="legend-items">
                <template x-for="item in getLegendItems()" :key="item.label">
                  <div class="legend-item">
                    <div class="legend-color" :style="{ background: item.color }"></div>
                    <span class="legend-label" x-text="item.label"></span>
                  </div>
                </template>
              </div>
            </div>

            <div class="floor-tip">Tap any room for detailed history</div>
          </div>
        </div>

        <!-- Vision 4: Ambient -->
        <div x-show="currentView === 'ambient'" x-cloak x-data="ambientView()">
          <div class="ambient-view" :style="{ background: getBackgroundColor() }" :class="{ 'dark-mode': isDarkMode }"
               @click="showDetailsOverlay()">
            <div class="ambient-main">
              <div class="ambient-temperature">
                <span x-text="currentRoom.temperature?.toFixed(1) || '--'"></span>
                <span class="ambient-unit">¬∞</span>
              </div>
              <div class="ambient-room-name" x-text="currentRoom.name"></div>
              <div class="ambient-humidity">
                <span>üíß</span>
                <span x-text="(currentRoom.humidity?.toFixed(0) || '--') + '%'"></span>
              </div>
            </div>

            <div class="ambient-details" x-show="showDetails" x-transition.opacity>
              <div class="detail-item">
                <span class="detail-label">Today</span>
                <span class="detail-value" x-text="getMinMaxToday()"></span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Trend</span>
                <span class="detail-value trend" x-text="getTrend()"></span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Updated</span>
                <span class="detail-value" x-text="formatLastUpdate()"></span>
              </div>
            </div>

            <div class="ambient-room-dots">
              <template x-for="(room, index) in rooms" :key="room.id">
                <button class="room-dot-btn" :class="{ active: currentRoomIndex === index }"
                        @click.stop="selectRoom(index)">
                  <div class="dot-circle"></div>
                  <div class="dot-label">
                    <span class="dot-temp" x-text="room.temperature?.toFixed(0) + '¬∞'"></span>
                    <span class="dot-name" x-text="room.name.split(' ')[0]"></span>
                  </div>
                </button>
              </template>
            </div>

            <div class="ambient-hint">
              <span>‚Üê swipe to change room ‚Üí</span>
              <span class="hint-secondary" x-show="isDarkMode">Double-tap for light mode</span>
            </div>

            <div class="auto-rotate-indicator" x-show="autoRotate">üîÑ Auto-rotating</div>
          </div>
        </div>

        <!-- Vision 5: Timeline -->
        <div x-show="currentView === 'timeline'" x-cloak x-data="timelineView()">
          <div class="timeline-view">
            <div class="timeline-header">
              <h2 class="timeline-title">üìñ Today's Climate Story</h2>
              <div class="date-selector">
                <button class="btn btn-secondary" :class="{ active: selectedDate === 'today' }"
                        @click="setDate('today')">Today</button>
                <button class="btn btn-secondary" :class="{ active: selectedDate === 'yesterday' }"
                        @click="setDate('yesterday')">Yesterday</button>
                <button class="btn btn-secondary" :class="{ active: selectedDate === 'week' }"
                        @click="setDate('week')">This Week</button>
              </div>
            </div>

            <template x-if="getTodaySummary()">
              <div class="summary-card">
                <div class="summary-title">üìä Summary</div>
                <div class="summary-grid">
                  <div class="summary-item">
                    <span class="summary-label">Temperature Range</span>
                    <span class="summary-value" x-text="getTodaySummary().minTemp + '¬∞ ‚Äî ' + getTodaySummary().maxTemp + '¬∞'"></span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Most Stable</span>
                    <span class="summary-value" x-text="getTodaySummary().mostStable || '--'"></span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Most Variable</span>
                    <span class="summary-value" x-text="getTodaySummary().mostVolatile || '--'"></span>
                  </div>
                  <div class="summary-item">
                    <span class="summary-label">Events Detected</span>
                    <span class="summary-value" x-text="getTodaySummary().eventCount"></span>
                  </div>
                </div>
              </div>
            </template>

            <div class="timeline-content">
              <div class="timeline-now" x-show="selectedDate === 'today'">
                <div class="now-marker">NOW</div>
                <div class="now-line"></div>
              </div>

              <template x-if="events.length === 0 && !loading">
                <div class="no-events">
                  <span class="no-events-icon">üì≠</span>
                  <span class="no-events-text">No significant events detected</span>
                  <span class="no-events-hint">Events appear when temperature changes rapidly or reaches peaks</span>
                </div>
              </template>

              <template x-if="loading">
                <div class="loading-events">
                  <span class="loading-indicator"></span>
                  <span>Analyzing climate data...</span>
                </div>
              </template>

              <div class="timeline-events">
                <template x-for="event in events" :key="event.time + event.room">
                  <div class="timeline-event" :class="getEventClass(event.type)" @click="openRoom(event.room)">
                    <div class="event-time-marker">
                      <span class="event-time" x-text="formatTime(event.time)"></span>
                      <div class="event-dot"></div>
                    </div>
                    <div class="event-card">
                      <div class="event-header">
                        <span class="event-icon" x-text="event.eventIcon"></span>
                        <span class="event-room-icon" x-text="event.icon"></span>
                        <span class="event-title" x-text="event.title"></span>
                      </div>
                      <template x-if="event.cause">
                        <div class="event-cause">
                          <span class="cause-icon">üí°</span>
                          <span class="cause-text" x-text="'Likely: ' + event.cause.text"></span>
                        </div>
                      </template>
                      <template x-if="event.type === 'RAPID_RISE' || event.type === 'RAPID_DROP'">
                        <div class="event-details">
                          <span x-text="event.value.toFixed(1) + '¬∞ ‚Üí ' + event.endValue.toFixed(1) + '¬∞'"></span>
                          <span class="event-duration" x-text="'(' + event.duration + ' min)'"></span>
                        </div>
                      </template>
                    </div>
                  </div>
                </template>
              </div>

              <div class="timeline-midnight" x-show="selectedDate === 'today'">
                <div class="midnight-line"></div>
                <div class="midnight-label">MIDNIGHT</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 6: Classic Cards View -->
        <div x-show="currentView === 'classic'" x-cloak x-data="classicView()">
          <div class="classic-view">
            <!-- Room Grid -->
            <div class="classic-grid">
              <template x-for="room in rooms" :key="room.id">
                <div class="classic-card" :class="{ 'stale': isStale(room) }" @click="openRoom(room)">
                  <div class="classic-comfort" :class="getComfortClass(room.temperature)"></div>

                  <div class="classic-header">
                    <div class="classic-room-info">
                      <div class="classic-icon" x-text="room.icon"></div>
                      <div class="classic-name" x-text="room.name"></div>
                    </div>
                    <div class="classic-updated" x-text="formatUpdate(room.lastSeen)"></div>
                  </div>

                  <div class="classic-values">
                    <div class="classic-temp">
                      <template x-if="room.temperature !== null">
                        <span><span x-text="room.temperature.toFixed(1)"></span><span class="unit">¬∞</span></span>
                      </template>
                      <template x-if="room.temperature === null">
                        <span class="no-data">--</span>
                      </template>
                    </div>
                    <div class="classic-humidity">
                      <span class="humidity-icon">üíß</span>
                      <template x-if="room.humidity !== null">
                        <span x-text="room.humidity.toFixed(0) + '%'"></span>
                      </template>
                      <template x-if="room.humidity === null">
                        <span>--%</span>
                      </template>
                    </div>
                  </div>

                  <div class="classic-sparkline">
                    <svg :id="'classic-spark-' + room.id" class="sparkline-svg" preserveAspectRatio="none"></svg>
                  </div>
                </div>
              </template>
            </div>

            <!-- Average Card -->
            <div class="classic-average">
              <div class="avg-section">
                <div class="avg-label">Home Average Temperature</div>
                <div class="avg-value">
                  <template x-if="avgTemperature !== null">
                    <span><span x-text="avgTemperature.toFixed(1)"></span><span class="avg-unit">¬∞C</span></span>
                  </template>
                  <template x-if="avgTemperature === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider"></div>
              <div class="avg-section">
                <div class="avg-label">Home Average Humidity</div>
                <div class="avg-value">
                  <template x-if="avgHumidity !== null">
                    <span><span x-text="avgHumidity.toFixed(0)"></span><span class="avg-unit">%</span></span>
                  </template>
                  <template x-if="avgHumidity === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider hidden-mobile"></div>
              <div class="avg-chart">
                <svg id="classic-spark-avg" class="sparkline-svg" preserveAspectRatio="none"></svg>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 7: Lights Control -->
        <div x-show="currentView === 'lights'" x-cloak x-data="lightsView()">
          <div class="lights-view">
            <div class="lights-header">
              <h2>üí° Light Control</h2>
              <p class="lights-subtitle">
                Control your IKEA FLOALT panel lights
                <span class="loading-indicator" x-show="$store.lights.initializing && $store.mqtt.connected"></span>
              </p>
            </div>

            <!-- Initializing overlay -->
            <div class="lights-initializing" x-show="$store.lights.initializing && $store.mqtt.connected" x-transition>
              <span class="loading-indicator loading-lg"></span>
              <span>Loading light states...</span>
            </div>

            <!-- Not connected warning -->
            <div class="lights-warning" x-show="!$store.mqtt.connected">
              <span class="loading-indicator"></span>
              <span>Connecting to MQTT...</span>
            </div>

            <!-- Master Control Toggle -->
            <div class="master-control"
                 :class="{
                   'master-on': $store.lights.list.every(l => l.state === 'ON'),
                   'master-syncing': $store.lights.syncing,
                   'master-disabled': !$store.mqtt.connected || $store.lights.initializing
                 }">
              <div class="master-info">
                <span class="master-icon">üí°</span>
                <div class="master-text">
                  <span class="master-label">Master Control</span>
                  <span class="master-status" x-text="$store.lights.lightsOnCount + ' of ' + $store.lights.list.length + ' lights on'"></span>
                </div>
              </div>
              <button class="light-toggle master-toggle"
                      :class="{ 'toggle-on': $store.lights.list.every(l => l.state === 'ON'), 'toggle-syncing': $store.lights.syncing }"
                      @click="$store.lights.toggleAllLights()"
                      :disabled="$store.lights.syncing || !$store.mqtt.connected || $store.lights.initializing">
                <div class="toggle-track">
                  <div class="toggle-thumb"></div>
                </div>
              </button>
            </div>

            <!-- Light Cards -->
            <div class="lights-grid" :class="{ 'lights-disabled': !$store.mqtt.connected || $store.lights.initializing }">
              <template x-for="light in $store.lights.list" :key="light.id">
                <div class="light-card" :class="{ 'light-on': light.state === 'ON' && light.available, 'light-off': light.state === 'OFF' && light.available, 'light-syncing': light.syncing, 'light-unavailable': !light.available }">
                  <!-- Unavailable overlay -->
                  <div class="light-unavailable-overlay" x-show="!light.available" x-transition.opacity>
                    <span class="unavailable-icon">‚ö°</span>
                    <span class="unavailable-text">Offline</span>
                  </div>
                  <!-- Syncing overlay -->
                  <div class="light-syncing-overlay" x-show="light.syncing && light.available" x-transition.opacity>
                    <span class="loading-indicator"></span>
                  </div>

                  <div class="light-header">
                    <div class="light-info">
                      <span class="light-icon" x-text="light.icon"></span>
                      <div class="light-details">
                        <span class="light-name" x-text="light.name"></span>
                        <span class="light-status">
                          <span x-show="!light.available" class="unavailable-status">Offline</span>
                          <span x-show="light.available && light.syncing" class="syncing-text">Syncing...</span>
                          <span x-show="light.available && !light.syncing" x-text="light.state === 'ON' ? 'On' : 'Off'"></span>
                        </span>
                      </div>
                    </div>
                    <button class="light-toggle" :class="{ 'toggle-on': light.state === 'ON' && light.available, 'toggle-syncing': light.syncing, 'toggle-unavailable': !light.available }"
                            @click="$store.lights.toggleLight(light)" :disabled="light.syncing || !light.available">
                      <div class="toggle-track">
                        <div class="toggle-thumb">
                          <span class="loading-indicator loading-sm" x-show="light.syncing"></span>
                        </div>
                      </div>
                    </button>
                  </div>

                  <!-- Brightness Slider -->
                  <div class="light-control" x-show="light.state === 'ON' && light.available" x-transition
                       :class="{ 'control-disabled': !$store.mqtt.connected || $store.lights.initializing || light.syncing }">
                    <div class="control-row">
                      <label class="control-label">
                        <span class="control-icon">üîÜ</span>
                        Brightness
                      </label>
                      <span class="control-value">
                        <span x-show="light.syncing" class="control-syncing">‚ü≥</span>
                      </span>
                    </div>
                    <div class="slider-wrapper">
                      <input type="range" class="slider brightness-slider" min="1" max="254"
                             x-model="light.brightness"
                             :disabled="!$store.mqtt.connected || $store.lights.initializing"
                             @change="$store.lights.setBrightness(light, $event.target.value)"
                             :style="'background: linear-gradient(90deg, rgba(255,220,180,0.8) 0%, rgba(255,240,210,0.6) ' + (light.brightness / 254 * 100) + '%, rgba(245,245,247,1) ' + (light.brightness / 254 * 100) + '%, rgba(245,245,247,1) 100%)'">
                      <span class="slider-percent" x-text="Math.round(light.brightness / 254 * 100) + '%'"></span>
                    </div>
                  </div>

                  <!-- Color Temperature Slider -->
                  <div class="light-control" x-show="light.state === 'ON' && light.available" x-transition
                       :class="{ 'control-disabled': !$store.mqtt.connected || $store.lights.initializing || light.syncing }">
                    <div class="control-row">
                      <label class="control-label">
                        <span class="control-icon">üå°Ô∏è</span>
                        Color Temp
                      </label>
                      <span class="control-value">
                        <span x-show="light.syncing" class="control-syncing">‚ü≥</span>
                        <span x-text="getColorTempLabel(light.colorTemp)"></span>
                      </span>
                    </div>
                    <input type="range" class="slider colortemp-slider" min="250" max="454"
                           x-model="light.colorTemp"
                           :disabled="!$store.mqtt.connected || $store.lights.initializing"
                           @change="$store.lights.setColorTemp(light, $event.target.value)">
                    <div class="colortemp-labels">
                      <span>Cool</span>
                      <span>Warm</span>
                    </div>
                  </div>

                  <!-- Quick Presets -->
                  <div class="light-presets" x-show="light.state === 'ON' && light.available" x-transition>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'reading')" title="Reading">üìñ</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'relax')" title="Relax">üåÖ</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'bright')" title="Bright">‚òÄÔ∏è</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'night')" title="Night">üåô</button>
                  </div>

                  <!-- Link Quality -->
                  <div class="light-meta">
                    <span class="light-availability" :class="{ 'available': light.available, 'unavailable': !light.available }">
                      <span x-text="light.available ? 'üü¢' : 'üî¥'"></span>
                      <span x-text="light.available ? 'Online' : 'Offline'"></span>
                    </span>
                    <span class="light-linkquality" x-show="light.available" :title="'Link Quality: ' + light.linkquality">
                      üì∂ <span x-text="light.linkquality || '--'"></span>
                    </span>
                    <span class="light-update" x-text="formatLastUpdate(light.lastSeen)"></span>
                  </div>
                </div>
              </template>
            </div>

            <!-- Scene Buttons -->
            <div class="lights-scenes" :class="{ 'lights-disabled': !$store.mqtt.connected || $store.lights.initializing }">
              <h3 class="scenes-title">Quick Scenes</h3>
              <div class="scenes-grid">
                <button class="scene-btn" @click="$store.lights.applyScene('movie')">
                  <span class="scene-icon">üé¨</span>
                  <span class="scene-name">Movie</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('work')">
                  <span class="scene-icon">üíº</span>
                  <span class="scene-name">Work</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('evening')">
                  <span class="scene-icon">üåÜ</span>
                  <span class="scene-name">Evening</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('goodnight')">
                  <span class="scene-icon">üò¥</span>
                  <span class="scene-name">Goodnight</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 8: 3D Floor Plan -->
        <div x-show="currentView === '3d'" x-cloak x-data="threeDView()" x-init="init()">
          <div class="three-d-view">
            <!-- Controls -->
            <div class="three-controls">
              <div class="view-toggle">
                <button class="btn btn-secondary" :class="{ active: viewMode === 'temperature' }"
                        @click="setViewMode('temperature')">üå°Ô∏è Temperature</button>
                <button class="btn btn-secondary" :class="{ active: viewMode === 'humidity' }"
                        @click="setViewMode('humidity')">üíß Humidity</button>
              </div>
            </div>

            <!-- Three.js Container -->
            <div class="three-container" x-ref="threeContainer"></div>

            <!-- View Control Buttons -->
            <div class="three-controls-bar">
              <button class="three-control-btn" :class="{ active: viewMode3D === '3d' }"
                      @click="set3DView()">
                üéÆ 3D View
              </button>
              <button class="three-control-btn" :class="{ active: viewMode3D === 'top' }"
                      @click="setTopView()">
                üìê Top View
              </button>
              <button class="three-control-btn" :class="{ active: !wallsVisible }"
                      @click="toggleWalls()">
                üß± <span x-text="wallsVisible ? 'Hide Walls' : 'Show Walls'"></span>
              </button>
              <button class="three-control-btn" :class="{ active: autoRotate }"
                      @click="toggleAutoRotate()">
                üîÑ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
              </button>
              <button class="three-control-btn" :class="{ active: darkTheme }"
                      @click="toggleDarkTheme()">
                üåô Dark
              </button>
              <div class="zoom-controls">
                <button class="three-control-btn zoom-btn" @click="zoomIn()">‚ûï</button>
                <button class="three-control-btn zoom-btn" @click="zoomOut()">‚ûñ</button>
              </div>
            </div>

            <!-- Legend -->
            <div class="three-legend">
              <div class="legend-title" x-text="viewMode === 'temperature' ? 'Temperature' : 'Humidity'"></div>
              <div class="legend-items">
                <template x-for="item in getLegendItems()" :key="item.label">
                  <div class="legend-item">
                    <div class="legend-color" :style="{ background: item.color }"></div>
                    <span class="legend-label" x-text="item.label"></span>
                  </div>
                </template>
              </div>
            </div>

            <!-- Tip -->
            <div class="three-tip">
              üè† Interactive 3D view of your home ‚Ä¢ Drag to rotate, scroll to zoom
            </div>
          </div>
        </div>

        <!-- Isometric Floor Plan View -->
        <div x-show="currentView === 'isometric'" x-cloak x-data="isometricView()" x-init="init()">
          <div class="isometric-view">
            <!-- Controls -->
            <div class="iso-controls">
              <div class="iso-view-toggle">
                <button class="iso-control-btn" :class="{ active: viewMode === 'temperature' }"
                        @click="setViewMode('temperature')">üå°Ô∏è Temp</button>
                <button class="iso-control-btn" :class="{ active: viewMode === 'humidity' }"
                        @click="setViewMode('humidity')">üíß Humid</button>
              </div>
              <button class="iso-control-btn" :class="{ active: !wallsVisible }"
                      @click="toggleWalls()">
                üß± <span x-text="wallsVisible ? 'Hide Walls' : 'Show Walls'"></span>
              </button>
              <button class="iso-control-btn" :class="{ active: darkTheme }"
                      @click="toggleDarkTheme()">
                üåô Dark
              </button>
              <button class="iso-control-btn" :class="{ active: autoRotate }"
                      @click="toggleAutoRotate()">
                üîÑ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
              </button>
              <button class="iso-control-btn" @click="resetView()">
                üéØ Reset
              </button>
              <div class="iso-zoom-controls">
                <button class="iso-control-btn iso-zoom-btn" @click="zoomOut()">‚ûñ</button>
                <span class="iso-zoom-indicator" x-text="getZoomPercent() + '%'"></span>
                <button class="iso-control-btn iso-zoom-btn" @click="zoomIn()">‚ûï</button>
              </div>
            </div>

            <!-- Isometric Canvas Container -->
            <div class="iso-container" x-ref="isoContainer"></div>

            <!-- Legend -->
            <div class="iso-legend">
              <span class="iso-legend-label" x-text="viewMode === 'temperature' ? 'Cold' : 'Dry'"></span>
              <div class="iso-legend-gradient" :class="{ humidity: viewMode === 'humidity' }"></div>
              <span class="iso-legend-label" x-text="viewMode === 'temperature' ? 'Hot' : 'Humid'"></span>
            </div>

            <!-- Tip -->
            <div class="iso-tip">
              üî∑ Isometric view ‚Ä¢ Drag to pan, scroll to zoom ‚Ä¢ Press I for quick access
            </div>
          </div>
        </div>

        <!-- Vision 9: Sensor Configuration -->
        <div x-show="currentView === 'config'" x-cloak x-data="sensorConfigView()" x-init="init()">
          <div class="sensor-config-container">
            <!-- Sensor Palette (Left Panel) -->
            <div class="sensor-palette">
              <div class="palette-header">
                <span class="palette-title">‚öôÔ∏è Sensors</span>
                <span class="palette-count" x-text="placedCount + '/' + totalCount + ' placed'"></span>
              </div>

              <!-- Search Box -->
              <div class="palette-search">
                <input type="text" placeholder="üîç Search sensors..." x-model="searchQuery">
              </div>

              <!-- Loading State -->
              <div class="palette-loading" x-show="loading">
                <div class="loading-spinner"></div>
                <span>Discovering sensors...</span>
              </div>

              <!-- Empty State -->
              <div class="palette-empty" x-show="!loading && totalCount === 0">
                <span class="empty-icon">üì°</span>
                <span>No sensors found</span>
                <span>Check MQTT connection</span>
              </div>

              <!-- Sensor Groups by Type -->
              <template x-for="(typeSensors, sensorType) in sensorsByType" :key="sensorType">
                <div class="sensor-type-group" x-show="typeSensors.length > 0">
                  <div class="type-header" @click="expandedTypes[sensorType] = !expandedTypes[sensorType]">
                    <span class="type-icon" x-text="getTypeIcon(sensorType)"></span>
                    <span class="type-label" x-text="getTypeLabel(sensorType)"></span>
                    <span class="type-count" x-text="typeSensors.length"></span>
                  </div>
                  <div class="sensor-list" x-show="expandedTypes[sensorType]">
                    <template x-for="sensor in typeSensors" :key="sensor.ieee_address">
                      <div class="sensor-card"
                           :class="{
                             placed: isPlaced(sensor.ieee_address),
                             selected: selectedSensor?.ieee_address === sensor.ieee_address,
                             stale: isStale(sensor.ieee_address)
                           }"
                           draggable="true"
                           @dragstart="startDrag($event, sensor)"
                           @click="selectSensor(sensor)">
                        <div class="sensor-icon"
                             :style="'background-color: ' + getTypeColor(sensor.sensorType)">
                          <span x-text="getTypeIcon(sensor.sensorType)"></span>
                        </div>
                        <div class="sensor-info">
                          <div class="sensor-name" x-text="sensor.friendly_name"></div>
                          <div class="sensor-value" x-text="formatLiveValue(sensor)"></div>
                          <div class="sensor-status">
                            <span class="placed-badge" x-show="isPlaced(sensor.ieee_address)">‚úì Placed</span>
                            <span class="unplaced-badge" x-show="!isPlaced(sensor.ieee_address)">‚óã Unplaced</span>
                            <span class="stale-badge" x-show="isStale(sensor.ieee_address)">‚ö† Stale</span>
                          </div>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </template>

              <!-- Coverage Toggle -->
              <label class="coverage-toggle" x-show="hasCoverageToggle">
                <input type="checkbox" x-model="showCoverage">
                <span>Show motion coverage zones</span>
              </label>
            </div>

            <!-- 3D Canvas -->
            <div class="config-canvas"
                 x-ref="configCanvas"
                 @dragover.prevent="onDragOver($event)"
                 @drop.prevent="onDrop($event)">

              <!-- Control Buttons -->
              <div class="config-controls">
                <button class="control-btn" @click="resetView()" title="Reset View">üîÑ</button>
                <button class="control-btn" @click="toggleTopView()" :class="{ active: isTopView }" title="Top View">üìê</button>
                <button class="control-btn" @click="zoomIn()" title="Zoom In">‚ûï</button>
                <button class="control-btn" @click="zoomOut()" title="Zoom Out">‚ûñ</button>
              </div>

              <!-- Tooltip -->
              <div class="config-tooltip"
                   x-show="tooltip.visible"
                   :style="'left: ' + tooltip.x + 'px; top: ' + tooltip.y + 'px'"
                   x-text="tooltip.text">
              </div>
            </div>

            <!-- Status Bar -->
            <div class="config-status">
              <div class="status-item">
                <span class="status-label">Placed:</span>
                <span class="status-value" x-text="placedCount + '/' + totalCount"></span>
              </div>
              <div class="status-divider"></div>
              <div class="status-item" x-show="selectedSensor">
                <span class="status-label">Selected:</span>
                <span class="status-value" x-text="selectedSensor?.friendly_name || 'None'"></span>
              </div>
              <div class="status-divider" x-show="selectedSensor && selectedRoom"></div>
              <div class="status-item" x-show="selectedRoom">
                <span class="status-label">Room:</span>
                <span class="status-value" x-text="selectedRoom || '-'"></span>
              </div>
              <div style="flex: 1;"></div>
              <button class="reset-btn" @click="resetAllPositions()" title="Remove all sensor placements">
                üóëÔ∏è Reset All
              </button>
              <button class="help-btn" @click="showHelp = !showHelp" title="Help">‚ùì</button>
            </div>
          </div>
        </div>

        <!-- Vision 10: CO2 Monitor -->
        <div x-show="currentView === 'co2'" x-cloak x-data="co2View()" x-init="init()">
          <div class="co2-view">

            <!-- Giant Circular Gauge -->
            <div class="co2-gauge-section">
              <div class="co2-gauge-header">AIR QUALITY</div>
              <div class="co2-gauge">
                <svg viewBox="0 0 200 200" class="co2-gauge-ring">
                  <circle cx="100" cy="100" r="90" class="co2-gauge-bg"/>
                  <circle cx="100" cy="100" r="90"
                          class="co2-gauge-arc"
                          :class="{ pulse: !isStale }"
                          :stroke="co2Color"
                          :stroke-dasharray="gaugeArc"
                          transform="rotate(-90 100 100)"/>
                </svg>
                <div class="co2-gauge-content">
                  <span class="co2-value" :style="{ color: co2Color }" x-text="co2Value ?? '--'"></span>
                  <span class="co2-unit">ppm</span>
                  <span class="co2-status" :style="{ color: co2Color }" x-text="airQualityLevel"></span>
                  <div class="co2-trend" :class="trendDirection" x-show="trendDirection !== 'stable'">
                    <span class="co2-trend-arrow" x-text="trendArrow"></span>
                    <span x-text="trendValue + ' ppm'"></span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Air Quality Dashboard (3 Cards) -->
            <div class="air-quality-dashboard">
              <!-- CO2 Card -->
              <div class="air-quality-card highlight">
                <div class="air-quality-icon">üí®</div>
                <div class="air-quality-label">CO2</div>
                <div class="air-quality-value" :style="{ color: co2Color }" x-text="(co2Value ?? '--') + ' ppm'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: co2Percent + '%', background: co2Color }"></div>
                </div>
                <div class="air-quality-status" x-text="airQualityLevel"></div>
              </div>

              <!-- Temperature Card -->
              <div class="air-quality-card">
                <div class="air-quality-icon">üå°Ô∏è</div>
                <div class="air-quality-label">Temperature</div>
                <div class="air-quality-value" :style="{ color: tempColor }" x-text="temperature !== null ? temperature.toFixed(1) + '¬∞C' : '--'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: tempPercent + '%', background: tempColor }"></div>
                </div>
                <div class="air-quality-status" x-text="tempLevel"></div>
              </div>

              <!-- Humidity Card -->
              <div class="air-quality-card">
                <div class="air-quality-icon">üíß</div>
                <div class="air-quality-label">Humidity</div>
                <div class="air-quality-value" :style="{ color: humidityColor }" x-text="humidity !== null ? Math.round(humidity) + '%' : '--'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: humidityPercent + '%', background: humidityColor }"></div>
                </div>
                <div class="air-quality-status" x-text="humidityLevel"></div>
              </div>
            </div>

            <!-- History Chart -->
            <div class="co2-chart-section">
              <div class="chart-header">
                <div class="chart-title">CO2 History</div>
                <div class="time-range-selector">
                  <template x-for="range in timeRanges" :key="range">
                    <button class="time-range-btn"
                            :class="{ active: timeRange === range }"
                            @click="setTimeRange(range)"
                            x-text="range"></button>
                  </template>
                </div>
              </div>

              <div class="co2-chart-container">
                <div class="chart-loading" x-show="loading">
                  <span class="loading-indicator"></span>
                  Loading history...
                </div>
                <div class="chart-no-data" x-show="!loading && co2History.length === 0">
                  No data in this time range
                </div>
                <svg id="co2-history-chart" class="co2-chart" x-show="!loading && co2History.length > 0"></svg>
              </div>

              <!-- Chart Stats -->
              <div class="chart-stats" x-show="co2History.length > 0">
                <div class="chart-stat">
                  <div class="chart-stat-label">Min</div>
                  <div class="chart-stat-value" x-text="minMax.min + ' ppm'"></div>
                </div>
                <div class="chart-stat">
                  <div class="chart-stat-label">Avg</div>
                  <div class="chart-stat-value" x-text="avgCo2 + ' ppm'"></div>
                </div>
                <div class="chart-stat">
                  <div class="chart-stat-label">Max</div>
                  <div class="chart-stat-value" x-text="minMax.max + ' ppm'"></div>
                </div>
              </div>
            </div>

            <!-- Legend -->
            <div class="co2-legend">
              <div class="legend-item">
                <div class="legend-dot" style="background: #34C759;"></div>
                <span>Excellent (&lt;600)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #30D158;"></div>
                <span>Good (600-1000)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FFD60A;"></div>
                <span>Moderate (1000-1500)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FF9500;"></div>
                <span>Poor (1500-2000)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FF3B30;"></div>
                <span>Bad (&gt;2000)</span>
              </div>
            </div>

            <!-- Footer -->
            <div class="co2-footer">
              <div class="co2-footer-item" :class="{ 'stale-indicator': isStale }">
                <span x-text="isStale ? '‚ö†Ô∏è' : '‚úì'"></span>
                <span x-text="'Last update: ' + formatLastUpdate()"></span>
              </div>
              <div class="co2-footer-item">
                <span>üìç</span>
                <span x-text="sensorRoom"></span>
              </div>
              <div class="co2-footer-item" x-show="co2History.length > 0">
                <span>üìä</span>
                <span x-text="co2History.length + ' readings'"></span>
              </div>
            </div>

            <!-- Ambient Mode Toggle Button -->
            <button class="ambient-toggle" @click="toggleAmbient()">
              üåô Ambient Mode
            </button>

            <!-- Ambient Mode Overlay -->
            <div class="co2-ambient-overlay" :class="{ hidden: !ambientMode }" @click="ambientMode = false">
              <div class="ambient-co2-value" :style="{ color: co2Color }" x-text="co2Value ?? '--'"></div>
              <div class="ambient-co2-unit">ppm</div>
              <div class="ambient-status" :style="{ color: co2Color }" x-text="airQualityLevel"></div>
              <div class="ambient-trend" x-text="trendArrow"></div>
              <div class="ambient-room" x-text="sensorRoom"></div>
              <div class="ambient-hint">Tap anywhere to exit</div>
            </div>

          </div>
        </div>

        <!-- Zigbee Network View -->
        <div x-show="currentView === 'network'" x-cloak x-data="networkView()" x-init="init()">
          <div class="network-view">
            <!-- Controls -->
            <div class="network-controls">
              <button class="network-control-btn" :class="{ active: showSignalRange }"
                      @click="showSignalRange = !showSignalRange">
                üì∂ <span x-text="showSignalRange ? 'Hide Range' : 'Show Range'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: showLabels }"
                      @click="showLabels = !showLabels">
                üè∑Ô∏è <span x-text="showLabels ? 'Hide Labels' : 'Show Labels'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: autoRotate }"
                      @click="toggleAutoRotate()">
                üîÑ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: showWallNumbers }"
                      @click="toggleWallNumbers()">
                üî¢ <span x-text="showWallNumbers ? 'Hide #' : 'Show #'"></span>
              </button>
              <button class="network-control-btn" @click="resetView()">
                üéØ Reset
              </button>
              <div class="network-zoom-controls">
                <button class="network-control-btn network-zoom-btn" @click="zoomOut()">‚ûñ</button>
                <span class="network-zoom-indicator" x-text="getZoomPercent() + '%'"></span>
                <button class="network-control-btn network-zoom-btn" @click="zoomIn()">‚ûï</button>
              </div>
            </div>

            <!-- Network Canvas Container -->
            <div class="network-container" x-ref="networkContainer"></div>

            <!-- Legend -->
            <div class="network-legend">
              <div class="legend-item">
                <div class="legend-badge coordinator">Z</div>
                <span>Zigbee Coordinator</span>
              </div>
              <div class="legend-item">
                <div class="legend-badge router">R</div>
                <span>Zigbee Router</span>
              </div>
              <div class="legend-item">
                <div class="legend-badge end-device">E</div>
                <span>Zigbee End Device</span>
              </div>
            </div>

            <!-- Stats -->
            <div class="network-stats">
              <div class="network-stat">
                <span>üì°</span>
                <span x-text="deviceCount + ' devices'"></span>
              </div>
              <div class="network-stat">
                <span>üîó</span>
                <span x-text="routerCount + ' routers'"></span>
              </div>
              <div class="network-stat">
                <span>üìç</span>
                <span x-text="endDeviceCount + ' end devices'"></span>
              </div>
            </div>
          </div>
        </div>

      </div>
    </main>

    <!-- Footer -->
    <footer class="app-footer" x-show="currentView !== 'ambient'">
      <span class="footer-status">
        <span class="loading-indicator" x-show="$store.mqtt.connecting"></span>
        <span class="status-dot" :class="{ 'connected': $store.mqtt.connected, 'disconnected': !$store.mqtt.connected }" x-show="!$store.mqtt.connecting"></span>
        <span x-text="$store.mqtt.connecting ? 'Connecting...' : ($store.mqtt.connected ? 'Connected' : 'Reconnecting...')"></span>
      </span>
      <span> ‚Ä¢ </span>
      <span x-show="$store.rooms.loading" class="footer-status">
        <span class="loading-indicator"></span>
        <span>Loading history...</span>
      </span>
      <span x-show="!$store.rooms.loading" x-text="$store.rooms.historyCount + ' data points'"></span>
      <span x-show="$store.lights.syncing"> ‚Ä¢ <span class="loading-indicator"></span> Syncing lights...</span>
    </footer>

    <!-- Room Detail Modal -->
    <template x-if="$store.roomDetail.selectedRoom">
      <div class="modal-overlay" @click.self="$store.roomDetail.close()" @keydown.escape.window="$store.roomDetail.close()">
        <div class="modal">
          <div class="modal-header">
            <div class="modal-title">
              <span class="icon" x-text="$store.roomDetail.selectedRoom.icon"></span>
              <h2 x-text="$store.roomDetail.selectedRoom.name"></h2>
            </div>
            <button class="modal-close" @click="$store.roomDetail.close()">&times;</button>
          </div>
          <div class="modal-body">
            <div class="time-range-selector">
              <template x-for="range in $store.roomDetail.timeRanges" :key="range">
                <button class="btn btn-secondary" :class="{ active: $store.roomDetail.timeRange === range }"
                        @click="$store.roomDetail.setTimeRange(range)" x-text="range"></button>
              </template>
              <span x-show="$store.roomDetail.loading" class="loading-indicator"></span>
            </div>

            <div class="modal-stats">
              <div class="modal-stat">
                <div class="modal-stat-label">Temperature</div>
                <div class="modal-stat-value temp"
                     x-text="$store.roomDetail.selectedRoom.temperature !== null
                       ? $store.roomDetail.selectedRoom.temperature.toFixed(1) + '¬∞C' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Humidity</div>
                <div class="modal-stat-value humid"
                     x-text="$store.roomDetail.selectedRoom.humidity !== null
                       ? $store.roomDetail.selectedRoom.humidity.toFixed(0) + '%' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Min / Max</div>
                <div class="modal-stat-value minmax" x-text="$store.roomDetail.getMinMax()"></div>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Temperature History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-temp">
                <template x-if="$store.roomDetail.tempHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-temp" x-show="$store.roomDetail.tempHistory.length > 0"></svg>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Humidity History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-humid">
                <template x-if="$store.roomDetail.humidHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-humid" x-show="$store.roomDetail.humidHistory.length > 0"></svg>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <span x-text="'Last updated: ' + $store.roomDetail.formatUpdate($store.roomDetail.selectedRoom.lastSeen)"></span>
            <span> ‚Ä¢ </span>
            <span x-text="$store.roomDetail.tempHistory.length + ' temperature readings, ' + $store.roomDetail.humidHistory.length + ' humidity readings'"></span>
          </div>
        </div>
      </div>
    </template>

  </div>

  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <!-- Stub for co2View - provides initial state and reactive getters -->
  <script>
    window.co2View = function() {
      return {
        // CO2 Thresholds (ppm)
        thresholds: { excellent: 600, good: 1000, moderate: 1500, poor: 2000 },

        // State
        timeRange: '6h',
        timeRanges: ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d'],
        loading: false,
        co2History: [],
        tempHistory: [],
        humidHistory: [],
        trendDirection: 'stable',
        trendValue: 0,
        ambientMode: false,
        _moduleLoaded: false,

        // Reactive getters that access the store directly
        get co2Sensor() {
          const sensors = this.$store?.sensors;
          if (!sensors?.devices) return null;
          return sensors.devices.find(d =>
            d.friendly_name?.toLowerCase().includes('co2') && d.sensorType === 'co2'
          );
        },
        get liveData() {
          if (!this.co2Sensor) return null;
          return this.$store?.sensors?.getLiveData?.(this.co2Sensor.ieee_address) ?? null;
        },
        get co2Value() { return this.liveData?.co2 ?? null; },
        get temperature() { return this.liveData?.temperature ?? null; },
        get humidity() { return this.liveData?.humidity ?? null; },
        get airQualityLevel() {
          const co2 = this.co2Value;
          if (co2 === null) return 'unknown';
          if (co2 < this.thresholds.excellent) return 'excellent';
          if (co2 < this.thresholds.good) return 'good';
          if (co2 < this.thresholds.moderate) return 'moderate';
          if (co2 < this.thresholds.poor) return 'poor';
          return 'bad';
        },
        get co2Color() {
          const colors = { excellent: '#34C759', good: '#30D158', moderate: '#FFD60A', poor: '#FF9500', bad: '#FF3B30', unknown: '#AEAEB2' };
          return colors[this.airQualityLevel];
        },
        get gaugeArc() {
          const maxPPM = 2500;
          const value = Math.min(this.co2Value || 0, maxPPM);
          const percent = value / maxPPM;
          const circumference = 2 * Math.PI * 90;
          return `${percent * circumference} ${circumference}`;
        },
        get tempLevel() {
          const temp = this.temperature;
          if (temp === null) return 'unknown';
          if (temp < 18) return 'cold';
          if (temp < 20) return 'cool';
          if (temp <= 26) return 'comfortable';
          if (temp <= 28) return 'warm';
          return 'hot';
        },
        get tempColor() {
          const colors = { cold: '#90CAF9', cool: '#A5D6A7', comfortable: '#81C784', warm: '#FFE082', hot: '#EF5350', unknown: '#AEAEB2' };
          return colors[this.tempLevel];
        },
        get humidityLevel() {
          const h = this.humidity;
          if (h === null) return 'unknown';
          if (h < 30) return 'dry';
          if (h < 40) return 'low';
          if (h <= 60) return 'optimal';
          if (h <= 70) return 'high';
          return 'humid';
        },
        get humidityColor() {
          const colors = { dry: '#FFCC80', low: '#A5D6A7', optimal: '#81C784', high: '#90CAF9', humid: '#5C6BC0', unknown: '#AEAEB2' };
          return colors[this.humidityLevel];
        },
        get isStale() {
          if (!this.co2Sensor) return true;
          return this.$store?.sensors?.isStale?.(this.co2Sensor.ieee_address) ?? true;
        },
        get trendArrow() {
          if (this.trendDirection === 'rising') return '\u2191';
          if (this.trendDirection === 'falling') return '\u2193';
          return '\u2192';
        },
        get sensorRoom() {
          if (!this.co2Sensor) return 'Unknown';
          const name = this.co2Sensor.friendly_name || '';
          const match = name.match(/\[([^\]]+)\]/);
          return match ? match[1] + ' Room' : 'Room';
        },
        get minMax() {
          if (this.co2History.length === 0) return { min: '--', max: '--' };
          const values = this.co2History.map(d => d.value);
          return { min: Math.round(Math.min(...values)), max: Math.round(Math.max(...values)) };
        },
        get avgCo2() {
          if (this.co2History.length === 0) return '--';
          const sum = this.co2History.reduce((acc, d) => acc + d.value, 0);
          return Math.round(sum / this.co2History.length);
        },
        get co2Percent() { return Math.min(100, ((this.co2Value || 0) / 2500) * 100); },
        get tempPercent() { return Math.min(100, Math.max(0, ((this.temperature || 20) - 15) / 20 * 100)); },
        get humidityPercent() { return Math.min(100, Math.max(0, this.humidity || 0)); },

        // Methods
        init() {
          console.log('[co2-view] Stub initialized, waiting for module...');
          window._co2ViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          if (window._co2ViewMethods && !this._moduleLoaded) {
            console.log('[co2-view] Module methods available, enhancing...');
            this._moduleLoaded = true;
            // Only copy methods, not getters (getters are already defined above)
            const methods = window._co2ViewMethods;
            if (methods.loadHistoricalData) this.loadHistoricalData = methods.loadHistoricalData.bind(this);
            if (methods.queryInflux) this.queryInflux = methods.queryInflux.bind(this);
            if (methods.setTimeRange) this.setTimeRange = methods.setTimeRange.bind(this);
            if (methods.drawChart) this.drawChart = methods.drawChart.bind(this);
            if (methods.drawThresholdZones) this.drawThresholdZones = methods.drawThresholdZones.bind(this);
            if (methods.formatTimeLabel) this.formatTimeLabel = methods.formatTimeLabel.bind(this);
            if (methods.calculateTrend) this.calculateTrend = methods.calculateTrend.bind(this);
            if (methods.formatLastUpdate) this.formatLastUpdate = methods.formatLastUpdate.bind(this);
            // Load historical data now
            this.loadHistoricalData();
          } else if (!this._moduleLoaded) {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        loadHistoricalData() { console.log('[co2-view] Stub loadHistoricalData (waiting for module)'); },
        setTimeRange(range) { this.timeRange = range; },
        drawChart() {},
        calculateTrend() {},
        formatLastUpdate() { return 'No data'; },
        toggleAmbient() { this.ambientMode = !this.ambientMode; },
        destroy() {}
      };
    };
  </script>

  <!-- Stub for sensorConfigView - reactive stub that pulls from Alpine store -->
  <script>
    window.sensorConfigView = function() {
      return {
        searchQuery: '',
        expandedTypes: { climate: true, co2: true, motion: true, contact: true },
        showHelp: false,
        isTopView: false,
        showCoverage: false,
        tooltip: { text: '', visible: false, x: 0, y: 0 },
        selectedSensor: null,

        init() {
          console.log('[sensor-config] Stub initialized, waiting for Three.js module...');
          // Store reference for module to find and enhance
          window._sensorConfigComponent = this;
          this._checkForThreeJS();
        },

        _checkForThreeJS() {
          if (window._initSensorConfigThreeJS) {
            console.log('[sensor-config] Three.js module ready, initializing 3D view...');
            window._initSensorConfigThreeJS(this);
          } else {
            // Keep checking until module loads
            setTimeout(() => this._checkForThreeJS(), 100);
          }
        },

        // Reactive getters that pull from sensors store
        get loading() { return Alpine.store('sensors')?.loading ?? true; },
        get placedCount() { return Alpine.store('sensors')?.placedCount ?? 0; },
        get totalCount() { return Alpine.store('sensors')?.totalCount ?? 0; },
        get sensors() { return Alpine.store('sensors')?.devices ?? []; },
        get positions() { return Alpine.store('sensors')?.positions ?? {}; },
        get selectedRoom() {
          if (!this.selectedSensor) return null;
          return Alpine.store('sensors')?.getPosition(this.selectedSensor.ieee_address)?.roomId || null;
        },
        get hasCoverageToggle() {
          return this.sensors.some(s => s.sensorType === 'motion');
        },
        get sensorsByType() {
          const sensors = this.sensors;
          const grouped = { climate: [], co2: [], motion: [], contact: [] };
          sensors.forEach(sensor => {
            const type = sensor.sensorType || 'climate';
            if (grouped[type]) {
              if (!this.searchQuery ||
                  sensor.friendly_name.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                  type.includes(this.searchQuery.toLowerCase())) {
                grouped[type].push(sensor);
              }
            }
          });
          return grouped;
        },

        // Helper methods
        getTypeIcon(type) { return { climate: 'üå°Ô∏è', co2: 'üí®', motion: 'üëÅÔ∏è', contact: 'üö™' }[type] || 'üì°'; },
        getTypeLabel(type) { return { climate: 'Temperature & Humidity', co2: 'CO‚ÇÇ Sensors', motion: 'Motion Sensors', contact: 'Contact Sensors' }[type] || 'Unknown'; },
        getTypeColor(type) { return { climate: '#34d399', co2: '#ff6b6b', motion: '#ffd93d', contact: '#38bdf8' }[type] || '#888'; },

        formatLiveValue(sensor) {
          const data = Alpine.store('sensors')?.getLiveData(sensor.ieee_address);
          if (!data) return '--';
          switch (sensor.sensorType) {
            case 'climate':
              const temp = data.temperature !== undefined ? `${data.temperature.toFixed(1)}¬∞` : '--';
              const hum = data.humidity !== undefined ? `${Math.round(data.humidity)}%` : '';
              return `${temp} ${hum}`.trim();
            case 'co2': return data.co2 !== undefined ? `${data.co2} ppm` : '--';
            case 'motion': return data.occupancy !== undefined ? (data.occupancy ? 'üî¥ Motion' : '‚ö™ Clear') : '--';
            case 'contact': return data.contact !== undefined ? (data.contact ? 'üîí Closed' : 'üîì Open') : '--';
            default: return '--';
          }
        },
        isPlaced(ieee) { return Alpine.store('sensors')?.isPlaced(ieee) || false; },
        isStale(ieee) { return Alpine.store('sensors')?.isStale(ieee) || false; },

        selectSensor(sensor) {
          this.selectedSensor = this.selectedSensor?.ieee_address === sensor.ieee_address ? null : sensor;
          if (window._sensorConfigController) {
            window._sensorConfigController.selectedSensor = this.selectedSensor?.ieee_address;
          }
        },
        startDrag(e, sensor) {
          e.dataTransfer?.setData('sensor-ieee', sensor.ieee_address);
          this.selectedSensor = sensor;
          // Start drag in Three.js controller
          if (window._sensorConfigController?.startDragFromPalette) {
            window._sensorConfigController.startDragFromPalette(sensor.ieee_address);
          }
        },
        onDragOver(e) {
          e.preventDefault();
          // Check if dragging a sensor
          if (!e.dataTransfer?.types?.includes('sensor-ieee')) return;

          const controller = window._sensorConfigController;
          const container = e.currentTarget;
          if (!controller || !container) return;

          // Calculate normalized mouse position
          const rect = container.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

          // Update preview position
          if (controller.updateDragPreview) {
            controller.updateDragPreview(x, y);
          }
        },
        onDragLeave(e) {
          // Hide preview when leaving canvas
          const threeState = window._configThreeState;
          if (threeState?.dragPreview) {
            threeState.dragPreview.visible = false;
          }
        },
        onDrop(e) {
          e.preventDefault();
          const ieee = e.dataTransfer?.getData('sensor-ieee');
          if (!ieee) return;

          const controller = window._sensorConfigController;
          const container = e.currentTarget;
          if (!controller || !container) return;

          // Calculate normalized mouse position for raycasting
          const rect = container.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

          // Use controller to handle the drop
          if (controller.handlePaletteDrop) {
            controller.handlePaletteDrop(ieee, x, y);
          }
        },
        resetView() {
          if (window._sensorConfigController?.onResize) {
            window._sensorConfigController.onResize();
          }
        },
        toggleTopView() {
          this.isTopView = !this.isTopView;
          // Could adjust camera angle via controller
        },
        zoomIn() {
          // Zoom via Three.js camera if available
          console.log('[stub] zoomIn');
        },
        zoomOut() {
          console.log('[stub] zoomOut');
        },
        resetAllPositions() { Alpine.store('sensors')?.resetAllPositions(); },
        toggleCoverage() {
          this.showCoverage = !this.showCoverage;
          if (window._sensorConfigController?.toggleCoverage) {
            window._sensorConfigController.toggleCoverage();
          }
        }
      };
    };
  </script>

  <!-- Alpine.js is now imported as ES module in js/app.js -->

  <!-- CO2 Monitor Module - enhances the stub with methods -->
  <script type="module">
    import { co2View } from './views/co2-monitor.js?v=3';

    // Get the module object and extract only the methods (not getters)
    const moduleObj = co2View();
    window._co2ViewMethods = {
      loadHistoricalData: moduleObj.loadHistoricalData,
      queryInflux: moduleObj.queryInflux,
      setTimeRange: moduleObj.setTimeRange,
      drawChart: moduleObj.drawChart,
      drawThresholdZones: moduleObj.drawThresholdZones,
      formatTimeLabel: moduleObj.formatTimeLabel,
      calculateTrend: moduleObj.calculateTrend,
      formatLastUpdate: moduleObj.formatLastUpdate
    };
    console.log('[co2-monitor] Module loaded, methods ready');

    // If stub component exists, trigger enhancement
    if (window._co2ViewComponent && !window._co2ViewComponent._moduleLoaded) {
      console.log('[co2-monitor] Stub found, enhancing with methods...');
      window._co2ViewComponent._checkForModule();
    }
  </script>

  <!-- Sensor Config Module - loads after Alpine, enhances the stub -->
  <script type="module">
    import { sensorConfigView } from './views/sensor-config.js?v=3';
    import { initSensorsStore } from './js/stores/sensors-store.js';
    import { FLOOR_PLAN_CONFIG, SENSOR_VISUALS } from './js/config.js';

    // Create a Three.js controller that will manage the 3D view
    // This is separate from Alpine's reactive system to avoid proxy issues
    const threeJSController = sensorConfigView(FLOOR_PLAN_CONFIG, SENSOR_VISUALS, THREE.OrbitControls);

    // Store controller globally for stub access
    window._sensorConfigThreeJS = threeJSController;

    // Expose initialization function for stub to call
    // Guard against multiple initializations
    let initializationComplete = false;

    window._initSensorConfigThreeJS = function(alpineComponent) {
      // Prevent multiple initializations
      if (initializationComplete) {
        console.log('[sensor-config] Already initialized, skipping');
        return;
      }
      console.log('[sensor-config] Initializing Three.js controller...');

      // The controller needs access to Alpine component for $refs
      const container = alpineComponent.$refs?.configCanvas;
      if (!container) {
        console.error('[sensor-config] Container ref not found, retrying...');
        setTimeout(() => window._initSensorConfigThreeJS(alpineComponent), 100);
        return;
      }

      // Create proxy object that gives controller access to container
      const controllerContext = {
        $refs: { configCanvas: container },
        tooltip: alpineComponent.tooltip,
        selectedSensor: null,
        showMotionCoverage: false
      };

      // Bind all controller methods to the proxy context
      Object.keys(threeJSController).forEach(key => {
        if (typeof threeJSController[key] === 'function') {
          controllerContext[key] = threeJSController[key].bind(controllerContext);
        }
      });

      // Store the bound controller for stub methods to use
      window._sensorConfigController = controllerContext;

      // Add custom drop handler for palette drops
      controllerContext.handlePaletteDrop = function(ieee, mouseX, mouseY) {
        const threeState = window._configThreeState;

        // Hide drag preview
        if (threeState?.dragPreview) {
          threeState.dragPreview.visible = false;
        }

        // Re-enable controls
        if (threeState?.controls) {
          threeState.controls.enabled = true;
        }

        if (!threeState?.raycaster || !threeState?.camera || !threeState?.floorPlane) {
          console.error('[sensor-config] Three.js state not ready for drop', {
            raycaster: !!threeState?.raycaster,
            camera: !!threeState?.camera,
            floorPlane: !!threeState?.floorPlane
          });
          return;
        }

        // Set mouse position for raycaster
        const mouse = new THREE.Vector2(mouseX, mouseY);
        threeState.raycaster.setFromCamera(mouse, threeState.camera);

        // Raycast to floor plane
        const intersects = threeState.raycaster.intersectObject(threeState.floorPlane);
        if (intersects.length === 0) {
          console.log('[sensor-config] Drop missed floor plane');
          return;
        }

        const point = intersects[0].point;
        const sensor = Alpine.store('sensors').getSensor(ieee);
        if (!sensor) {
          console.error('[sensor-config] Sensor not found:', ieee);
          return;
        }

        const visuals = window.SENSOR_VISUALS?.[sensor.sensorType] || window.SENSOR_VISUALS?.climate;
        const position = {
          x: point.x,
          y: visuals?.heightAboveFloor || 1.5,
          z: point.z
        };

        // Detect which room using bound detectRoom method
        const roomId = controllerContext.detectRoom ? controllerContext.detectRoom(point.x, point.z) : null;

        // Save position to store (persists via MQTT)
        Alpine.store('sensors').savePosition(ieee, position, roomId);
        console.log('[sensor-config] Sensor placed:', ieee, 'at', position, 'in', roomId);
      };

      // Update preview position during drag-over
      controllerContext.updateDragPreview = function(mouseX, mouseY) {
        const threeState = window._configThreeState;
        if (!threeState?.raycaster || !threeState?.camera || !threeState?.floorPlane) return;

        // Raycast to floor plane
        const mouse = new THREE.Vector2(mouseX, mouseY);
        threeState.raycaster.setFromCamera(mouse, threeState.camera);
        const intersects = threeState.raycaster.intersectObject(threeState.floorPlane);

        if (intersects.length === 0) {
          // Hide preview if not over floor
          if (threeState.dragPreview) threeState.dragPreview.visible = false;
          return;
        }

        const point = intersects[0].point;

        // Create preview sphere if not exists
        if (!threeState.dragPreview) {
          const geometry = new THREE.SphereGeometry(0.15, 16, 16);
          const material = new THREE.MeshBasicMaterial({
            color: 0x34d399,  // Green
            transparent: true,
            opacity: 0.8
          });
          threeState.dragPreview = new THREE.Mesh(geometry, material);
          threeState.scene.add(threeState.dragPreview);
        }

        // Update preview position
        threeState.dragPreview.visible = true;
        threeState.dragPreview.position.set(point.x, 1.5, point.z);

        // Color based on validity (green = valid room, red = invalid)
        const roomId = controllerContext.detectRoom ? controllerContext.detectRoom(point.x, point.z) : null;
        threeState.dragPreview.material.color.setHex(roomId ? 0x34d399 : 0xff6b6b);
      };

      // Custom initialization that waits for container to be visible
      function initThreeJS() {
        const c = container;
        if (!c || c.clientWidth === 0 || c.clientHeight === 0) {
          // Container not visible yet (view hidden), retry
          setTimeout(initThreeJS, 200);
          return;
        }

        console.log('[sensor-config] Container ready, initializing Three.js...');
        try {
          controllerContext.initScene();
          controllerContext.initCamera(c, THREE.OrbitControls);
          controllerContext.initRenderer(c);
          controllerContext.initLighting();
          controllerContext.initRaycaster();
          controllerContext.buildFloorPlan();
          controllerContext.setupEventListeners(c);
          controllerContext.animate();
          initializationComplete = true;
          console.log('[sensor-config] Three.js initialization complete!');
        } catch (e) {
          console.error('[sensor-config] Three.js init error:', e);
        }
      }

      initThreeJS();
    };
    console.log('[sensor-config] Module loaded, _initSensorConfigThreeJS ready');

    // Replace stub for any future component creations
    window.sensorConfigView = function() {
      return sensorConfigView(FLOOR_PLAN_CONFIG, SENSOR_VISUALS, THREE.OrbitControls);
    };

    // Initialize sensors store
    function initSensors() {
      const CONFIG = window.CONFIG;
      if (typeof Alpine !== 'undefined' && CONFIG) {
        if (!Alpine.store('sensors')) {
          initSensorsStore(Alpine, CONFIG);
          console.log('[sensor-config] Sensors store initialized');
        }
        // Initialize MQTT subscriptions
        setTimeout(() => {
          const sensorsStore = Alpine.store('sensors');
          if (sensorsStore && Alpine.store('mqtt')?.client) {
            sensorsStore.init();
            console.log('[sensor-config] Sensors MQTT subscriptions initialized');
          }
        }, 2000);
      }
    }

    // Try to initialize
    if (typeof Alpine !== 'undefined') {
      initSensors();
    } else {
      document.addEventListener('alpine:init', () => {
        initSensorsStore(Alpine, window.CONFIG);
      });
      document.addEventListener('DOMContentLoaded', initSensors);
    }
  </script>

  <script>
    // ========================================
    // CONFIGURATION
    // ========================================
    const CONFIG = {
      mqttUrl: 'ws://' + window.location.hostname + ':9001',
      baseTopic: 'zigbee2mqtt',
      influxUrl: '/api/influx',
      influxDb: 'homeassistant',
      rooms: [
        { id: 'living', name: 'Living Room', icon: 'üõãÔ∏è', sensor: '[Living] Temperature & Humidity', entityId: 'sensor.living_temperature_humidity' },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', sensor: '[Bed] Temperature & Humidity Sensor', entityId: 'sensor.bed_temperature_humidity_sensor' },
        { id: 'study', name: 'Study', icon: 'üìö', sensor: '[Study] Temperature & Humidity', entityId: 'sensor.study_temperature_humidity' },
        { id: 'kitchen', name: 'Kitchen', icon: 'üç≥', sensor: '[Kitchen] Temperature & Humidity', entityId: 'sensor.kitchen_temperature_humidity' },
        { id: 'bathroom', name: 'Bathroom', icon: 'üöø', sensor: '[Bath] Temperature & Humidity', entityId: 'sensor.bath_temperature_humidity' },
        { id: 'balcony', name: 'Balcony', icon: 'üåø', sensor: '[Balcony] Temperature & Humidity', entityId: 'sensor.balcony_temperature_humidity' }
      ],
      staleThreshold: 5 * 60 * 1000,
      maxHistoryPoints: 500,
      historyHours: 6
    };
    // Make CONFIG globally available for modules
    window.CONFIG = CONFIG;

    // Alpine stores and app() are now in js/app.js (imports from js/stores/*.js)
    // CONFIG is kept here for compatibility with inline view components

    // ========================================
    // VIEW COMPONENTS (to be extracted in Phase 4)
    // ========================================

    // Placeholder - stores removed, now provided by js/stores/*.js modules
    // Placeholder - app() removed, now provided by js/app.js

    // ========================================
    // ZIGBEE NETWORK VIEW
    // Warm beige monochromatic visualization
    // ========================================

    const networkState = {
      scene: null,
      camera: null,
      renderer: null,
      roomMeshes: {},
      wallMeshes: [],
      wallNumberSprites: [],
      deviceMeshes: {},
      labelElements: {},
      signalElements: {},
      animationId: null,
      isInitialized: false,
      panOffset: { x: 0, z: 0 },
      isPanning: false,
      lastPanPos: { x: 0, y: 0 }
    };

    // Device configuration with types and icons
    const ZIGBEE_DEVICES = [
      { id: 'coordinator', name: 'ZBBridge-P', type: 'coordinator', icon: 'üì°', room: 'living', x: 0.5, z: 0.4 },
      { id: 'router1', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'study', x: 0.8, z: 0.2 },
      { id: 'router2', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'living', x: 0.3, z: 0.3 },
      { id: 'sensor1', name: 'SNZB-02P', type: 'end-device', icon: 'üå°Ô∏è', room: 'bedroom', x: 0.2, z: 0.15 },
      { id: 'sensor2', name: 'SNZB-03P', type: 'end-device', icon: 'üö∂', room: 'kitchen', x: 0.5, z: 0.1 },
      { id: 'sensor3', name: 'SNZB-04P', type: 'end-device', icon: 'üö™', room: 'bathroom', x: 0.85, z: 0.1 },
      { id: 'trv', name: 'TRVZB', type: 'end-device', icon: 'üî•', room: 'bedroom', x: 0.1, z: 0.25 },
    ];

    function networkView() {
      const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
      const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

      return {
        showSignalRange: false,
        showLabels: false,
        showWallNumbers: false,
        autoRotate: false,
        rotationAngle: 0,
        zoomLevel: 2.0,
        deviceCount: ZIGBEE_DEVICES.length,
        routerCount: ZIGBEE_DEVICES.filter(d => d.type === 'router').length,
        endDeviceCount: ZIGBEE_DEVICES.filter(d => d.type === 'end-device').length,

        init() {
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.networkContainer;
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          if (networkState.isInitialized && networkState.renderer) {
            if (!container.contains(networkState.renderer.domElement)) {
              container.appendChild(networkState.renderer.domElement);
            }
            this.createLabels(container);
            this.onResize();
            return;
          }

          if (networkState.renderer) networkState.renderer.dispose();
          if (networkState.scene) networkState.scene.clear();
          if (networkState.animationId) cancelAnimationFrame(networkState.animationId);

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.addWallNumbers();
          this.createDevices();
          this.createLabels(container);
          this.setupPanControls(container);
          this.animate();
          networkState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          networkState.scene = new THREE.Scene();
          // Warm beige gradient background
          networkState.scene.background = new THREE.Color(0xE8DFD4);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15;
          networkState.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2, 0.1, 1000
          );
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
        },

        initRenderer(container) {
          networkState.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
          networkState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          networkState.renderer.shadowMap.enabled = true;
          networkState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(networkState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.7);
          networkState.scene.add(ambient);
          const directional = new THREE.DirectionalLight(0xffffff, 0.6);
          directional.position.set(15, 20, 15);
          directional.castShadow = false;  // No shadows anywhere
          networkState.scene.add(directional);
          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          networkState.scene.add(fill);
        },

        addWallNumbers() {
          // Clear existing wall number sprites
          networkState.wallNumberSprites.forEach(sprite => {
            networkState.scene.remove(sprite);
            if (sprite.material.map) sprite.material.map.dispose();
            sprite.material.dispose();
          });
          networkState.wallNumberSprites = [];

          // Add number labels at start, middle, end of each wall for precise identification
          const createNumberSprite = (text, color = '#FF0000') => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(String(text), 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(0.4, 0.4, 1);
            return sprite;
          };

          // Direction labels by POSITION (reliable regardless of wall creation order)
          // Outer walls are identified by: edge position + full length
          const getOuterWallDirection = (wall) => {
            const apartmentWidth = FLOOR_PLAN_CONFIG.apartmentWidth;   // 9.239
            const apartmentDepth = FLOOR_PLAN_CONFIG.apartmentDepth;   // 7.665
            const halfW = apartmentWidth / 2;  // 4.6195
            const halfD = apartmentDepth / 2;  // 3.8325
            const tolerance = 0.05;  // Position tolerance (5cm) - outer walls are at exact edges
            const lengthTolerance = 0.2;  // Length must be within 20cm of full apartment dimension

            const params = wall.geometry.parameters;
            const isHorizontal = params.width > params.depth;  // Runs along X axis
            const isVertical = params.depth > params.width;    // Runs along Z axis

            let result = null;

            // Check for full-length horizontal walls (North/South)
            // In isometric view: z=-halfD appears at TOP (North), z=+halfD at BOTTOM (South)
            if (isHorizontal && Math.abs(params.width - apartmentWidth) < lengthTolerance) {
              if (Math.abs(wall.position.z - (-halfD)) < tolerance) result = 'N';  // Top edge
              else if (Math.abs(wall.position.z - halfD) < tolerance) result = 'S';  // Bottom edge
            }

            // Check for full-length vertical walls (West/East)
            // In isometric view: x=-halfW appears at LEFT (West), x=+halfW at RIGHT (East)
            if (isVertical && Math.abs(params.depth - apartmentDepth) < lengthTolerance) {
              if (Math.abs(wall.position.x - (-halfW)) < tolerance) result = 'W';  // Left edge
              else if (Math.abs(wall.position.x - halfW) < tolerance) result = 'E';  // Right edge
            }

            return result;
          };

          networkState.wallMeshes.forEach((wall, index) => {
            const geom = wall.geometry;
            const params = geom.parameters;
            const wx = wall.position.x;
            const wy = wall.position.y + 0.5;
            const wz = wall.position.z;

            // Check if this is an outer wall with direction label (by position)
            const directionLabel = getOuterWallDirection(wall);

            // Determine if wall is horizontal (along X) or vertical (along Z)
            const isHorizontal = params.width > params.depth;
            const wallLength = isHorizontal ? params.width : params.depth;
            const halfLen = wallLength / 2 * 0.8; // 80% to stay within wall bounds

            // Create 3 sprites: start, middle, end
            const positions = isHorizontal
              ? [[wx - halfLen, wy, wz], [wx, wy, wz], [wx + halfLen, wy, wz]]
              : [[wx, wy, wz - halfLen], [wx, wy, wz], [wx, wy, wz + halfLen]];

            positions.forEach((pos, i) => {
              // Use direction label (N/S/E/W) for outer walls, index number for inner walls
              const label = directionLabel || index.toString();
              // Green for direction labels, Red/Blue for numbered walls
              const color = directionLabel ? '#228B22' : (i === 1 ? '#FF0000' : '#0066CC');
              const sprite = createNumberSprite(label, color);
              sprite.position.set(pos[0], pos[1], pos[2]);
              sprite.visible = false;  // Hidden by default
              networkState.scene.add(sprite);
              networkState.wallNumberSprites.push(sprite);
            });
          });
        },

        toggleWallNumbers() {
          this.showWallNumbers = !this.showWallNumbers;
          networkState.wallNumberSprites.forEach(sprite => {
            sprite.visible = this.showWallNumbers;
          });
        },

        /**
         * WALL INDEX REFERENCE (Fully consolidated walls)
         * =================================================
         * Walls are pushed to networkState.wallMeshes in this EXACT order:
         *
         * FIRST: Room walls via createRoom() for each room in config order:
         *   Study:    0=left (back‚Üínorth wall, front skipped, right‚Üíeast wall)
         *   Living:   (none - all consolidated)
         *   Bedroom:  1=right divider (back skipped, left‚Üíwest wall, front‚Üísouth wall)
         *   Kitchen:  (none - all consolidated)
         *   Bathroom: 2=front (back‚Üínorth wall, left‚Üíwest wall, right‚Üíeast wall)
         *
         * THEN: Consolidated walls created in buildFloorPlan():
         *   3 = Study‚ÜîLiving horizontal divider
         *   4 = Coat hanging wall (hallway, 30% from north)
         *   5 = North wall (z=0, full apartment width)
         *   6 = West wall (x=0, full apartment depth)
         *   7 = East wall upper (Bathroom+Kitchen right, z=0 to z=3.697)
         *   8 = East wall lower (Study+Living right, z=0 to z=7.665)
         *   9 = South wall (full apartment width at z=7.665)
         *
         * TOTAL: 10 walls (indices 0-9)
         */
        buildFloorPlan() {
          networkState.wallMeshes = [];
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;  // 4.6195
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;  // 3.8325
          const floorColor = 0xC9B89A;  // Warm beige (same as rooms)

          // Base floor covering entire apartment (fills all gaps)
          const baseFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(FLOOR_PLAN_CONFIG.apartmentWidth + 2, FLOOR_PLAN_CONFIG.apartmentDepth + 2),
            new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 })
          );
          baseFloor.rotation.x = -Math.PI / 2;
          baseFloor.position.set(0, 0.001, 0);  // Lowest level, centered
          baseFloor.receiveShadow = true;
          networkState.scene.add(baseFloor);

          // Build rooms (each room has its own floor and outer walls)
          // NOTE: This runs FIRST, creating walls 0-15
          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            this.createRoom(config);
          });

          // Interior divider walls (created AFTER room walls, so these are walls 16-17)
          const wallHeight = 0.8;
          const wallMat = new THREE.MeshStandardMaterial({ color: 0xB5A080, roughness: 0.7, transparent: true, opacity: 0.6 });

          // Get room references
          const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
          const living = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'living');
          const kitchen = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'kitchen');
          const bedroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bedroom');
          const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');

          // Wall 3: Study ‚Üî Living (horizontal divider wall with 2 door openings)
          // Moved 0.5m towards study (into study area)
          const studyFrontZ = study.z + study.depth/2 - 0.5;  // 3.197 (moved towards study)

          // Door openings (0.42m wide each - reduced 30%)
          const doorWidth = 0.42;
          const door4X = 3.8;  // Bedroom ‚Üî Hallway (west door)
          const door2X = 4.8;  // Living ‚Üî Hallway (east door)

          const door4Left = door4X - doorWidth/2;   // 3.2
          const door4Right = door4X + doorWidth/2;  // 3.8
          const door2Left = door2X - doorWidth/2;   // 4.5
          const door2Right = door2X + doorWidth/2;  // 5.1

          // Left segment: from west edge (0) to door4 left edge
          const wall3LeftWidth = door4Left;
          const wall3Left = new THREE.Mesh(new THREE.BoxGeometry(wall3LeftWidth, wallHeight, 0.08), wallMat);
          wall3Left.position.set(door4Left/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Left);
          networkState.wallMeshes.push(wall3Left);

          // Middle segment: from door4 right edge to door2 left edge
          const wall3MidWidth = door2Left - door4Right;  // 4.5 - 3.8 = 0.7
          const wall3Mid = new THREE.Mesh(new THREE.BoxGeometry(wall3MidWidth, wallHeight, 0.08), wallMat);
          wall3Mid.position.set(door4Right + wall3MidWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Mid);
          networkState.wallMeshes.push(wall3Mid);

          // Right segment: from door2 right edge to east edge
          const wall3RightWidth = FLOOR_PLAN_CONFIG.apartmentWidth - door2Right;
          const wall3Right = new THREE.Mesh(new THREE.BoxGeometry(wall3RightWidth, wallHeight, 0.08), wallMat);
          wall3Right.position.set(door2Right + wall3RightWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Right);
          networkState.wallMeshes.push(wall3Right);

          // Wall 2: Kitchen ‚Üî Bedroom - REMOVED (was wall index 17)
          // This interior divider was redundant - bedroom's back wall already defines the boundary

          // Wall 4: Coat hanging wall in hallway (30% from north towards Study‚ÜîLiving divider)
          const wall16Z = 0;  // North connector position
          const wall15Z = study.z + study.depth/2;  // 3.697 (Study‚ÜîLiving divider)
          const coatWallLength = (wall15Z - wall16Z) * 0.30;  // 30% of distance ‚âà 1.1m
          const coatWallCenterZ = wall16Z + coatWallLength / 2;  // Start from wall 16

          // Position towards study (middle of hallway-study boundary)
          const coatWallX = 4.6;  // Moved from hallway center (3.839) towards study

          const coatWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, coatWallLength), wallMat);
          coatWall.position.set(coatWallX - centerX, wallHeight/2, coatWallCenterZ - centerZ);
          networkState.scene.add(coatWall);
          networkState.wallMeshes.push(coatWall);

          // Wall 5: North wall (consolidated from Study back + connector + Bathroom back)
          // Split into 2 segments with main entry door at x=3.5
          const mainDoorX = 4.0;
          const mainDoorWidth = 0.42;
          const mainDoorLeft = mainDoorX - mainDoorWidth/2;  // 3.29
          const mainDoorRight = mainDoorX + mainDoorWidth/2;  // 3.71

          // Segment 1: x=0 to door left edge (west side)
          const northSeg1Width = mainDoorLeft;  // 3.29
          const northWall1 = new THREE.Mesh(new THREE.BoxGeometry(northSeg1Width, wallHeight, 0.08), wallMat);
          northWall1.position.set(northSeg1Width/2 - centerX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall1);
          networkState.wallMeshes.push(northWall1);

          // Segment 2: door right edge to apartment east edge (east side)
          const northSeg2Width = FLOOR_PLAN_CONFIG.apartmentWidth - mainDoorRight;  // 9.239 - 3.71 = 5.529
          const northSeg2CenterX = (mainDoorRight + FLOOR_PLAN_CONFIG.apartmentWidth) / 2 - centerX;
          const northWall2 = new THREE.Mesh(new THREE.BoxGeometry(northSeg2Width, wallHeight, 0.08), wallMat);
          northWall2.position.set(northSeg2CenterX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall2);
          networkState.wallMeshes.push(northWall2);

          // Wall 7: West wall (full depth, equal to Wall 9)
          const westWallDepth = FLOOR_PLAN_CONFIG.apartmentDepth;  // 7.665 (same as Wall 9)
          const westWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, westWallDepth), wallMat);
          westWall.position.set(-centerX, wallHeight/2, 0);  // Centered in z
          networkState.scene.add(westWall);
          networkState.wallMeshes.push(westWall);

          // Wall 10: East wall upper (Bathroom+Kitchen right consolidated)
          // Split into 3 segments with 2 door openings: bathroom (z=0.7) and kitchen (z=2.5)
          const wall10X = bathroom.x + bathroom.width/2;  // Right edge of bathroom/kitchen area (3.15)
          const wall10DoorWidth = 0.42;

          // Bathroom door at z=0.7
          const bathDoorZ = 0.7;
          const bathDoorTop = bathDoorZ - wall10DoorWidth/2;  // 0.49
          const bathDoorBottom = bathDoorZ + wall10DoorWidth/2;  // 0.91

          // Kitchen door at z=2.5
          const kitchenDoorZ = 2.5;
          const kitchenDoorTop = kitchenDoorZ - wall10DoorWidth/2;  // 2.29
          const kitchenDoorBottom = kitchenDoorZ + wall10DoorWidth/2;  // 2.71

          // Segment 1: z=0 to bathroom door top
          const wall10Seg1Depth = bathDoorTop;  // 0.49
          const eastWallUpper1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg1Depth), wallMat);
          eastWallUpper1.position.set(wall10X - centerX, wallHeight/2, wall10Seg1Depth/2 - centerZ);
          networkState.scene.add(eastWallUpper1);
          networkState.wallMeshes.push(eastWallUpper1);

          // Segment 2: bathroom door bottom to kitchen door top
          const wall10Seg2Depth = kitchenDoorTop - bathDoorBottom;  // 2.29 - 0.91 = 1.38
          const wall10Seg2CenterZ = (bathDoorBottom + kitchenDoorTop) / 2 - centerZ;
          const eastWallUpper2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg2Depth), wallMat);
          eastWallUpper2.position.set(wall10X - centerX, wallHeight/2, wall10Seg2CenterZ);
          networkState.scene.add(eastWallUpper2);
          networkState.wallMeshes.push(eastWallUpper2);

          // Segment 3: kitchen door bottom to studyFrontZ
          const wall10Seg3Depth = studyFrontZ - kitchenDoorBottom;  // 3.197 - 2.71 = 0.487
          const wall10Seg3CenterZ = (kitchenDoorBottom + studyFrontZ) / 2 - centerZ;
          const eastWallUpper3 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg3Depth), wallMat);
          eastWallUpper3.position.set(wall10X - centerX, wallHeight/2, wall10Seg3CenterZ);
          networkState.scene.add(eastWallUpper3);
          networkState.wallMeshes.push(eastWallUpper3);

          // Wall 9: East wall lower (Study+Living right consolidated)
          // From z=0 to z=7.665 (full depth) at x = study/living right edge (apartment east edge)
          const wall9X = FLOOR_PLAN_CONFIG.apartmentWidth;  // 9.239 (east edge)
          const wall9Depth = FLOOR_PLAN_CONFIG.apartmentDepth;  // 7.665
          const eastWallLower = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall9Depth), wallMat);
          eastWallLower.position.set(wall9X - centerX, wallHeight/2, 0);  // Centered in z
          networkState.scene.add(eastWallLower);
          networkState.wallMeshes.push(eastWallLower);

          // Wall 10: South wall (Bedroom+Living front consolidated)
          // Full apartment width at z=7.665 (south edge)
          const wall10Z = FLOOR_PLAN_CONFIG.apartmentDepth;  // 7.665
          const wall10Width = FLOOR_PLAN_CONFIG.apartmentWidth;  // 9.239
          const southWall = new THREE.Mesh(new THREE.BoxGeometry(wall10Width, wallHeight, 0.08), wallMat);
          southWall.position.set(0, wallHeight/2, wall10Z - centerZ);  // x centered, z at south edge
          networkState.scene.add(southWall);
          networkState.wallMeshes.push(southWall);

          // Door X markers - adding from FLOOR_PLAN_CONFIG.doors
          const doorMarkerMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
          const markerSize = 0.3;
          const markerThickness = 0.05;
          const markerHeight = 0.02;

          // Helper function to add door marker
          const addDoorMarker = (x, z) => {
            const posX = x - centerX;
            const posZ = z - centerZ;

            // Bar 1 (diagonal \)
            const bar1 = new THREE.Mesh(
              new THREE.BoxGeometry(markerSize, markerHeight, markerThickness),
              doorMarkerMat
            );
            bar1.rotation.y = Math.PI / 4;
            bar1.position.set(posX, markerHeight/2, posZ);
            networkState.scene.add(bar1);

            // Bar 2 (diagonal /)
            const bar2 = new THREE.Mesh(
              new THREE.BoxGeometry(markerSize, markerHeight, markerThickness),
              doorMarkerMat
            );
            bar2.rotation.y = -Math.PI / 4;
            bar2.position.set(posX, markerHeight/2, posZ);
            networkState.scene.add(bar2);
          };

          // Door 2: Living ‚Üî Hallway - on Wall 3 (Study‚ÜîLiving divider at z=3.197)
          addDoorMarker(4.8, 3.197);

          // Door 3: Study door - on Wall 0 (study's left wall at x=5.331)
          addDoorMarker(5.331, 2.5);

          // Door 4: Bedroom ‚Üî Hallway - on Wall 3 (at x=3.8)
          addDoorMarker(3.8, 3.197);

          // Door 5: Kitchen door - on wall 10 (east wall upper at x=3.15)
          addDoorMarker(3.15, 2.5);

          // Door 6: Bathroom door - on wall 10 (east wall upper at x=3.15)
          addDoorMarker(3.15, 0.7);

          // Door 7: Main Entry - on north wall (z=0)
          addDoorMarker(4.0, 0);
        },

        createRoom(config) {
          const group = new THREE.Group();
          const floorColor = 0xC9B89A;  // Warm beige
          const wallColor = 0xB5A080;
          const wallHeight = 0.8;

          // Correct center coordinates (x,z are already center positions)
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const rx = config.x - centerX;
          const rz = config.z - centerZ;

          // Room floor at correct position
          const floorGeom = new THREE.PlaneGeometry(config.width, config.depth);
          const floorMat = new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 });
          const floor = new THREE.Mesh(floorGeom, floorMat);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(rx, 0.01, rz);
          floor.receiveShadow = true;
          group.add(floor);

          // Helipad-style room label on floor
          const helipadSize = Math.min(config.width, config.depth) * 0.6;
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');

          // Outer circle
          ctx.strokeStyle = 'rgba(90, 70, 50, 0.4)';
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.arc(128, 128, 110, 0, Math.PI * 2);
          ctx.stroke();

          // Inner circle
          ctx.strokeStyle = 'rgba(90, 70, 50, 0.3)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(128, 128, 85, 0, Math.PI * 2);
          ctx.stroke();

          // Room name text
          ctx.fillStyle = 'rgba(90, 70, 50, 0.5)';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(config.name.toUpperCase(), 128, 128);

          const helipadTexture = new THREE.CanvasTexture(canvas);
          const helipadGeom = new THREE.PlaneGeometry(helipadSize, helipadSize);
          const helipadMat = new THREE.MeshBasicMaterial({
            map: helipadTexture,
            transparent: true,
            depthWrite: false
          });
          const helipad = new THREE.Mesh(helipadGeom, helipadMat);
          helipad.rotation.x = -Math.PI / 2;
          helipad.position.set(rx, 0.02, rz);
          group.add(helipad);

          // Create all 4 walls automatically
          const halfW = config.width / 2;
          const halfD = config.depth / 2;
          const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.7, transparent: true, opacity: 0.6 });

          // Back wall (north) - skip for all rooms at z=0 edge (consolidated into single north wall)
          // Only bathroom has a front wall (interior divider at z=1.504)
          // Study, Living, Bedroom, Kitchen, Bathroom back walls are all consolidated
          if (false) {  // All back walls consolidated into single north wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
            backWall.position.set(rx, wallHeight/2, rz - halfD);
            group.add(backWall);
            networkState.wallMeshes.push(backWall);
          }

          // Front wall (south) - skip for study, kitchen, bedroom, living (consolidated into single south wall)
          if (config.id !== 'study' && config.id !== 'kitchen' && config.id !== 'bedroom' && config.id !== 'living') {
            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
            frontWall.position.set(rx, wallHeight/2, rz + halfD);
            group.add(frontWall);
            networkState.wallMeshes.push(frontWall);
          }

          // Left wall (west) - skip for living room and west-edge rooms (single west wall created in buildFloorPlan)
          const roomAtWestEdge = ['bathroom', 'kitchen', 'bedroom'].includes(config.id);
          if (config.id !== 'living' && !roomAtWestEdge) {
            // For study, use studyFrontZ (3.197) to join Wall 3
            // Split into 2 segments with door opening at z=1.85
            if (config.id === 'study') {
              const studyObj = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
              const studyFrontZ = studyObj.z + studyObj.depth/2 - 0.5;  // 3.197 (joins Wall 3)
              const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

              // Door opening parameters
              const doorZ = 2.5;  // Door center position (towards living room)
              const doorWidth = 0.42;  // Same as other doors
              const doorTop = doorZ - doorWidth/2;  // 1.64
              const doorBottom = doorZ + doorWidth/2;  // 2.06

              // Segment 1: from z=0 to door top edge
              const seg1Depth = doorTop;  // 1.64
              const seg1CenterZ = seg1Depth/2 - centerZ;
              const leftWall1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, seg1Depth), wallMat);
              leftWall1.position.set(rx - halfW, wallHeight/2, seg1CenterZ);
              leftWall1.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall1);
              networkState.wallMeshes.push(leftWall1);

              // Segment 2: from door bottom edge to studyFrontZ
              const seg2Depth = studyFrontZ - doorBottom;  // 3.197 - 2.06 = 1.137
              const seg2CenterZ = (doorBottom + studyFrontZ)/2 - centerZ;
              const leftWall2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, seg2Depth), wallMat);
              leftWall2.position.set(rx - halfW, wallHeight/2, seg2CenterZ);
              leftWall2.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall2);
              networkState.wallMeshes.push(leftWall2);
            } else {
              const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
              leftWall.position.set(rx - halfW, wallHeight/2, rz);
              leftWall.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall);
              networkState.wallMeshes.push(leftWall);
            }
          }

          // Right wall (east) - skip for rooms using consolidated east walls
          // Bathroom, Kitchen ‚Üí consolidated into east wall upper (Wall 8)
          // Study, Living ‚Üí consolidated into east wall lower (Wall 9)
          // Only Bedroom keeps its individual right wall (divider between bedroom and living)
          const roomsWithConsolidatedEastWall = ['bathroom', 'kitchen', 'study', 'living'];
          if (!roomsWithConsolidatedEastWall.includes(config.id)) {
            if (config.id === 'bedroom') {
              // Bedroom's right wall (Wall 1) serves as divider between bedroom and living
              // Extends from studyFrontZ (z=3.197) to south edge (z=7.665) - joins Wall 3
              const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
              const wall15Z = study.z + study.depth/2 - 0.5;  // 3.197 (same as Wall 3, joins it)
              const bedroomFrontZ = config.z + config.depth/2;  // 7.665 (apartment south edge)
              const extendedDepth = bedroomFrontZ - wall15Z;  // 4.468 (extended to join Wall 3)
              const extendedCenterZ = (wall15Z + bedroomFrontZ) / 2 - FLOOR_PLAN_CONFIG.apartmentDepth / 2;

              // Position moved towards living room (increased x by 0.8m)
              const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');
              const wall7X = bathroom.x + bathroom.width/2 + 0.8 - FLOOR_PLAN_CONFIG.apartmentWidth / 2;

              const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, extendedDepth), wallMat);
              rightWall.position.set(wall7X, wallHeight/2, extendedCenterZ);
              group.add(rightWall);
              networkState.wallMeshes.push(rightWall);
            } else {
              // Default right wall for any other rooms
              const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
              rightWall.position.set(rx + halfW, wallHeight/2, rz);
              group.add(rightWall);
              networkState.wallMeshes.push(rightWall);
            }
          }

          // Furniture
          this.createFurniture(group, config, rx, rz);

          networkState.scene.add(group);
          networkState.roomMeshes[config.id] = { group, floor, config };
        },

        createFurniture(group, config, rx, rz) {
          const furnitureColor = 0xBFA98A;
          const furnitureMat = new THREE.MeshStandardMaterial({ color: furnitureColor, roughness: 0.6 });

          if (config.id === 'bedroom') {
            // Bed
            const bedGeom = new THREE.BoxGeometry(1.4, 0.3, 2.0);
            const bed = new THREE.Mesh(bedGeom, furnitureMat);
            bed.position.set(rx - config.width/4, 0.15, rz);
            group.add(bed);
          } else if (config.id === 'living') {
            // Sofa
            const sofaGeom = new THREE.BoxGeometry(2.0, 0.4, 0.8);
            const sofa = new THREE.Mesh(sofaGeom, furnitureMat);
            sofa.position.set(rx, 0.2, rz + config.depth/4);
            group.add(sofa);
          } else if (config.id === 'study') {
            // Desk
            const deskGeom = new THREE.BoxGeometry(1.2, 0.5, 0.6);
            const desk = new THREE.Mesh(deskGeom, furnitureMat);
            desk.position.set(rx + config.width/4, 0.25, rz - config.depth/4);
            group.add(desk);
          }
        },

        createDevices() {
          networkState.deviceMeshes = {};
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

          ZIGBEE_DEVICES.forEach(device => {
            // Create device marker (sphere)
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            let color;
            switch (device.type) {
              case 'coordinator': color = 0xFF6B6B; break;
              case 'router': color = 0x4DABF7; break;
              default: color = 0x51CF66;
            }
            const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geometry, material);

            // Position based on room (room.x, room.z are center coords)
            const room = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === device.room);
            if (room) {
              const roomCenterX = room.x - centerX;
              const roomCenterZ = room.z - centerZ;  // FIX: use z not y
              mesh.position.set(
                roomCenterX + (device.x - 0.5) * room.width * 0.8,
                0.5,
                roomCenterZ + (device.z - 0.5) * room.depth * 0.8
              );
            }

            mesh.castShadow = true;
            networkState.scene.add(mesh);
            networkState.deviceMeshes[device.id] = { mesh, config: device };
          });
        },

        createLabels(container) {
          // Clear existing labels
          Object.values(networkState.labelElements).forEach(el => el?.remove());
          Object.values(networkState.signalElements).forEach(el => el?.remove());
          networkState.labelElements = {};
          networkState.signalElements = {};

          ZIGBEE_DEVICES.forEach(device => {
            // Device label
            const label = document.createElement('div');
            label.className = 'device-label visible';
            label.innerHTML = `
              <div class="device-icon ${device.type}">${device.icon}</div>
              <div class="device-name">${device.name}</div>
            `;
            container.appendChild(label);
            networkState.labelElements[device.id] = label;

            // Signal range circle (for coordinator and routers)
            if (device.type === 'coordinator' || device.type === 'router') {
              const signal = document.createElement('div');
              signal.className = `signal-range ${device.type}`;
              signal.style.width = device.type === 'coordinator' ? '200px' : '150px';
              signal.style.height = device.type === 'coordinator' ? '200px' : '150px';
              container.appendChild(signal);
              networkState.signalElements[device.id] = signal;
            }
          });
        },

        updateLabels() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;

          ZIGBEE_DEVICES.forEach(device => {
            const deviceData = networkState.deviceMeshes[device.id];
            const label = networkState.labelElements[device.id];
            const signal = networkState.signalElements[device.id];

            if (!deviceData || !label) return;

            const pos = deviceData.mesh.position.clone();
            pos.y += 0.3;
            pos.project(networkState.camera);

            const x = (pos.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-pos.y * 0.5 + 0.5) * container.clientHeight;

            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.style.display = this.showLabels ? 'flex' : 'none';

            if (signal) {
              signal.style.left = x + 'px';
              signal.style.top = (y + 40) + 'px';
              signal.style.display = this.showSignalRange ? 'block' : 'none';
            }
          });
        },

        setupPanControls(container) {
          container.addEventListener('pointerdown', (e) => {
            if (this.autoRotate) return;
            networkState.isPanning = true;
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
            container.style.cursor = 'grabbing';
          });

          container.addEventListener('pointermove', (e) => {
            if (!networkState.isPanning) return;
            const dx = e.clientX - networkState.lastPanPos.x;
            const dy = e.clientY - networkState.lastPanPos.y;
            networkState.panOffset.x -= dx * 0.02;
            networkState.panOffset.z -= dy * 0.02;
            networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
          });

          container.addEventListener('pointerup', () => {
            networkState.isPanning = false;
            container.style.cursor = 'grab';
          });

          container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.setZoom(this.zoomLevel * delta);
          }, { passive: false });
        },

        setZoom(level) {
          this.zoomLevel = Math.max(0.5, Math.min(3.0, level));
          this.updateCameraZoom();
        },

        updateCameraZoom() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
        },

        zoomIn() { this.setZoom(this.zoomLevel * 1.2); },
        zoomOut() { this.setZoom(this.zoomLevel / 1.2); },

        resetView() {
          this.zoomLevel = 1.0;
          this.autoRotate = false;
          this.rotationAngle = Math.PI / 4;
          networkState.panOffset = { x: 0, z: 0 };
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
          this.updateCameraZoom();
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (this.autoRotate) {
            const pos = networkState.camera.position;
            this.rotationAngle = Math.atan2(pos.x, pos.z);
          }
        },

        animate() {
          const self = this;
          const radius = 17.32;
          const height = 10;

          function loop() {
            networkState.animationId = requestAnimationFrame(loop);

            if (self.autoRotate && networkState.camera) {
              self.rotationAngle += 0.003;
              const x = Math.sin(self.rotationAngle) * radius;
              const z = Math.cos(self.rotationAngle) * radius;
              networkState.camera.position.set(x, height, z);
              networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            }

            self.updateLabels();
            if (networkState.renderer && networkState.scene && networkState.camera) {
              networkState.renderer.render(networkState.scene, networkState.camera);
            }
          }
          loop();
        },

        onResize() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera || !networkState.renderer) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        getZoomPercent() { return Math.round(this.zoomLevel * 100); }
      };
    }
  </script>
</body>
</html>
