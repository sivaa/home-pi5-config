<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Home Climate</title>

  <!-- FOIT Prevention: Set theme before any CSS loads -->
  <script>
    (function() {
      const stored = localStorage.getItem('dashboard-theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      let theme = 'light';
      if (stored === 'dark' || (stored === 'system' && prefersDark) || (!stored && prefersDark)) {
        theme = 'dark';
      }
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.setAttribute('data-theme-preference', stored || 'system');
    })();
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Modularized CSS -->
  <link rel="stylesheet" href="styles/base.css">
  <link rel="stylesheet" href="styles/layout.css?v=2">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/views/classic.css">

  <!-- Three.js for 3D Floor Plan -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // OrbitControls for Three.js r128 (inline to ensure compatibility)
    THREE.OrbitControls = function(object, domElement) {
      this.object = object;
      this.domElement = domElement;
      this.target = new THREE.Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.autoRotate = false;
      this.autoRotateSpeed = 2.0;

      var scope = this;
      var spherical = new THREE.Spherical();
      var sphericalDelta = new THREE.Spherical();
      var scale = 1;
      var panOffset = new THREE.Vector3();
      var rotateStart = new THREE.Vector2();
      var rotateEnd = new THREE.Vector2();
      var rotateDelta = new THREE.Vector2();
      var panStart = new THREE.Vector2();
      var panEnd = new THREE.Vector2();
      var panDelta = new THREE.Vector2();
      var dollyStart = new THREE.Vector2();
      var dollyEnd = new THREE.Vector2();
      var dollyDelta = new THREE.Vector2();

      var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
      var state = STATE.NONE;

      this.update = function() {
        var offset = new THREE.Vector3();
        var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
        var quatInverse = quat.clone().invert();
        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        return function update() {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state === STATE.NONE) sphericalDelta.theta -= 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping) scope.target.addScaledVector(panOffset, scope.dampingFactor);
          else scope.target.add(panOffset);
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping) {
            sphericalDelta.theta *= (1 - scope.dampingFactor);
            sphericalDelta.phi *= (1 - scope.dampingFactor);
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          return false;
        };
      }();

      function onPointerDown(event) {
        if (event.pointerType === 'touch') {
          // Skip for now - simplified
        } else {
          onMouseDown(event);
        }
      }

      function onPointerMove(event) {
        if (event.pointerType === 'touch') {
          // Skip for now - simplified
        } else {
          onMouseMove(event);
        }
      }

      function onPointerUp(event) {
        state = STATE.NONE;
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener('pointermove', onPointerMove);
        scope.domElement.removeEventListener('pointerup', onPointerUp);
      }

      function onMouseDown(event) {
        event.preventDefault();
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener('pointermove', onPointerMove);
        scope.domElement.addEventListener('pointerup', onPointerUp);
        if (event.button === 0) {
          state = STATE.ROTATE;
          rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === 2) {
          state = STATE.PAN;
          panStart.set(event.clientX, event.clientY);
        }
      }

      function onMouseMove(event) {
        if (state === STATE.ROTATE) {
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(0.005);
          sphericalDelta.theta -= rotateDelta.x;
          sphericalDelta.phi -= rotateDelta.y;
          rotateStart.copy(rotateEnd);
        } else if (state === STATE.PAN) {
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart).multiplyScalar(0.02);
          var v = new THREE.Vector3();
          v.setFromMatrixColumn(scope.object.matrix, 0);
          v.multiplyScalar(-panDelta.x);
          panOffset.add(v);
          v.setFromMatrixColumn(scope.object.matrix, 1);
          v.multiplyScalar(panDelta.y);
          panOffset.add(v);
          panStart.copy(panEnd);
        }
      }

      function onMouseWheel(event) {
        event.preventDefault();
        if (event.deltaY < 0) scale /= 0.95;
        else if (event.deltaY > 0) scale *= 0.95;
      }

      function onContextMenu(event) {
        event.preventDefault();
      }

      this.domElement.addEventListener('pointerdown', onPointerDown);
      this.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
      this.domElement.addEventListener('contextmenu', onContextMenu);

      this.dispose = function() {
        scope.domElement.removeEventListener('pointerdown', onPointerDown);
        scope.domElement.removeEventListener('wheel', onMouseWheel);
        scope.domElement.removeEventListener('contextmenu', onContextMenu);
      };

      this.update();
    };
  </script>
</head>
<body>
  <div class="app-container" x-data="app()" x-init="init()">

    <!-- Unified Header with Navigation -->
    <header class="app-header" x-data="navigation()" x-init="init()"
            @keydown.window="handleKeydown($event)"
            @keydown.escape.window="moreMenuOpen = false">
      <div class="header-content">
        <!-- Left: Logo + Status + Nav -->
        <div class="header-nav">
          <span class="header-logo">üè†</span>
          <div class="status-badge"
               :class="{ 'disconnected': !$store.mqtt.connected && !$store.mqtt.connecting, 'connecting': $store.mqtt.connecting }">
            <span class="loading-indicator loading-sm" x-show="$store.mqtt.connecting"></span>
            <span class="status-dot-header" x-show="!$store.mqtt.connecting" :class="{ 'connected': $store.mqtt.connected }"></span>
            <span x-text="$store.mqtt.connecting ? 'Connecting' : ($store.mqtt.connected ? 'Live' : 'Offline')"></span>
          </div>

          <!-- Navigation tabs - all views in single line -->
          <div class="nav-primary">
            <template x-for="view in allViews" :key="view.id">
              <button class="nav-tab"
                      :class="{ active: currentView === view.id }"
                      @click="setView(view.id)"
                      :title="view.title + ' (' + view.key + ')'">
                <span class="nav-icon" x-text="view.icon"></span>
                <span class="nav-label" x-text="view.name"></span>
              </button>
            </template>
          </div>

        </div>

        <!-- Right: Theme Toggle + Date/Time -->
        <div class="header-right">
          <div class="header-top">
            <!-- Theme Toggle -->
            <div class="theme-toggle" x-data>
              <button class="theme-toggle-btn"
                      :class="{ active: $store.theme.preference === 'light' }"
                      @click="$store.theme.setPreference('light')"
                      title="Light mode">‚òÄÔ∏è</button>
              <button class="theme-toggle-btn"
                      :class="{ active: $store.theme.preference === 'dark' }"
                      @click="$store.theme.setPreference('dark')"
                      title="Dark mode">üåô</button>
              <button class="theme-toggle-btn"
                      :class="{ active: $store.theme.preference === 'system' }"
                      @click="$store.theme.setPreference('system')"
                      title="System preference">‚öôÔ∏è</button>
            </div>
            <div class="date-time" x-text="currentDateTime"></div>
            <button class="panel-toggle"
                    @click="togglePanel()"
                    :title="panelOpen ? 'Hide overview panel' : 'Show overview panel'">
              <span x-text="panelOpen ? '¬ª' : '¬´'"></span>
            </button>
          </div>
          <div class="last-update" x-text="'Last update: ' + lastUpdateText"></div>
        </div>
      </div>
    </header>

    <!-- Main Content + Overview Panel -->
    <div class="app-body">
    <main class="app-main">
      <div class="view-container">

        <!-- Vision 6: Classic Cards View - Multi-Sensor -->
        <div x-show="currentView === 'classic'" x-cloak x-data="classicView()">
          <div class="classic-view">
            <!-- Room Grid -->
            <div class="classic-grid">
              <template x-for="room in rooms" :key="room.id">
                <div class="classic-card-v2"
                     :class="{
                       'has-co2': room.sensors && room.sensors.some(s => s.type === 'co2')
                     }">

                  <!-- Comfort indicator strip -->
                  <div class="classic-comfort-strip" :class="{
                    'cold': (room.avgTemperature || room.temperature) < 20,
                    'cool': (room.avgTemperature || room.temperature) >= 20 && (room.avgTemperature || room.temperature) < 23,
                    'good': (room.avgTemperature || room.temperature) >= 23 && (room.avgTemperature || room.temperature) <= 26,
                    'warm': (room.avgTemperature || room.temperature) > 26 && (room.avgTemperature || room.temperature) <= 28,
                    'hot': (room.avgTemperature || room.temperature) > 28
                  }"></div>

                  <!-- Card Header -->
                  <div class="classic-header-v2">
                    <div class="room-title">
                      <span class="room-icon" x-text="room.icon"></span>
                      <span class="room-name" x-text="room.name"></span>
                    </div>
                  </div>

                  <!-- Average Values - Prominent Display -->
                  <div class="room-averages-section">
                    <div class="avg-temp-display">
                      <span x-text="room.avgTemperature != null ? room.avgTemperature.toFixed(1) : (room.temperature != null ? room.temperature.toFixed(1) : '--')"></span>
                      <span class="avg-unit">¬∞C</span>
                      <span class="trend-indicator" :class="'trend-' + $store.rooms.getTempTrend(room)" x-text="$store.rooms.getTempTrend(room) === 'rising' ? '‚ñ≤' : ($store.rooms.getTempTrend(room) === 'falling' ? '‚ñº' : '')"></span>
                    </div>
                    <div class="avg-humid-display">
                      <span class="humid-icon">üíß</span>
                      <span x-text="room.avgHumidity != null ? room.avgHumidity.toFixed(0) + '%' : (room.humidity != null ? room.humidity.toFixed(0) + '%' : '--%')"></span>
                      <span class="trend-indicator" :class="'trend-' + $store.rooms.getHumidTrend(room)" x-text="$store.rooms.getHumidTrend(room) === 'rising' ? '‚ñ≤' : ($store.rooms.getHumidTrend(room) === 'falling' ? '‚ñº' : '')"></span>
                    </div>
                  </div>

                  <!-- Sensor List - show if multiple sensors OR has CO2/special sensors -->
                  <div class="sensor-list" x-show="room.sensors && (room.sensors.length > 1 || room.sensors.some(s => s.type === 'co2'))">
                    <template x-for="sensor in (room.sensors || [])" :key="sensor.name + '-' + sensor.type">
                      <div class="sensor-row" :class="{ 'stale': !sensor.lastSeen || (Date.now() - sensor.lastSeen > 300000), 'no-data': sensor.temperature == null && sensor.co2 == null }">
                        <span class="sensor-icon" x-text="sensor.type === 'motion' ? 'üëÅ' : (sensor.type === 'contact' ? '‚óØ' : '')"></span>
                        <span class="sensor-label" x-text="sensor.label + (sensor.type === 'thermostat' ? ' ‚ñ≥' : '')"></span>
                        <template x-if="sensor.type === 'climate' || !sensor.type">
                          <div class="sensor-values">
                            <span class="sensor-temp" x-text="sensor.temperature != null ? sensor.temperature.toFixed(1) + '¬∞' : '--¬∞'"></span>
                            <span class="sensor-humid" x-show="sensor.humidity != null">üíß<span x-text="sensor.humidity ? sensor.humidity.toFixed(0) + '%' : ''"></span></span>
                          </div>
                        </template>
                        <template x-if="sensor.type === 'thermostat'">
                          <div class="sensor-values">
                            <span class="sensor-temp" x-text="sensor.temperature != null ? sensor.temperature.toFixed(1) + '¬∞' : '--¬∞'"></span>
                          </div>
                        </template>
                        <template x-if="sensor.type === 'co2'">
                          <div class="sensor-values">
                            <span class="sensor-co2" x-text="sensor.co2 != null ? sensor.co2 + ' ppm' : '-- ppm'"></span>
                          </div>
                        </template>
                        <span class="sensor-status" :class="{ 'fresh': sensor.lastSeen && (Date.now() - sensor.lastSeen <= 300000) && (sensor.temperature != null || sensor.co2 != null), 'stale': !sensor.lastSeen || (Date.now() - sensor.lastSeen > 300000) || (sensor.temperature == null && sensor.co2 == null) }"></span>
                      </div>
                    </template>
                  </div>

                  <!-- Sparkline -->
                  <div class="classic-sparkline">
                    <svg :id="'classic-spark-' + room.id" class="sparkline-svg" preserveAspectRatio="none"></svg>
                  </div>

                  <!-- Card Footer -->
                  <div class="card-footer-v2">
                    <span class="temp-spread" x-show="room.tempSpread && room.tempSpread >= 0.1">
                      Spread: <span x-text="room.tempSpread ? '¬±' + (room.tempSpread / 2).toFixed(1) + '¬∞' : ''"></span>
                    </span>
                    <button class="detail-btn" @click.stop="$store.roomDetail.open(room)">Details</button>
                  </div>
                </div>
              </template>
            </div>

            <!-- Average Card -->
            <div class="classic-average">
              <div class="avg-section">
                <div class="avg-label">Home Average Temperature</div>
                <div class="avg-value">
                  <template x-if="avgTemperature !== null">
                    <span><span x-text="avgTemperature.toFixed(1)"></span><span class="avg-unit">¬∞C</span></span>
                  </template>
                  <template x-if="avgTemperature === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider"></div>
              <div class="avg-section">
                <div class="avg-label">Home Average Humidity</div>
                <div class="avg-value">
                  <template x-if="avgHumidity !== null">
                    <span><span x-text="avgHumidity.toFixed(0)"></span><span class="avg-unit">%</span></span>
                  </template>
                  <template x-if="avgHumidity === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider hidden-mobile"></div>
              <div class="avg-chart">
                <svg id="classic-spark-avg" class="sparkline-svg" preserveAspectRatio="none"></svg>
              </div>
            </div>
          </div>
        </div>

      </div>
    </main>

    <!-- Overview Panel (Right Sidebar) -->
    <aside class="overview-panel" :class="{ collapsed: !panelOpen }">
      <div class="panel-content">

        <!-- Section: Home Average -->
        <div class="panel-section panel-section-primary">
          <div class="panel-section-title">HOME</div>
          <div class="panel-metrics-grid">
            <div class="panel-metric">
              <span class="panel-icon">üè†</span>
              <span class="panel-value" x-text="($store.rooms.avgTemperature?.toFixed(1) || '--') + '¬∞'"></span>
            </div>
            <div class="panel-metric">
              <span class="panel-icon">üíß</span>
              <span class="panel-value" x-text="($store.rooms.avgHumidity?.toFixed(0) || '--') + '%'"></span>
            </div>
            <div class="panel-metric" x-show="$store.rooms.co2Value">
              <span class="panel-icon">üí®</span>
              <span class="panel-value" x-text="$store.rooms.co2Value"></span>
            </div>
          </div>
        </div>

        <!-- Section: Outside -->
        <div class="panel-section panel-section-primary">
          <div class="panel-section-title">OUTSIDE</div>
          <div class="panel-metrics-grid">
            <div class="panel-metric">
              <span class="panel-icon">üåø</span>
              <span class="panel-value" x-text="($store.rooms.list.find(r => r.id === 'balcony')?.temperature?.toFixed(1) || '--') + '¬∞'"></span>
            </div>
            <div class="panel-metric" x-show="$store.weather?.temperature != null">
              <span class="panel-icon" x-text="$store.weather?.conditionIcon || '‚òÅÔ∏è'"></span>
              <span class="panel-value" x-text="($store.weather?.temperature?.toFixed(0) || '--') + '¬∞'"></span>
            </div>
          </div>
        </div>

        <!-- Section: By Room -->
        <div class="panel-section panel-section-primary">
          <div class="panel-section-title">ROOMS</div>
          <div class="panel-metrics-grid">
            <template x-for="room in $store.rooms.list.filter(r => r.id !== 'balcony')" :key="room.id">
              <div class="panel-metric">
                <span class="panel-icon" x-text="room.icon"></span>
                <span class="panel-value" x-text="(room.temperature?.toFixed(1) || '--') + '¬∞'"></span>
              </div>
            </template>
          </div>
        </div>

        <!-- Section: Heating (only active heaters) -->
        <div class="panel-section">
          <div class="panel-section-title">HEATING</div>
          <div class="panel-metrics-grid">
            <div class="panel-metric full-width">
              <span class="panel-icon" x-text="($store.thermostats?.activeHeatingCount || 0) > 0 ? 'üî•' : '‚ùÑÔ∏è'"></span>
              <span class="panel-value" x-text="($store.thermostats?.activeHeatingCount || 0) === 0 ? 'All off' : ($store.thermostats?.activeHeatingCount + ' heating')"></span>
            </div>
            <template x-for="trv in ($store.thermostats?.list || []).filter(t => t.runningState === 'heat')" :key="trv.id">
              <div class="panel-metric heating-active">
                <span class="panel-icon" x-text="trv.icon || 'üî•'"></span>
                <span class="panel-value" x-text="(trv.localTemp?.toFixed(1) || '--') + '‚Üí' + (trv.targetTemp || '--') + '¬∞'"></span>
              </div>
            </template>
          </div>
        </div>

        <!-- Section: Security (only open windows/doors) -->
        <div class="panel-section">
          <div class="panel-section-title">SECURITY</div>
          <div class="panel-metrics-grid">
            <div class="panel-metric full-width">
              <span class="panel-icon" x-text="getOpenContactCount() === 0 ? 'üîí' : 'üîì'"></span>
              <span class="panel-value" x-text="getOpenContactCount() === 0 ? 'All secure' : getOpenContactCount() + ' open'"></span>
            </div>
            <template x-for="sensor in ($store.sensors?.sensorsByType?.contact || []).filter(s => $store.sensors?.liveData?.[s.ieee_address]?.contact === false)" :key="sensor.ieee_address">
              <div class="panel-metric contact-open">
                <span class="panel-icon">üîì</span>
                <span class="panel-value" x-text="getContactShortName(sensor.friendly_name)"></span>
              </div>
            </template>
          </div>
        </div>

      </div>
    </aside>
    </div><!-- /.app-body -->

    <!-- Footer -->
    <footer class="app-footer" x-show="currentView !== 'ambient'">
      <span class="footer-status">
        <span class="loading-indicator" x-show="$store.mqtt.connecting"></span>
        <span class="status-dot" :class="{ 'connected': $store.mqtt.connected, 'disconnected': !$store.mqtt.connected }" x-show="!$store.mqtt.connecting"></span>
        <span x-text="$store.mqtt.connecting ? 'Connecting...' : ($store.mqtt.connected ? 'Connected' : 'Reconnecting...')"></span>
      </span>
      <span> ‚Ä¢ </span>
      <span x-show="$store.rooms.loading" class="footer-status">
        <span class="loading-indicator"></span>
        <span>Loading history...</span>
      </span>
      <span x-show="!$store.rooms.loading" x-text="$store.rooms.historyCount + ' data points'"></span>
      <span x-show="$store.lights.syncing"> ‚Ä¢ <span class="loading-indicator"></span> Syncing lights...</span>
    </footer>

    <!-- Room Detail Modal -->
    <template x-if="$store.roomDetail.selectedRoom">
      <div class="modal-overlay" @click.self="$store.roomDetail.close()" @keydown.escape.window="$store.roomDetail.close()">
        <div class="modal">
          <div class="modal-header">
            <div class="modal-title">
              <span class="icon" x-text="$store.roomDetail.selectedRoom.icon"></span>
              <h2 x-text="$store.roomDetail.selectedRoom.name"></h2>
            </div>
            <button class="modal-close" @click="$store.roomDetail.close()">&times;</button>
          </div>
          <div class="modal-body">
            <div class="time-range-selector">
              <template x-for="range in $store.roomDetail.timeRanges" :key="range">
                <button class="btn btn-secondary" :class="{ active: $store.roomDetail.timeRange === range }"
                        @click="$store.roomDetail.setTimeRange(range)" x-text="range"></button>
              </template>
              <span x-show="$store.roomDetail.loading" class="loading-indicator"></span>
            </div>

            <div class="modal-stats">
              <div class="modal-stat">
                <div class="modal-stat-label">Temperature</div>
                <div class="modal-stat-value temp"
                     x-text="$store.roomDetail.selectedRoom.temperature !== null
                       ? $store.roomDetail.selectedRoom.temperature.toFixed(1) + '¬∞C' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Humidity</div>
                <div class="modal-stat-value humid"
                     x-text="$store.roomDetail.selectedRoom.humidity !== null
                       ? $store.roomDetail.selectedRoom.humidity.toFixed(0) + '%' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Min / Max</div>
                <div class="modal-stat-value minmax" x-text="$store.roomDetail.getMinMax()"></div>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Temperature History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-temp">
                <template x-if="$store.roomDetail.tempHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-temp" x-show="$store.roomDetail.tempHistory.length > 0"></svg>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Humidity History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-humid">
                <template x-if="$store.roomDetail.humidHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-humid" x-show="$store.roomDetail.humidHistory.length > 0"></svg>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <span x-text="'Last updated: ' + $store.roomDetail.formatUpdate($store.roomDetail.selectedRoom.lastSeen)"></span>
            <span> ‚Ä¢ </span>
            <span x-text="$store.roomDetail.tempHistory.length + ' temperature readings, ' + $store.roomDetail.humidHistory.length + ' humidity readings'"></span>
          </div>
        </div>
      </div>
    </template>

  </div>

  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <!-- Stub for co2View - provides initial state and reactive getters -->
  <script>
    window.co2View = function() {
      return {
        // CO2 Thresholds (ppm)
        thresholds: { excellent: 600, good: 1000, moderate: 1500, poor: 2000 },

        // State
        timeRange: '6h',
        timeRanges: ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d'],
        loading: false,
        co2History: [],
        tempHistory: [],
        humidHistory: [],
        trendDirection: 'stable',
        trendValue: 0,
        ambientMode: false,
        _moduleLoaded: false,

        // Reactive getters that access the store directly
        get co2Sensor() {
          const sensors = this.$store?.sensors;
          if (!sensors?.devices) return null;
          return sensors.devices.find(d =>
            d.friendly_name?.toLowerCase().includes('co2') && d.sensorType === 'co2'
          );
        },
        get liveData() {
          if (!this.co2Sensor) return null;
          return this.$store?.sensors?.getLiveData?.(this.co2Sensor.ieee_address) ?? null;
        },
        get co2Value() { return this.liveData?.co2 ?? null; },
        get temperature() { return this.liveData?.temperature ?? null; },
        get humidity() { return this.liveData?.humidity ?? null; },
        get airQualityLevel() {
          const co2 = this.co2Value;
          if (co2 === null) return 'unknown';
          if (co2 < this.thresholds.excellent) return 'excellent';
          if (co2 < this.thresholds.good) return 'good';
          if (co2 < this.thresholds.moderate) return 'moderate';
          if (co2 < this.thresholds.poor) return 'poor';
          return 'bad';
        },
        get co2Color() {
          const colors = { excellent: '#34C759', good: '#30D158', moderate: '#FFD60A', poor: '#FF9500', bad: '#FF3B30', unknown: '#AEAEB2' };
          return colors[this.airQualityLevel];
        },
        get gaugeArc() {
          const maxPPM = 2500;
          const value = Math.min(this.co2Value || 0, maxPPM);
          const percent = value / maxPPM;
          const circumference = 2 * Math.PI * 90;
          return `${percent * circumference} ${circumference}`;
        },
        get tempLevel() {
          const temp = this.temperature;
          if (temp === null) return 'unknown';
          if (temp < 18) return 'cold';
          if (temp < 20) return 'cool';
          if (temp <= 26) return 'comfortable';
          if (temp <= 28) return 'warm';
          return 'hot';
        },
        get tempColor() {
          const colors = { cold: '#90CAF9', cool: '#A5D6A7', comfortable: '#81C784', warm: '#FFE082', hot: '#EF5350', unknown: '#AEAEB2' };
          return colors[this.tempLevel];
        },
        get humidityLevel() {
          const h = this.humidity;
          if (h === null) return 'unknown';
          if (h < 30) return 'dry';
          if (h < 40) return 'low';
          if (h <= 60) return 'optimal';
          if (h <= 70) return 'high';
          return 'humid';
        },
        get humidityColor() {
          const colors = { dry: '#FFCC80', low: '#A5D6A7', optimal: '#81C784', high: '#90CAF9', humid: '#5C6BC0', unknown: '#AEAEB2' };
          return colors[this.humidityLevel];
        },
        get isStale() {
          if (!this.co2Sensor) return true;
          return this.$store?.sensors?.isStale?.(this.co2Sensor.ieee_address) ?? true;
        },
        get trendArrow() {
          if (this.trendDirection === 'rising') return '\u2191';
          if (this.trendDirection === 'falling') return '\u2193';
          return '\u2192';
        },
        get sensorRoom() {
          if (!this.co2Sensor) return 'Unknown';
          const name = this.co2Sensor.friendly_name || '';
          const match = name.match(/\[([^\]]+)\]/);
          return match ? match[1] + ' Room' : 'Room';
        },
        get minMax() {
          if (this.co2History.length === 0) return { min: '--', max: '--' };
          const values = this.co2History.map(d => d.value);
          return { min: Math.round(Math.min(...values)), max: Math.round(Math.max(...values)) };
        },
        get avgCo2() {
          if (this.co2History.length === 0) return '--';
          const sum = this.co2History.reduce((acc, d) => acc + d.value, 0);
          return Math.round(sum / this.co2History.length);
        },
        get co2Percent() { return Math.min(100, ((this.co2Value || 0) / 2500) * 100); },
        get tempPercent() { return Math.min(100, Math.max(0, ((this.temperature || 20) - 15) / 20 * 100)); },
        get humidityPercent() { return Math.min(100, Math.max(0, this.humidity || 0)); },

        // Methods
        init() {
          console.log('[co2-view] Stub initialized, waiting for module...');
          window._co2ViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          if (window._co2ViewMethods && !this._moduleLoaded) {
            console.log('[co2-view] Module methods available, enhancing...');
            this._moduleLoaded = true;
            // Only copy methods, not getters (getters are already defined above)
            const methods = window._co2ViewMethods;
            if (methods.loadHistoricalData) this.loadHistoricalData = methods.loadHistoricalData.bind(this);
            if (methods.queryInflux) this.queryInflux = methods.queryInflux.bind(this);
            if (methods.setTimeRange) this.setTimeRange = methods.setTimeRange.bind(this);
            if (methods.drawChart) this.drawChart = methods.drawChart.bind(this);
            if (methods.drawThresholdZones) this.drawThresholdZones = methods.drawThresholdZones.bind(this);
            if (methods.formatTimeLabel) this.formatTimeLabel = methods.formatTimeLabel.bind(this);
            if (methods.calculateTrend) this.calculateTrend = methods.calculateTrend.bind(this);
            if (methods.formatLastUpdate) this.formatLastUpdate = methods.formatLastUpdate.bind(this);
            // Load historical data now
            this.loadHistoricalData();
          } else if (!this._moduleLoaded) {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        loadHistoricalData() { console.log('[co2-view] Stub loadHistoricalData (waiting for module)'); },
        setTimeRange(range) { this.timeRange = range; },
        drawChart() {},
        calculateTrend() {},
        formatLastUpdate() { return 'No data'; },
        toggleAmbient() { this.ambientMode = !this.ambientMode; },
        destroy() {}
      };
    };
  </script>

  <!-- Stub for thermostatView - reactive stub that pulls from Alpine store -->
  <script>
    window.thermostatView = function() {
      return {
        activeTab: 'overview',
        timeRange: '24h',
        showBackground: false,
        filterRoom: '',
        filterEventType: '',
        tempHistory: {},
        loading: false,
        chartUpdateInterval: null,

        init() {
          console.log('[thermostat-view] Stub initialized, waiting for module...');
          window._thermostatViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          // Check if real module is loaded
          if (window._thermostatViewMethods && !this._moduleLoaded) {
            console.log('[thermostat-view] Module methods available, enhancing...');
            const methods = window._thermostatViewMethods;
            Object.keys(methods).forEach(key => {
              if (typeof methods[key] === 'function') {
                this[key] = methods[key].bind(this);
              }
            });
            this._moduleLoaded = true;
            if (this.setupMqttListener) this.setupMqttListener();
          } else {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        destroy() {
          if (this.chartUpdateInterval) {
            clearInterval(this.chartUpdateInterval);
          }
        },

        // Getters - these pull from the Alpine store
        get thermostats() {
          return Alpine.store('thermostats')?.list ?? [];
        },

        get events() {
          let events = [...(Alpine.store('thermostats')?.events ?? [])];
          if (this.filterRoom) {
            events = events.filter(e => e.roomId === this.filterRoom);
          }
          if (this.filterEventType) {
            events = events.filter(e => e.eventType === this.filterEventType);
          }
          return events;
        },

        get importantEvents() {
          return this.events.filter(e => e.info?.priority === 'important').slice(0, 10);
        },

        get activityEvents() {
          return this.events.filter(e => e.info?.priority === 'activity').slice(0, 20);
        },

        get backgroundEvents() {
          return this.events.filter(e => e.info?.priority === 'background');
        },

        get stats() {
          return Alpine.store('thermostats')?.getStats?.(24) ?? { heatingCycles: 0, setpointChanges: 0 };
        },

        get activeHeatingCount() {
          return Alpine.store('thermostats')?.activeHeatingCount ?? 0;
        },

        get offlineCount() {
          return Alpine.store('thermostats')?.offlineCount ?? 0;
        },

        get uniqueRooms() {
          const rooms = new Set(this.events.map(e => e.roomId));
          return [...rooms].filter(r => r);
        },

        get uniqueEventTypes() {
          const types = new Set(this.events.map(e => e.eventType));
          return [...types].filter(t => t);
        },

        // UI Helper methods
        setTab(tab) { this.activeTab = tab; },
        setTimeRange(range) {
          this.timeRange = range;
          if (this.activeTab === 'trends' && this.loadHistoricalData) {
            this.loadHistoricalData();
          }
        },
        clearFilters() { this.filterRoom = ''; this.filterEventType = ''; },

        getDisplayTemp(t) {
          const temp = t?.pendingTarget ?? t?.targetTemp;
          return temp;
        },
        getHeatingColor(t) {
          if (t?.systemMode === 'off') return 'var(--color-text-tertiary)';
          if (t?.runningState === 'heat') return 'var(--color-danger)';
          return 'var(--color-success)';
        },
        getStatusText(t) {
          if (!t?.available) return 'Offline';
          if (t?.systemMode === 'off') return 'Off';
          if (t?.runningState === 'heat') return 'Heating';
          return 'Idle';
        },
        getStatusIcon(t) {
          if (!t?.available) return 'üì°';
          if (t?.systemMode === 'off') return '‚èπÔ∏è';
          if (t?.runningState === 'heat') return 'üî•';
          return '‚ùÑÔ∏è';
        },
        getProgressPercent(t) {
          if (!t?.localTemp || !t?.targetTemp) return 0;
          // Show actual temperature ratio regardless of heating state
          const progress = (t.localTemp / t.targetTemp) * 100;
          return Math.min(100, Math.max(0, Math.round(progress)));
        },
        getProgressLabel(t) {
          if (!t?.localTemp || !t?.targetTemp) return 'Unknown';
          if (t?.runningState === 'heat') return 'Heating...';
          // Check if within 0.5¬∞ of target (either direction)
          if (Math.abs(t.localTemp - t.targetTemp) <= 0.5) return 'At target';
          if (t.localTemp > t.targetTemp) return 'Above target';
          return 'Below target';
        },
        getBatteryColor(b) {
          if (b === null) return 'var(--color-text-tertiary)';
          if (b < 20) return 'var(--color-danger)';
          if (b < 50) return 'var(--color-warning)';
          return 'var(--color-success)';
        },
        getBatteryIcon(b) { return b === null || b < 20 ? 'ü™´' : 'üîã'; },
        formatTemp(temp) { return temp?.toFixed(1) ?? '--'; },
        // Split temp into whole and decimal parts for styling
        tempParts(temp) {
          if (temp == null) return { whole: '--', decimal: '' };
          const fixed = temp.toFixed(1);
          const [whole, decimal] = fixed.split('.');
          return { whole, decimal: '.' + decimal };
        },

        // Troubleshooting helpers
        getLastStateChange(t) {
          const events = this.$store.thermostats?.events || [];
          const lastEvent = events.find(e =>
            e.deviceId === t.id &&
            (e.eventType === 'heating_started' || e.eventType === 'heating_stopped')
          );
          if (!lastEvent) return 'No data';
          const action = lastEvent.eventType === 'heating_started' ? 'Started' : 'Stopped';
          return `${action} ${this.formatRelativeTime(lastEvent.time)}`;
        },
        getTodayStats(t) {
          const stats = this.$store.thermostats?.getStatsByDevice?.(t.id, 24) || { heatingCycles: 0, heatingMinutes: 0 };
          return `${stats.heatingCycles} cycles, ${this.formatDuration(stats.heatingMinutes)}`;
        },
        formatTime(ts) {
          const date = new Date(ts);
          const now = new Date();
          if (date.toDateString() === now.toDateString()) {
            return date.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
          }
          return date.toLocaleDateString('en-AU', { weekday: 'short', hour: 'numeric', minute: '2-digit' });
        },
        formatRelativeTime(ts) {
          const s = Math.floor((Date.now() - ts) / 1000);
          if (s < 60) return 'Just now';
          if (s < 3600) return `${Math.floor(s / 60)}m ago`;
          if (s < 86400) return `${Math.floor(s / 3600)}h ago`;
          return `${Math.floor(s / 86400)}d ago`;
        },
        formatDuration(m) {
          if (m < 60) return `${m}m`;
          const h = Math.floor(m / 60);
          const mins = m % 60;
          return mins > 0 ? `${h}h ${mins}m` : `${h}h`;
        },
        getEventInfo(type) {
          const types = {
            heating_started: { icon: 'üî•', color: '#ef4444', label: 'Heating Started', priority: 'important' },
            heating_stopped: { icon: '‚ùÑÔ∏è', color: '#3b82f6', label: 'Heating Stopped', priority: 'important' },
            target_reached: { icon: '‚úÖ', color: '#22c55e', label: 'Target Reached', priority: 'important' },
            device_offline: { icon: 'üì°', color: '#ef4444', label: 'Device Offline', priority: 'important' },
            low_battery: { icon: 'ü™´', color: '#f59e0b', label: 'Low Battery', priority: 'important' },
            setpoint_changed: { icon: 'üéØ', color: '#f59e0b', label: 'Setpoint Changed', priority: 'activity' },
            mode_changed: { icon: '‚öôÔ∏è', color: '#8b5cf6', label: 'Mode Changed', priority: 'activity' },
            preset_changed: { icon: 'üöÄ', color: '#06b6d4', label: 'Preset Changed', priority: 'activity' },
            device_online: { icon: 'üì°', color: '#22c55e', label: 'Device Online', priority: 'background' },
            battery_ok: { icon: 'üîã', color: '#22c55e', label: 'Battery OK', priority: 'background' }
          };
          return types[type] || { icon: 'üìù', color: '#94a3b8', label: type, priority: 'background' };
        },

        // Control methods - delegate to store
        adjustTemp(id, delta) { Alpine.store('thermostats')?.adjustTemp?.(id, delta); },
        setTargetTemp(id, temp) { Alpine.store('thermostats')?.setTargetTemp?.(id, parseFloat(temp)); },
        togglePower(id) { Alpine.store('thermostats')?.togglePower?.(id); },
        setMode(id, mode) { Alpine.store('thermostats')?.setMode?.(id, mode); },
        toggleChildLock(id) {
          const t = Alpine.store('thermostats')?.getThermostat?.(id);
          if (t) Alpine.store('thermostats')?.setChildLock?.(id, t.childLock === 'UNLOCK');
        },

        // Efficiency
        getDeviceStats(id) { return Alpine.store('thermostats')?.getStatsByDevice?.(id, 24) ?? {}; },
        getComparisonStats() {
          const today = this.stats;
          return {
            today,
            yesterday: { heatingCycles: today.heatingCycles + 2, setpointChanges: today.setpointChanges + 1 }
          };
        },

        // Historical data - stub, real methods will come from module
        async loadHistoricalData() { console.log('[thermostat-view] loadHistoricalData stub called'); },
        drawCharts() { console.log('[thermostat-view] drawCharts stub called'); },
        drawThermostatChart(id) { console.log('[thermostat-view] drawThermostatChart stub called'); }
      };
    };
  </script>

  <!-- Stub for mailboxView - reactive stub that waits for module -->
  <script>
    window.mailboxView = function() {
      return {
        // State
        deviceName: '[Mailbox] Motion Sensor',
        dateRange: 'today',
        patternMode: 'hourly',
        mailboxEvents: [],
        loading: false,
        _mqttSetup: false,
        _moduleLoaded: false,

        init() {
          console.log('[mailbox-view] Stub initialized, waiting for module...');
          window._mailboxViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          if (window._mailboxViewMethods && !this._moduleLoaded) {
            console.log('[mailbox-view] Module methods available, enhancing...');
            const methods = window._mailboxViewMethods;
            Object.keys(methods).forEach(key => {
              if (typeof methods[key] === 'function') {
                this[key] = methods[key].bind(this);
              }
            });
            this._moduleLoaded = true;
            if (this.loadMailboxEvents) this.loadMailboxEvents();
            if (this.setupMqttListener) this.setupMqttListener();
          } else {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        destroy() {
          if (this._refreshInterval) {
            clearInterval(this._refreshInterval);
          }
        },

        // Computed getters
        get filteredEvents() {
          const now = Date.now();
          let startTime, endTime = now;
          switch (this.dateRange) {
            case 'today':
              startTime = new Date().setHours(0, 0, 0, 0);
              break;
            case 'yesterday':
              const yesterday = new Date();
              yesterday.setDate(yesterday.getDate() - 1);
              startTime = yesterday.setHours(0, 0, 0, 0);
              endTime = new Date().setHours(0, 0, 0, 0);
              break;
            case 'week':
              startTime = now - 7 * 24 * 60 * 60 * 1000;
              break;
            default:
              startTime = new Date().setHours(0, 0, 0, 0);
          }
          return this.mailboxEvents.filter(e => e.time >= startTime && e.time <= endTime);
        },

        get deliveryEvents() {
          return this.filteredEvents.filter(e => e.eventType === 'motion_detected');
        },

        get lastDelivery() {
          const deliveries = this.mailboxEvents.filter(e => e.eventType === 'motion_detected');
          return deliveries.length > 0 ? deliveries[0] : null;
        },

        get hasMailToday() {
          const todayStart = new Date().setHours(0, 0, 0, 0);
          return this.mailboxEvents.some(e => e.eventType === 'motion_detected' && e.time >= todayStart);
        },

        get stats() {
          const todayStart = new Date().setHours(0, 0, 0, 0);
          const weekStart = Date.now() - 7 * 24 * 60 * 60 * 1000;
          const allDeliveries = this.mailboxEvents.filter(e => e.eventType === 'motion_detected');
          const todayDeliveries = allDeliveries.filter(e => e.time >= todayStart);
          const weekDeliveries = allDeliveries.filter(e => e.time >= weekStart);
          const deliveryHours = weekDeliveries.map(e => new Date(e.time).getHours());
          const avgHour = deliveryHours.length > 0
            ? Math.round(deliveryHours.reduce((a, b) => a + b, 0) / deliveryHours.length)
            : null;
          return {
            todayCount: todayDeliveries.length,
            weekCount: weekDeliveries.length,
            totalCount: allDeliveries.length,
            avgDeliveryHour: avgHour,
            avgDeliveryTime: avgHour !== null ? this.formatHour(avgHour) : '--'
          };
        },

        get signalHealth() {
          const now = Date.now();
          const twentyFourHoursAgo = now - 24 * 60 * 60 * 1000;
          const recentEvents = this.mailboxEvents.filter(e => e.time >= twentyFourHoursAgo);
          const sortedEvents = [...recentEvents].sort((a, b) => b.time - a.time);
          const lastEvent = sortedEvents[0];
          const lastSeen = lastEvent?.time || null;
          let gaps = 0;
          const thirtyMinutes = 30 * 60 * 1000;
          for (let i = 0; i < sortedEvents.length - 1; i++) {
            if (sortedEvents[i].time - sortedEvents[i + 1].time > thirtyMinutes) gaps++;
          }
          const timeSinceLastSeen = lastSeen ? now - lastSeen : Infinity;
          const isOffline = timeSinceLastSeen > thirtyMinutes;
          const expectedEvents = 24 * 2;
          const uptimePercent = Math.min(100, Math.round((recentEvents.length / expectedEvents) * 100));
          let status = 'healthy', label = 'Healthy';
          if (isOffline) { status = 'critical'; label = 'Offline'; }
          else if (gaps > 3 || uptimePercent < 50) { status = 'warning'; label = 'Intermittent'; }
          else if (recentEvents.length === 0) { status = 'unknown'; label = 'No Data'; }
          return { status, label, lastSeen, uptimePercent, gaps, eventCount: recentEvents.length };
        },

        get hourlyPattern() {
          const hours = new Array(24).fill(0);
          const weekStart = Date.now() - 7 * 24 * 60 * 60 * 1000;
          this.mailboxEvents.filter(e => e.eventType === 'motion_detected' && e.time >= weekStart)
            .forEach(e => hours[new Date(e.time).getHours()]++);
          const max = Math.max(...hours, 1);
          return hours.map((count, hour) => ({
            hour, count, height: (count / max) * 100,
            label: this.formatHourShort(hour), isEmpty: count === 0
          }));
        },

        get dailyPattern() {
          const days = new Array(7).fill(0);
          const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
          const monthStart = Date.now() - 30 * 24 * 60 * 60 * 1000;
          this.mailboxEvents.filter(e => e.eventType === 'motion_detected' && e.time >= monthStart)
            .forEach(e => days[new Date(e.time).getDay()]++);
          const max = Math.max(...days, 1);
          return days.map((count, day) => ({
            day, count, height: (count / max) * 100,
            label: dayNames[day], isEmpty: count === 0
          }));
        },

        get patternData() {
          return this.patternMode === 'hourly' ? this.hourlyPattern : this.dailyPattern;
        },

        // Formatting helpers
        formatTime(timestamp) {
          if (!timestamp) return '--';
          return new Date(timestamp).toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit', hour12: true });
        },
        formatDate(timestamp) {
          if (!timestamp) return '--';
          return new Date(timestamp).toLocaleDateString('en-AU', { weekday: 'short', month: 'short', day: 'numeric' });
        },
        formatDateTime(timestamp) {
          if (!timestamp) return '--';
          return new Date(timestamp).toLocaleString('en-AU', { weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true });
        },
        formatRelativeTime(timestamp) {
          if (!timestamp) return '--';
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          return `${Math.floor(seconds / 86400)}d ago`;
        },
        formatHour(hour) {
          const period = hour >= 12 ? 'PM' : 'AM';
          const displayHour = hour % 12 || 12;
          return `${displayHour}:00 ${period}`;
        },
        formatHourShort(hour) {
          if (hour === 0) return '12a';
          if (hour === 12) return '12p';
          if (hour < 12) return `${hour}a`;
          return `${hour - 12}p`;
        },

        // Event helpers
        getEventIcon(eventType) {
          const icons = { motion_detected: '1f4ec', motion_cleared: '1f4ed', device_online: '1f4e1', device_offline: '26a0' };
          const code = icons[eventType] || '1f4cd';
          return String.fromCodePoint(parseInt(code, 16));
        },
        getEventLabel(eventType) {
          const labels = { motion_detected: 'Mail Arrived', motion_cleared: 'Motion Cleared', device_online: 'Sensor Online', device_offline: 'Sensor Offline' };
          return labels[eventType] || eventType;
        },
        getEventClass(eventType) { return eventType.replace(/_/g, '-'); },

        // Actions
        setDateRange(range) { this.dateRange = range; },
        setPatternMode(mode) { this.patternMode = mode; },
        refresh() { if (this.loadMailboxEvents) this.loadMailboxEvents(); },

        // Stubs - real methods come from module
        async loadMailboxEvents() { console.log('[mailbox-view] loadMailboxEvents stub called'); },
        setupMqttListener() { console.log('[mailbox-view] setupMqttListener stub called'); },
        addLiveEvent(event) { console.log('[mailbox-view] addLiveEvent stub called'); }
      };
    };
  </script>

  <!-- Stub for sensorConfigView - reactive stub that pulls from Alpine store -->
  <script>
    window.sensorConfigView = function() {
      return {
        searchQuery: '',
        expandedTypes: { climate: true, co2: true, motion: true, contact: true },
        showHelp: false,
        isTopView: false,
        showCoverage: false,
        tooltip: { text: '', visible: false, x: 0, y: 0 },
        selectedSensor: null,

        init() {
          console.log('[sensor-config] Stub initialized, waiting for Three.js module...');
          // Store reference for module to find and enhance
          window._sensorConfigComponent = this;
          this._checkForThreeJS();
        },

        _checkForThreeJS() {
          if (window._initSensorConfigThreeJS) {
            console.log('[sensor-config] Three.js module ready, initializing 3D view...');
            window._initSensorConfigThreeJS(this);
          } else {
            // Keep checking until module loads
            setTimeout(() => this._checkForThreeJS(), 100);
          }
        },

        // Reactive getters that pull from sensors store
        get loading() { return Alpine.store('sensors')?.loading ?? true; },
        get placedCount() { return Alpine.store('sensors')?.placedCount ?? 0; },
        get totalCount() { return Alpine.store('sensors')?.totalCount ?? 0; },
        get sensors() { return Alpine.store('sensors')?.devices ?? []; },
        get positions() { return Alpine.store('sensors')?.positions ?? {}; },
        get selectedRoom() {
          if (!this.selectedSensor) return null;
          return Alpine.store('sensors')?.getPosition(this.selectedSensor.ieee_address)?.roomId || null;
        },
        get hasCoverageToggle() {
          return this.sensors.some(s => s.sensorType === 'motion');
        },
        get sensorsByType() {
          const sensors = this.sensors;
          const grouped = { climate: [], co2: [], motion: [], contact: [] };
          sensors.forEach(sensor => {
            const type = sensor.sensorType || 'climate';
            if (grouped[type]) {
              if (!this.searchQuery ||
                  sensor.friendly_name.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                  type.includes(this.searchQuery.toLowerCase())) {
                grouped[type].push(sensor);
              }
            }
          });
          return grouped;
        },

        // Helper methods
        getTypeIcon(type) { return { climate: 'üå°Ô∏è', co2: 'üí®', motion: 'üëÅÔ∏è', contact: 'üö™' }[type] || 'üì°'; },
        getTypeLabel(type) { return { climate: 'Temperature & Humidity', co2: 'CO‚ÇÇ Sensors', motion: 'Motion Sensors', contact: 'Contact Sensors' }[type] || 'Unknown'; },
        getTypeColor(type) { return { climate: '#34d399', co2: '#ff6b6b', motion: '#ffd93d', contact: '#38bdf8' }[type] || '#888'; },

        formatLiveValue(sensor) {
          const data = Alpine.store('sensors')?.getLiveData(sensor.ieee_address);
          if (!data) return '--';
          switch (sensor.sensorType) {
            case 'climate':
              const temp = data.temperature !== undefined ? `${data.temperature.toFixed(1)}¬∞` : '--';
              const hum = data.humidity !== undefined ? `${Math.round(data.humidity)}%` : '';
              return `${temp} ${hum}`.trim();
            case 'co2': return data.co2 !== undefined ? `${data.co2} ppm` : '--';
            case 'motion': return data.occupancy !== undefined ? (data.occupancy ? 'üî¥ Motion' : '‚ö™ Clear') : '--';
            case 'contact': return data.contact !== undefined ? (data.contact ? 'üîí Closed' : 'üîì Open') : '--';
            default: return '--';
          }
        },
        isPlaced(ieee) { return Alpine.store('sensors')?.isPlaced(ieee) || false; },
        isStale(ieee) { return Alpine.store('sensors')?.isStale(ieee) || false; },

        selectSensor(sensor) {
          this.selectedSensor = this.selectedSensor?.ieee_address === sensor.ieee_address ? null : sensor;
          if (window._sensorConfigController) {
            window._sensorConfigController.selectedSensor = this.selectedSensor?.ieee_address;
          }
        },
        startDrag(e, sensor) {
          e.dataTransfer?.setData('sensor-ieee', sensor.ieee_address);
          this.selectedSensor = sensor;
          // Start drag in Three.js controller
          if (window._sensorConfigController?.startDragFromPalette) {
            window._sensorConfigController.startDragFromPalette(sensor.ieee_address);
          }
        },
        onDragOver(e) {
          e.preventDefault();
          // Check if dragging a sensor
          if (!e.dataTransfer?.types?.includes('sensor-ieee')) return;

          const controller = window._sensorConfigController;
          const container = e.currentTarget;
          if (!controller || !container) return;

          // Calculate normalized mouse position
          const rect = container.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

          // Update preview position
          if (controller.updateDragPreview) {
            controller.updateDragPreview(x, y);
          }
        },
        onDragLeave(e) {
          // Hide preview when leaving canvas
          const threeState = window._configThreeState;
          if (threeState?.dragPreview) {
            threeState.dragPreview.visible = false;
          }
        },
        onDrop(e) {
          e.preventDefault();
          const ieee = e.dataTransfer?.getData('sensor-ieee');
          if (!ieee) return;

          const controller = window._sensorConfigController;
          const container = e.currentTarget;
          if (!controller || !container) return;

          // Calculate normalized mouse position for raycasting
          const rect = container.getBoundingClientRect();
          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

          // Use controller to handle the drop
          if (controller.handlePaletteDrop) {
            controller.handlePaletteDrop(ieee, x, y);
          }
        },
        resetView() {
          if (window._sensorConfigController?.onResize) {
            window._sensorConfigController.onResize();
          }
        },
        toggleTopView() {
          this.isTopView = !this.isTopView;
          // Could adjust camera angle via controller
        },
        zoomIn() {
          // Zoom via Three.js camera if available
          console.log('[stub] zoomIn');
        },
        zoomOut() {
          console.log('[stub] zoomOut');
        },
        resetAllPositions() { Alpine.store('sensors')?.resetAllPositions(); },
        toggleCoverage() {
          this.showCoverage = !this.showCoverage;
          if (window._sensorConfigController?.toggleCoverage) {
            window._sensorConfigController.toggleCoverage();
          }
        }
      };
    };
  </script>

  <!-- Theme Store - MUST load before Alpine processes elements -->
  <script type="module">
    import { initThemeStore } from './js/stores/theme-store.js';

    // Register theme store when Alpine initializes
    document.addEventListener('alpine:init', () => {
      initThemeStore(Alpine);
      console.log('[theme-store] Theme store registered');
    });
  </script>

  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <!-- CO2 Monitor Module - enhances the stub with methods -->
  <script type="module">
    import { co2View } from './views/co2-monitor.js?v=3';

    // Get the module object and extract only the methods (not getters)
    const moduleObj = co2View();
    window._co2ViewMethods = {
      loadHistoricalData: moduleObj.loadHistoricalData,
      queryInflux: moduleObj.queryInflux,
      setTimeRange: moduleObj.setTimeRange,
      drawChart: moduleObj.drawChart,
      drawThresholdZones: moduleObj.drawThresholdZones,
      formatTimeLabel: moduleObj.formatTimeLabel,
      calculateTrend: moduleObj.calculateTrend,
      formatLastUpdate: moduleObj.formatLastUpdate
    };
    console.log('[co2-monitor] Module loaded, methods ready');

    // If stub component exists, trigger enhancement
    if (window._co2ViewComponent && !window._co2ViewComponent._moduleLoaded) {
      console.log('[co2-monitor] Stub found, enhancing with methods...');
      window._co2ViewComponent._checkForModule();
    }
  </script>

  <!-- Sensor Config Module - loads after Alpine, enhances the stub -->
  <script type="module">
    import { sensorConfigView } from './views/sensor-config.js?v=3';
    import { initSensorsStore } from './js/stores/sensors-store.js';
    import { FLOOR_PLAN_CONFIG, SENSOR_VISUALS } from './js/config.js';

    // Create a Three.js controller that will manage the 3D view
    // This is separate from Alpine's reactive system to avoid proxy issues
    const threeJSController = sensorConfigView(FLOOR_PLAN_CONFIG, SENSOR_VISUALS, THREE.OrbitControls);

    // Store controller globally for stub access
    window._sensorConfigThreeJS = threeJSController;

    // Expose initialization function for stub to call
    // Guard against multiple initializations
    let initializationComplete = false;

    window._initSensorConfigThreeJS = function(alpineComponent) {
      // Prevent multiple initializations
      if (initializationComplete) {
        console.log('[sensor-config] Already initialized, skipping');
        return;
      }
      console.log('[sensor-config] Initializing Three.js controller...');

      // The controller needs access to Alpine component for $refs
      const container = alpineComponent.$refs?.configCanvas;
      if (!container) {
        console.error('[sensor-config] Container ref not found, retrying...');
        setTimeout(() => window._initSensorConfigThreeJS(alpineComponent), 100);
        return;
      }

      // Create proxy object that gives controller access to container
      const controllerContext = {
        $refs: { configCanvas: container },
        tooltip: alpineComponent.tooltip,
        selectedSensor: null,
        showMotionCoverage: false
      };

      // Bind all controller methods to the proxy context
      Object.keys(threeJSController).forEach(key => {
        if (typeof threeJSController[key] === 'function') {
          controllerContext[key] = threeJSController[key].bind(controllerContext);
        }
      });

      // Store the bound controller for stub methods to use
      window._sensorConfigController = controllerContext;

      // Add custom drop handler for palette drops
      controllerContext.handlePaletteDrop = function(ieee, mouseX, mouseY) {
        const threeState = window._configThreeState;

        // Hide drag preview
        if (threeState?.dragPreview) {
          threeState.dragPreview.visible = false;
        }

        // Re-enable controls
        if (threeState?.controls) {
          threeState.controls.enabled = true;
        }

        if (!threeState?.raycaster || !threeState?.camera || !threeState?.floorPlane) {
          console.error('[sensor-config] Three.js state not ready for drop', {
            raycaster: !!threeState?.raycaster,
            camera: !!threeState?.camera,
            floorPlane: !!threeState?.floorPlane
          });
          return;
        }

        // Set mouse position for raycaster
        const mouse = new THREE.Vector2(mouseX, mouseY);
        threeState.raycaster.setFromCamera(mouse, threeState.camera);

        // Raycast to floor plane
        const intersects = threeState.raycaster.intersectObject(threeState.floorPlane);
        if (intersects.length === 0) {
          console.log('[sensor-config] Drop missed floor plane');
          return;
        }

        const point = intersects[0].point;
        const sensor = Alpine.store('sensors').getSensor(ieee);
        if (!sensor) {
          console.error('[sensor-config] Sensor not found:', ieee);
          return;
        }

        const visuals = window.SENSOR_VISUALS?.[sensor.sensorType] || window.SENSOR_VISUALS?.climate;
        const position = {
          x: point.x,
          y: visuals?.heightAboveFloor || 1.5,
          z: point.z
        };

        // Detect which room using bound detectRoom method
        const roomId = controllerContext.detectRoom ? controllerContext.detectRoom(point.x, point.z) : null;

        // Save position to store (persists via MQTT)
        Alpine.store('sensors').savePosition(ieee, position, roomId);
        console.log('[sensor-config] Sensor placed:', ieee, 'at', position, 'in', roomId);
      };

      // Update preview position during drag-over
      controllerContext.updateDragPreview = function(mouseX, mouseY) {
        const threeState = window._configThreeState;
        if (!threeState?.raycaster || !threeState?.camera || !threeState?.floorPlane) return;

        // Raycast to floor plane
        const mouse = new THREE.Vector2(mouseX, mouseY);
        threeState.raycaster.setFromCamera(mouse, threeState.camera);
        const intersects = threeState.raycaster.intersectObject(threeState.floorPlane);

        if (intersects.length === 0) {
          // Hide preview if not over floor
          if (threeState.dragPreview) threeState.dragPreview.visible = false;
          return;
        }

        const point = intersects[0].point;

        // Create preview sphere if not exists
        if (!threeState.dragPreview) {
          const geometry = new THREE.SphereGeometry(0.15, 16, 16);
          const material = new THREE.MeshBasicMaterial({
            color: 0x34d399,  // Green
            transparent: true,
            opacity: 0.8
          });
          threeState.dragPreview = new THREE.Mesh(geometry, material);
          threeState.scene.add(threeState.dragPreview);
        }

        // Update preview position
        threeState.dragPreview.visible = true;
        threeState.dragPreview.position.set(point.x, 1.5, point.z);

        // Color based on validity (green = valid room, red = invalid)
        const roomId = controllerContext.detectRoom ? controllerContext.detectRoom(point.x, point.z) : null;
        threeState.dragPreview.material.color.setHex(roomId ? 0x34d399 : 0xff6b6b);
      };

      // Custom initialization that waits for container to be visible
      function initThreeJS() {
        const c = container;
        if (!c || c.clientWidth === 0 || c.clientHeight === 0) {
          // Container not visible yet (view hidden), retry
          setTimeout(initThreeJS, 200);
          return;
        }

        console.log('[sensor-config] Container ready, initializing Three.js...');
        try {
          controllerContext.initScene();
          controllerContext.initCamera(c, THREE.OrbitControls);
          controllerContext.initRenderer(c);
          controllerContext.initLighting();
          controllerContext.initRaycaster();
          controllerContext.buildFloorPlan();
          controllerContext.setupEventListeners(c);
          controllerContext.animate();
          initializationComplete = true;
          console.log('[sensor-config] Three.js initialization complete!');
        } catch (e) {
          console.error('[sensor-config] Three.js init error:', e);
        }
      }

      initThreeJS();
    };
    console.log('[sensor-config] Module loaded, _initSensorConfigThreeJS ready');

    // Replace stub for any future component creations
    window.sensorConfigView = function() {
      return sensorConfigView(FLOOR_PLAN_CONFIG, SENSOR_VISUALS, THREE.OrbitControls);
    };

    // Initialize sensors store
    function initSensors() {
      const CONFIG = window.CONFIG;
      if (typeof Alpine !== 'undefined' && CONFIG) {
        if (!Alpine.store('sensors')) {
          initSensorsStore(Alpine, CONFIG);
          console.log('[sensor-config] Sensors store initialized');
        }
        // Initialize MQTT subscriptions
        setTimeout(() => {
          const sensorsStore = Alpine.store('sensors');
          if (sensorsStore && Alpine.store('mqtt')?.client) {
            sensorsStore.init();
            console.log('[sensor-config] Sensors MQTT subscriptions initialized');
          }
        }, 2000);
      }
    }

    // Try to initialize
    if (typeof Alpine !== 'undefined') {
      initSensors();
    } else {
      document.addEventListener('alpine:init', () => {
        initSensorsStore(Alpine, window.CONFIG);
      });
      document.addEventListener('DOMContentLoaded', initSensors);
    }
  </script>

  <!-- Thermostat View Module - loads store and view -->
  <script type="module">
    import { initThermostatStore } from './js/stores/thermostat-store.js?v=3';
    import { thermostatView } from './views/thermostat.js?v=3';

    // Expose thermostatView globally for Alpine x-data
    window.thermostatView = thermostatView;
    console.log('[thermostat] Module loaded, thermostatView ready');

    // Initialize thermostat store
    function initThermostats() {
      const CONFIG = window.CONFIG;
      if (typeof Alpine !== 'undefined' && CONFIG) {
        if (!Alpine.store('thermostats')) {
          initThermostatStore(Alpine, CONFIG);
          console.log('[thermostat] Thermostat store initialized');
        }
        // Initialize MQTT subscriptions after MQTT connects
        setTimeout(() => {
          const thermostatStore = Alpine.store('thermostats');
          if (thermostatStore) {
            thermostatStore.init?.();
            console.log('[thermostat] MQTT subscriptions initializing');
          }
        }, 2000);
      }
    }

    // Try to initialize when Alpine is ready
    if (typeof Alpine !== 'undefined') {
      initThermostats();
    } else {
      document.addEventListener('alpine:init', () => {
        initThermostatStore(Alpine, window.CONFIG);
      });
      document.addEventListener('DOMContentLoaded', initThermostats);
    }
  </script>

  <!-- Mailbox View Module - loads methods and triggers stub enhancement -->
  <script type="module">
    import { mailboxView } from './views/mailbox.js?v=2';

    // Get the module object and extract the methods
    const moduleObj = mailboxView();
    window._mailboxViewMethods = {
      loadMailboxEvents: moduleObj.loadMailboxEvents,
      setupMqttListener: moduleObj.setupMqttListener,
      addLiveEvent: moduleObj.addLiveEvent
    };
    console.log('[mailbox] Module loaded, methods ready');

    // If stub component exists, trigger enhancement
    if (window._mailboxViewComponent && !window._mailboxViewComponent._moduleLoaded) {
      console.log('[mailbox] Stub found, enhancing with methods...');
      window._mailboxViewComponent._checkForModule();
    }
  </script>

  <script>
    // ========================================
    // CONFIGURATION
    // ========================================
    // Detect local dev (localhost) vs Pi deployment
    const isLocalDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const isNginxProxy = window.location.port === '8888';
    const CONFIG = {
      mqttUrl: isLocalDev
        ? 'ws://pi:9001'  // Local dev ‚Üí connect to Pi's MQTT
        : isNginxProxy
          ? 'ws://' + window.location.host + '/mqtt'  // Pi nginx proxy
          : 'ws://' + window.location.hostname + ':9001',
      baseTopic: 'zigbee2mqtt',
      influxUrl: isLocalDev
        ? 'http://pi:8086'  // Local dev ‚Üí connect to Pi's InfluxDB
        : '/api/influx',
      influxDb: 'homeassistant',
      // Room configuration - isOutdoor: true excludes from home-wide averages
      rooms: [
        { id: 'living', name: 'Living Room', icon: 'üõãÔ∏è', sensor: '[Living] Temperature & Humidity', entityId: 'sensor.living_temperature_humidity', isOutdoor: false },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', sensor: '[Bed] Temperature & Humidity Sensor', entityId: 'sensor.bed_temperature_humidity_sensor', isOutdoor: false },
        { id: 'study', name: 'Study', icon: 'üìö', sensor: '[Study] Temperature & Humidity', entityId: 'sensor.study_temperature_humidity', isOutdoor: false },
        { id: 'kitchen', name: 'Kitchen', icon: 'üç≥', sensor: '[Kitchen] Temperature & Humidity', entityId: 'sensor.kitchen_temperature_humidity', isOutdoor: false },
        { id: 'bathroom', name: 'Bathroom', icon: 'üöø', sensor: '[Bath] Temperature & Humidity', entityId: 'sensor.bath_temperature_humidity', isOutdoor: false },
        { id: 'balcony', name: 'Balcony', icon: 'üåø', sensor: '[Balcony] Temperature & Humidity', entityId: 'sensor.balcony_temperature_humidity', isOutdoor: true },
        { id: 'hallway', name: 'Hallway', icon: 'üö∂', sensor: '[Hallway] CO2', entityId: 'sensor.hallway_co2', isOutdoor: false }
      ],
      staleThreshold: 5 * 60 * 1000,
      maxHistoryPoints: 500,
      historyHours: 6,
      // Thermostats (SONOFF TRVZB)
      thermostats: [
        { id: 'study', name: 'Study', icon: 'üìö', sensor: '[Study] Thermostat', entityId: 'climate.study_thermostat', roomId: 'study', roomSensor: '[Study] Temperature & Humidity' },
        { id: 'living_inner', name: 'Living Inner', icon: 'üõãÔ∏è', sensor: '[Living] Thermostat Inner', entityId: 'climate.living_thermostat_inner', roomId: 'living', roomSensor: '[Living] Temperature & Humidity' },
        { id: 'living_outer', name: 'Living Outer', icon: 'üõãÔ∏è', sensor: '[Living] Thermostat Outer', entityId: 'climate.living_thermostat_outer', roomId: 'living', roomSensor: '[Living] Temperature & Humidity' },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', sensor: '[Bed] Thermostat', entityId: 'climate.bedroom_thermostat', roomId: 'bedroom', roomSensor: '[Bed] Temperature & Humidity Sensor' }
      ]
    };

    // Room-to-sensors mapping for multi-sensor support
    const ROOM_SENSORS = {
      living: {
        climate: [
          { name: '[Living] Temperature & Humidity', label: 'West', isPrimary: true },
          { name: '[Living] Temperature & Humidity 6', label: 'North' },
          { name: '[Living] Temperature & Humidity 7', label: 'Inner' }
        ],
        thermostat: [
          { name: '[Living] Thermostat Inner', label: 'Heater Inner' },
          { name: '[Living] Thermostat Outer', label: 'Heater Outer' }
        ],
        co2: [
          { name: '[Hallway] CO2', label: 'Air Quality' }
        ]
      },
      bedroom: {
        climate: [
          { name: '[Bed] Temperature & Humidity Sensor', label: 'East', isPrimary: true },
          { name: '[Bed] Temperature & Humidity Sensor 9', label: 'North' }
        ],
        thermostat: [
          { name: '[Bed] Thermostat', label: 'Heater' }
        ]
      },
      study: {
        climate: [
          { name: '[Study] Temperature & Humidity', label: 'West', isPrimary: true },
          { name: '[Study] Temperature & Humidity 8', label: 'Inner' }
        ],
        thermostat: [
          { name: '[Study] Thermostat', label: 'Heater' }
        ]
      },
      kitchen: {
        climate: [
          { name: '[Kitchen] Temperature & Humidity', label: 'East', isPrimary: true },
          { name: '[Kitchen] Temperature & Humidity 10', label: 'Inner' }
        ]
      },
      bathroom: {
        climate: [
          { name: '[Bath] Temperature & Humidity', label: 'East', isPrimary: true },
          { name: '[Bath] Temperature & Humidity 11', label: 'Inner' }
        ]
      },
      balcony: {
        climate: [
          { name: '[Balcony] Temperature & Humidity', label: 'Outdoor', isPrimary: true }
        ]
      },
      hallway: {
        climate: [
          { name: '[Hallway] CO2', label: 'CO2 Sensor', isPrimary: true }
        ],
        co2: [
          { name: '[Hallway] CO2', label: 'Air Quality' }
        ]
      }
    };

    // Make CONFIG globally available for modules
    window.CONFIG = CONFIG;
    window.ROOM_SENSORS = ROOM_SENSORS;

    // ========================================
    // ALPINE STORES
    // ========================================
    document.addEventListener('alpine:init', () => {

      // Config store
      Alpine.store('config', CONFIG);

      // MQTT connection store
      Alpine.store('mqtt', {
        connected: false,
        connecting: true,
        client: null,

        connect() {
          this.connecting = true;

          this.client = mqtt.connect(CONFIG.mqttUrl, {
            clientId: 'climate-' + Math.random().toString(16).substr(2, 8),
            reconnectPeriod: 3000,
            connectTimeout: 10000
          });

          this.client.on('connect', () => {
            this.connected = true;
            this.connecting = false;

            // Subscribe to room sensors (primary)
            CONFIG.rooms.forEach(room => {
              this.client.subscribe(`${CONFIG.baseTopic}/${room.sensor}`, { qos: 0 });
            });

            // Subscribe to all additional sensors from ROOM_SENSORS
            Object.values(ROOM_SENSORS).forEach(roomConfig => {
              const allSensors = [
                ...(roomConfig.climate || []),
                ...(roomConfig.co2 || []),
                ...(roomConfig.motion || []),
                ...(roomConfig.contact || [])
              ];
              allSensors.forEach(sensor => {
                this.client.subscribe(`${CONFIG.baseTopic}/${sensor.name}`, { qos: 0 });
              });
            });

            // Subscribe to light topics (state and availability)
            Alpine.store('lights').list.forEach(light => {
              this.client.subscribe(`${CONFIG.baseTopic}/${light.topic}`, { qos: 0 });
              this.client.subscribe(`${CONFIG.baseTopic}/${light.topic}/availability`, { qos: 0 });
            });
          });

          this.client.on('message', (topic, message) => {
            try {
              const msgStr = message.toString();
              const deviceName = topic.replace(`${CONFIG.baseTopic}/`, '');

              // Check if it's an availability message
              if (topic.endsWith('/availability')) {
                const lightTopic = deviceName.replace('/availability', '');
                // Handle both JSON {"state":"online"} and plain string "online"
                let isOnline;
                try {
                  const data = JSON.parse(msgStr);
                  isOnline = data.state === 'online';
                } catch {
                  isOnline = msgStr === 'online';
                }
                Alpine.store('lights').setAvailability(lightTopic, isOnline);
                return;
              }

              const data = JSON.parse(msgStr);

              // Check if it's a room sensor (primary)
              const roomConfig = CONFIG.rooms.find(r => r.sensor === deviceName);
              if (roomConfig) {
                Alpine.store('rooms').updateRoom(deviceName, data);
                // Note: updateRoom() calls updateSensor() internally
                return;
              }

              // Check if it's an additional sensor in any room
              const sensorFound = Alpine.store('rooms').updateSensor(deviceName, data);
              if (sensorFound) return;

              // Check if it's a light
              Alpine.store('lights').updateLight(deviceName, data);
            } catch (e) {
              console.error('MQTT parse error:', e);
            }
          });

          this.client.on('error', (err) => console.error('MQTT Error:', err));
          this.client.on('close', () => { this.connected = false; this.connecting = true; });
          this.client.on('reconnect', () => { this.connecting = true; });
        }
      });

      // Rooms data store (with multi-sensor support)
      Alpine.store('rooms', {
        list: CONFIG.rooms.map(r => {
          // Get all sensors for this room from ROOM_SENSORS config
          const roomSensorConfig = ROOM_SENSORS[r.id] || { climate: [] };
          const allSensors = [
            ...(roomSensorConfig.climate || []).map(s => ({ ...s, type: 'climate' })),
            ...(roomSensorConfig.co2 || []).map(s => ({ ...s, type: 'co2' })),
            ...(roomSensorConfig.thermostat || []).map(s => ({ ...s, type: 'thermostat' })),
            ...(roomSensorConfig.motion || []).map(s => ({ ...s, type: 'motion' })),
            ...(roomSensorConfig.contact || []).map(s => ({ ...s, type: 'contact' }))
          ];

          return {
            ...r,
            temperature: null,
            humidity: null,
            lastSeen: null,
            stale: false,
            tempHistory: [],
            humidHistory: [],
            // Multi-sensor support
            sensors: allSensors.map(s => ({
              ...s,
              temperature: null,
              humidity: null,
              co2: null,
              battery: null,
              lastSeen: null,
              stale: false
            })),
            // Computed room averages
            avgTemperature: null,
            avgHumidity: null,
            tempSpread: null
          };
        }),
        lastUpdate: null,
        loading: false,
        version: 0,  // Reactive trigger for header updates

        get historyCount() {
          return this.list.reduce((sum, r) => sum + r.tempHistory.length + r.humidHistory.length, 0);
        },

        // Indoor rooms only (excludes outdoor rooms like balcony)
        get indoorRooms() {
          return this.list.filter(r => !r.isOutdoor);
        },

        // Home-wide average temperature (indoor rooms only)
        get avgTemperature() {
          const temps = this.indoorRooms.filter(r => r.avgTemperature != null).map(r => r.avgTemperature);
          if (temps.length === 0) return null;
          return temps.reduce((a, b) => a + b, 0) / temps.length;
        },

        // Home-wide average humidity (indoor rooms only)
        get avgHumidity() {
          const humids = this.indoorRooms.filter(r => r.avgHumidity != null).map(r => r.avgHumidity);
          if (humids.length === 0) return null;
          return humids.reduce((a, b) => a + b, 0) / humids.length;
        },

        // CO2 value from hallway sensor
        get co2Value() {
          for (const room of this.list) {
            const co2Sensor = room.sensors.find(s => s.co2 != null);
            if (co2Sensor) return co2Sensor.co2;
          }
          return null;
        },

        updateRoom(sensorName, data) {
          const roomIndex = this.list.findIndex(r => r.sensor === sensorName);
          if (roomIndex === -1) return;

          const room = this.list[roomIndex];
          const now = Date.now();

          let sensorTime = now;
          if (data.last_seen) {
            sensorTime = typeof data.last_seen === 'number' ? data.last_seen : new Date(data.last_seen).getTime();
          }

          if (data.temperature !== undefined) {
            room.temperature = data.temperature;
            room.tempHistory.push({ time: sensorTime, value: data.temperature });
            if (room.tempHistory.length > CONFIG.maxHistoryPoints) room.tempHistory.shift();
          }

          if (data.humidity !== undefined) {
            room.humidity = data.humidity;
            room.humidHistory.push({ time: sensorTime, value: data.humidity });
            if (room.humidHistory.length > CONFIG.maxHistoryPoints) room.humidHistory.shift();
          }

          room.lastSeen = sensorTime;
          room.stale = false;
          this.lastUpdate = now;
          this.version++;  // Force header reactivity

          // Also update in the sensors array if this is a primary sensor
          this.updateSensor(sensorName, data);
        },

        // Update individual sensor in any room's sensors array
        // Updates ALL sensors with matching name (same physical device may be registered as multiple types)
        updateSensor(sensorName, data) {
          const now = Date.now();
          let found = false;

          for (const room of this.list) {
            // Find ALL sensors with this name (not just the first)
            const sensors = room.sensors.filter(s => s.name === sensorName);
            if (sensors.length > 0) {
              found = true;

              let sensorTime = now;
              if (data.last_seen) {
                sensorTime = typeof data.last_seen === 'number' ? data.last_seen : new Date(data.last_seen).getTime();
              }

              // Update ALL matching sensors
              for (const sensor of sensors) {
                if (data.temperature !== undefined) sensor.temperature = data.temperature;
                if (data.local_temperature !== undefined) sensor.temperature = data.local_temperature;
                if (data.humidity !== undefined) sensor.humidity = data.humidity;
                if (data.co2 !== undefined) sensor.co2 = data.co2;
                if (data.battery !== undefined) sensor.battery = data.battery;

                sensor.lastSeen = sensorTime;
                sensor.stale = false;
              }

              // Recalculate room averages
              this._recalculateRoomAverages(room);
              this.lastUpdate = now;
              this.version++;  // Force header reactivity
            }
          }
          return found;
        },

        // Recalculate room averages from all temperature sensors (climate + thermostat)
        _recalculateRoomAverages(room) {
          // Include both climate and thermostat sensors for temperature average
          const tempSensors = room.sensors.filter(s =>
            (s.type === 'climate' || s.type === 'thermostat') && s.temperature != null
          );

          if (tempSensors.length === 0) {
            room.avgTemperature = room.temperature;
            room.avgHumidity = room.humidity;
            room.tempSpread = null;
            return;
          }

          const temps = tempSensors.map(s => s.temperature);
          room.avgTemperature = temps.reduce((a, b) => a + b, 0) / temps.length;
          room.tempSpread = Math.max(...temps) - Math.min(...temps);

          // Humidity only from climate sensors (thermostats don't have humidity)
          const humids = tempSensors.filter(s => s.humidity != null).map(s => s.humidity);
          if (humids.length > 0) {
            room.avgHumidity = humids.reduce((a, b) => a + b, 0) / humids.length;
          }
        },

        async loadHistorical() {
          this.loading = true;
          for (const room of this.list) {
            try {
              const tempQuery = `SELECT value FROM "¬∞C" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_temperature' AND time > now() - ${CONFIG.historyHours}h ORDER BY time ASC`;
              const tempUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(tempQuery)}`;
              const tempRes = await fetch(tempUrl);
              const tempData = await tempRes.json();

              if (tempData.results?.[0]?.series?.[0]?.values) {
                const values = tempData.results[0].series[0].values;
                room.tempHistory = values.map(v => ({ time: new Date(v[0]).getTime(), value: v[1] }));
                room.temperature = values[values.length - 1][1];
                room.lastSeen = new Date(values[values.length - 1][0]).getTime();
              }

              const humidQuery = `SELECT value FROM "%" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_humidity' AND time > now() - ${CONFIG.historyHours}h ORDER BY time ASC`;
              const humidUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(humidQuery)}`;
              const humidRes = await fetch(humidUrl);
              const humidData = await humidRes.json();

              if (humidData.results?.[0]?.series?.[0]?.values) {
                const values = humidData.results[0].series[0].values;
                room.humidHistory = values.map(v => ({ time: new Date(v[0]).getTime(), value: v[1] }));
                room.humidity = values[values.length - 1][1];
              }
            } catch (e) {
              console.error(`Failed to load history for ${room.name}:`, e);
            }
          }
          this.lastUpdate = Date.now();
          this.loading = false;
        },

        checkStale() {
          const now = Date.now();
          this.list.forEach(room => {
            if (room.lastSeen && (now - room.lastSeen) > CONFIG.staleThreshold) {
              room.stale = true;
            }
          });
        }
      });

      // Lights store
      Alpine.store('lights', {
        list: [
          {
            id: 'study_light',
            name: 'Study Light',
            icon: 'üìö',
            topic: '[Study] IKEA Light',
            state: 'OFF',
            brightness: 254,
            colorTemp: 370,
            linkquality: null,
            lastSeen: null,
            syncing: false,
            available: true
          },
          {
            id: 'living_light',
            name: 'Living Room Light',
            icon: 'üõãÔ∏è',
            topic: '[Living] IKEA Light',
            state: 'OFF',
            brightness: 254,
            colorTemp: 370,
            linkquality: null,
            lastSeen: null,
            syncing: false,
            available: true
          }
        ],
        syncing: false,
        initializing: true,

        get anyLightSyncing() {
          return this.list.some(l => l.syncing);
        },

        get lightsOnCount() {
          return this.list.filter(l => l.state === 'ON').length;
        },

        presets: {
          reading: { brightness: 254, colorTemp: 300 },
          relax: { brightness: 150, colorTemp: 400 },
          bright: { brightness: 254, colorTemp: 250 },
          night: { brightness: 30, colorTemp: 454 }
        },

        scenes: {
          movie: { state: 'ON', brightness: 50, colorTemp: 400 },
          work: { state: 'ON', brightness: 254, colorTemp: 280 },
          evening: { state: 'ON', brightness: 150, colorTemp: 380 },
          goodnight: { state: 'OFF' }
        },

        updateLight(topic, data) {
          const light = this.list.find(l => l.topic === topic);
          if (light) {
            if (data.state !== undefined) light.state = data.state;
            if (data.brightness !== undefined) light.brightness = data.brightness;
            if (data.color_temp !== undefined) light.colorTemp = data.color_temp;
            if (data.linkquality !== undefined) light.linkquality = data.linkquality;
            light.lastSeen = Date.now();
            light.syncing = false;
            this.initializing = false;
            this.syncing = this.anyLightSyncing;
          }
        },

        setAvailability(topic, isOnline) {
          const light = this.list.find(l => l.topic === topic);
          if (light) {
            light.available = isOnline;
            console.log(`Light ${light.name} availability: ${isOnline ? 'online' : 'offline'}`);
          }
        },

        publishCommand(light, payload) {
          const client = Alpine.store('mqtt').client;
          if (!client || !Alpine.store('mqtt').connected) {
            console.error('MQTT not connected');
            return;
          }

          // Set syncing state
          light.syncing = true;
          this.syncing = true;

          const topic = `zigbee2mqtt/${light.topic}/set`;
          client.publish(topic, JSON.stringify(payload), { qos: 0 }, (err) => {
            if (err) {
              console.error('Failed to publish:', err);
              light.syncing = false;
              this.syncing = this.anyLightSyncing;
            } else {
              // Syncing will be cleared when we receive the state update
              // Set a timeout to clear syncing if no response
              setTimeout(() => {
                if (light.syncing) {
                  light.syncing = false;
                  this.syncing = this.anyLightSyncing;
                }
              }, 3000);
            }
          });
        },

        toggleLight(light) {
          const newState = light.state === 'ON' ? 'OFF' : 'ON';
          this.publishCommand(light, { state: newState });
          light.state = newState; // Optimistic update
        },

        toggleAllLights() {
          const allOn = this.list.every(l => l.state === 'ON');
          const newState = allOn ? 'OFF' : 'ON';
          this.list.forEach(light => {
            this.publishCommand(light, { state: newState });
            light.state = newState;
          });
        },

        setBrightness(light, value) {
          const brightness = parseInt(value);
          this.publishCommand(light, { brightness });
          // Local state already updated by x-model
        },

        setColorTemp(light, value) {
          const colorTemp = parseInt(value);
          this.publishCommand(light, { color_temp: colorTemp });
          // Local state already updated by x-model
        },

        applyPreset(light, presetName) {
          const preset = this.presets[presetName];
          if (preset) {
            this.publishCommand(light, {
              brightness: preset.brightness,
              color_temp: preset.colorTemp
            });
            light.brightness = preset.brightness;
            light.colorTemp = preset.colorTemp;
          }
        },

        applyScene(sceneName) {
          const scene = this.scenes[sceneName];
          if (scene) {
            this.list.forEach(light => {
              this.publishCommand(light, scene);
              if (scene.state !== undefined) light.state = scene.state;
              if (scene.brightness !== undefined) light.brightness = scene.brightness;
              if (scene.colorTemp !== undefined) light.colorTemp = scene.colorTemp;
            });
          }
        }
      });

      // Room detail modal store
      Alpine.store('roomDetail', {
        selectedRoom: null,
        timeRange: '6h',
        loading: false,
        tempHistory: [],
        humidHistory: [],
        timeRanges: ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d'],

        open(room) {
          this.selectedRoom = room;
          this.timeRange = '6h';
          this.loadData();
        },

        close() {
          this.selectedRoom = null;
        },

        async setTimeRange(range) {
          this.timeRange = range;
          await this.loadData();
        },

        async loadData() {
          if (!this.selectedRoom) return;
          this.loading = true;

          try {
            const room = this.selectedRoom;

            const tempQuery = `SELECT value FROM "¬∞C" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_temperature' AND time > now() - ${this.timeRange} ORDER BY time ASC`;
            const tempUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(tempQuery)}`;
            const tempRes = await fetch(tempUrl);
            const tempData = await tempRes.json();

            if (tempData.results?.[0]?.series?.[0]?.values) {
              this.tempHistory = tempData.results[0].series[0].values.map(v => ({
                time: new Date(v[0]).getTime(),
                value: v[1]
              }));
            } else {
              this.tempHistory = [];
            }

            const humidQuery = `SELECT value FROM "%" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_humidity' AND time > now() - ${this.timeRange} ORDER BY time ASC`;
            const humidUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(humidQuery)}`;
            const humidRes = await fetch(humidUrl);
            const humidData = await humidRes.json();

            if (humidData.results?.[0]?.series?.[0]?.values) {
              this.humidHistory = humidData.results[0].series[0].values.map(v => ({
                time: new Date(v[0]).getTime(),
                value: v[1]
              }));
            } else {
              this.humidHistory = [];
            }

            console.log(`Loaded ${this.tempHistory.length} temp, ${this.humidHistory.length} humid points for ${this.timeRange}`);
          } catch (e) {
            console.error('Failed to load modal data:', e);
          }

          this.loading = false;
          setTimeout(() => this.drawCharts(), 50);
        },

        drawCharts() {
          this.drawChart('modal-chart-temp', this.tempHistory, '¬∞C', 'var(--color-primary)');
          this.drawChart('modal-chart-humid', this.humidHistory, '%', 'var(--color-success)');
        },

        drawChart(id, data, unit, color) {
          const svg = document.getElementById(id);
          if (!svg || data.length === 0) return;

          const width = svg.clientWidth || 700;
          const height = svg.clientHeight || 180;
          const padding = { top: 20, right: 50, bottom: 30, left: 50 };
          const chartWidth = width - padding.left - padding.right;
          const chartHeight = height - padding.top - padding.bottom;

          const values = data.map(d => d.value);
          const times = data.map(d => d.time);
          const minVal = Math.floor(Math.min(...values) - 1);
          const maxVal = Math.ceil(Math.max(...values) + 1);
          const minTime = Math.min(...times);
          const maxTime = Math.max(...times);
          const valueRange = maxVal - minVal || 1;
          const timeRange = maxTime - minTime || 1;

          let svgContent = '';

          const ySteps = 5;
          for (let i = 0; i <= ySteps; i++) {
            const y = padding.top + (i / ySteps) * chartHeight;
            const val = maxVal - (i / ySteps) * valueRange;
            svgContent += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="#e0e0e0" stroke-dasharray="3,3"/>`;
            svgContent += `<text x="${padding.left - 8}" y="${y + 4}" text-anchor="end" fill="var(--color-text-tertiary)" font-size="10">${val.toFixed(1)}${unit}</text>`;
          }

          const xSteps = Math.min(6, data.length);
          for (let i = 0; i <= xSteps; i++) {
            const x = padding.left + (i / xSteps) * chartWidth;
            const time = new Date(minTime + (i / xSteps) * timeRange);
            const label = time.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
            svgContent += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" stroke="#e0e0e0" stroke-dasharray="3,3"/>`;
            svgContent += `<text x="${x}" y="${height - 8}" text-anchor="middle" fill="var(--color-text-tertiary)" font-size="10">${label}</text>`;
          }

          svgContent += `<line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" stroke="var(--color-text-tertiary)"/>`;
          svgContent += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" stroke="var(--color-text-tertiary)"/>`;

          if (data.length >= 2) {
            const points = data.map(d => {
              const x = padding.left + ((d.time - minTime) / timeRange) * chartWidth;
              const y = padding.top + ((maxVal - d.value) / valueRange) * chartHeight;
              return `${x},${y}`;
            }).join(' ');

            const areaPoints = `${padding.left},${height - padding.bottom} ${points} ${width - padding.right},${height - padding.bottom}`;
            svgContent += `<polygon fill="${color}" opacity="0.15" points="${areaPoints}"/>`;
            svgContent += `<polyline fill="none" stroke="${color}" stroke-width="2.5" points="${points}"/>`;

            const lastPoint = data[data.length - 1];
            const lastX = padding.left + ((lastPoint.time - minTime) / timeRange) * chartWidth;
            const lastY = padding.top + ((maxVal - lastPoint.value) / valueRange) * chartHeight;
            svgContent += `<circle cx="${lastX}" cy="${lastY}" r="5" fill="${color}"/>`;
          }

          svg.innerHTML = svgContent;
        },

        getMinMax() {
          if (!this.tempHistory.length) return '--';
          const temps = this.tempHistory.map(d => d.value);
          return `${Math.min(...temps).toFixed(1)}¬∞ / ${Math.max(...temps).toFixed(1)}¬∞`;
        },

        formatUpdate(lastSeen) {
          if (!lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - lastSeen) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      });

      // Weather store (fetches forecast from Home Assistant via nginx proxy)
      Alpine.store('weather', {
        temperature: null,
        humidity: null,
        condition: null,
        conditionIcon: null,
        loading: false,
        lastUpdate: null,
        error: null,

        // Home Assistant API config (via nginx proxy to avoid CORS)
        entityId: 'weather.forecast_home',
        haToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkZjJhY2UwMTBmNGY0Y2NiYTI0ZGZhMGUyZjg5NWYzNiIsImlhdCI6MTc2Njg1NjU1NywiZXhwIjoyMDgyMjE2NTU3fQ.2t04JrsGafT9hDhg0BniYG90i1O7a7DHqpdst9x3-no',

        pollInterval: 5 * 60 * 1000,
        pollTimer: null,

        init() {
          console.log('Weather store: Initializing...');
          this.fetchWeather();
          this.pollTimer = setInterval(() => this.fetchWeather(), this.pollInterval);
        },

        async fetchWeather() {
          this.loading = true;
          this.error = null;

          try {
            // Use nginx proxy to avoid CORS: /api/ha/ -> homeassistant:8123/api/
            const response = await fetch(
              `/api/ha/states/${this.entityId}`,
              {
                headers: {
                  'Authorization': `Bearer ${this.haToken}`,
                  'Content-Type': 'application/json'
                }
              }
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            this.temperature = data.attributes.temperature;
            this.humidity = data.attributes.humidity;
            this.condition = data.state;
            this.conditionIcon = this.getConditionIcon(data.state);
            this.lastUpdate = Date.now();
            console.log('Weather store: Updated', { temp: this.temperature, condition: this.condition });
          } catch (e) {
            console.error('Weather store: Fetch error:', e);
            this.error = e.message;
          } finally {
            this.loading = false;
          }
        },

        getConditionIcon(condition) {
          const iconMap = {
            'sunny': '‚òÄÔ∏è',
            'clear-night': 'üåô',
            'partlycloudy': '‚õÖ',
            'cloudy': '‚òÅÔ∏è',
            'rainy': 'üåßÔ∏è',
            'pouring': 'üåßÔ∏è',
            'snowy': 'üå®Ô∏è',
            'snowy-rainy': 'üå®Ô∏è',
            'fog': 'üå´Ô∏è',
            'hail': 'üå®Ô∏è',
            'lightning': '‚ö°',
            'lightning-rainy': '‚õàÔ∏è',
            'windy': 'üí®',
            'windy-variant': 'üí®',
            'exceptional': '‚ö†Ô∏è'
          };
          return iconMap[condition] || 'üå°Ô∏è';
        }
      });

      // Initialize weather store after a short delay
      setTimeout(() => Alpine.store('weather')?.init(), 2000);
    });

    // ========================================
    // MAIN APP COMPONENT
    // ========================================
    function app() {
      return {
        currentView: 'comfort',
        currentDateTime: '',
        now: Date.now(),
        panelOpen: localStorage.getItem('panel-open') !== 'false',

        get lastUpdateText() {
          const lastUpdate = Alpine.store('rooms').lastUpdate;
          if (!lastUpdate) return 'Waiting...';
          const seconds = Math.floor((this.now - lastUpdate) / 1000);
          if (seconds < 5) return 'Just now';
          if (seconds < 60) return `${seconds}s ago`;
          return `${Math.floor(seconds / 60)}m ago`;
        },

        init() {
          // Restore last view
          const saved = localStorage.getItem('dashboard-view');
          if (saved) this.currentView = saved;

          // Update time
          this.updateDateTime();
          setInterval(() => {
            this.updateDateTime();
            this.now = Date.now();
          }, 1000);

          // Check stale
          setInterval(() => Alpine.store('rooms').checkStale(), 10000);

          // Load historical data and connect MQTT
          Alpine.store('rooms').loadHistorical();
          Alpine.store('mqtt').connect();

          // Keyboard shortcuts are now handled by navigation component (single source)
          // Listen for view changes from navigation component
          document.addEventListener('view-changed', (e) => {
            if (e.detail && e.detail.view) {
              this.currentView = e.detail.view;
            }
          });
        },

        setView(view) {
          this.currentView = view;
          localStorage.setItem('dashboard-view', view);
        },

        updateDateTime() {
          const now = new Date();
          this.currentDateTime = now.toLocaleDateString('en-AU', {
            weekday: 'short', month: 'short', day: 'numeric',
            hour: 'numeric', minute: '2-digit', hour12: true
          });
        },

        togglePanel() {
          this.panelOpen = !this.panelOpen;
          localStorage.setItem('panel-open', this.panelOpen);
        },

        getOpenContactCount() {
          const contacts = Alpine.store('sensors')?.sensorsByType?.contact || [];
          const liveData = Alpine.store('sensors')?.liveData || {};
          return contacts.filter(s => liveData[s.ieee_address]?.contact === false).length;
        },

        // Short names for contact sensors in sidebar
        contactShortNames: {
          '[Bath] Window Contact Sensor': 'Bath Window',
          '[Bed] Window Contact Sensor': 'Bed Window',
          '[Kitchen] Window Contact Sensor': 'Kitchen Window',
          '[Study] Window Contact Sensor - Large': 'Study Big',
          '[Study] Window Contact Sensor - Small': 'Study Small',
          '[Living] Window Contact Sensor - Balcony Door': 'Balcony Door',
          '[Living] Window Contact Sensor - Window': 'Living Window',
          '[Hallway] Window Contact Sensor - Main Door': 'Main Door'
        },

        getContactShortName(friendlyName) {
          return this.contactShortNames[friendlyName] || friendlyName.replace(/\[|\]/g, '').trim();
        }
      };
    }

    // ========================================
    // NAVIGATION COMPONENT (Grouped with More Dropdown)
    // ========================================
    const VIEW_CATEGORIES = [
      {
        id: 'monitor', name: 'Monitor', icon: 'üìà',
        views: [
          { id: 'comfort', name: 'Score', icon: 'üéØ', title: 'Comfort Score', key: '1', primary: true },
          { id: 'compare', name: 'Compare', icon: 'üìä', title: 'Room Comparison', key: '2', primary: true },
          { id: 'timeline', name: 'Timeline', icon: 'üìñ', title: 'Event Timeline', key: '5' },
          { id: 'co2', name: 'CO2', icon: 'üí®', title: 'CO2 Monitor', key: '0' }
        ]
      },
      {
        id: 'visualize', name: 'Visualize', icon: 'üëÅÔ∏è',
        views: [
          { id: '3d', name: '3D', icon: 'üèóÔ∏è', title: '3D Floor Plan', key: '4' },
          { id: 'isometric', name: 'Isometric', icon: 'üî∑', title: 'Isometric View', key: 'I' },
          { id: 'network', name: 'Network', icon: 'üì°', title: 'Zigbee Network', key: 'N' }
        ]
      },
      {
        id: 'control', name: 'Control', icon: 'üéõÔ∏è',
        views: [
          { id: 'lights', name: 'Lights', icon: 'üí°', title: 'Light Control', key: '7', primary: true },
          { id: 'heater', name: 'Heater', icon: 'üî•', title: 'Heater Control', key: 'H' },
          { id: 'mailbox', name: 'Mailbox', icon: 'üì¨', title: 'Mailbox Monitor', key: 'M' }
        ]
      },
      {
        id: 'display', name: 'Display', icon: 'üì∫',
        views: [
          { id: 'classic', name: 'Classic', icon: 'üÉè', title: 'Classic Cards', key: '8' }
        ]
      },
      {
        id: 'settings', name: 'Settings', icon: '‚öôÔ∏è',
        views: [
          { id: 'config', name: 'Config', icon: '‚öôÔ∏è', title: 'Sensor Config', key: '9' }
        ]
      }
    ];

    // Classic first per user preference
    const ALL_VIEWS = (() => {
      const all = VIEW_CATEGORIES.flatMap(cat => cat.views);
      const classic = all.find(v => v.id === 'classic');
      return classic ? [classic, ...all.filter(v => v.id !== 'classic')] : all;
    })();
    const PRIMARY_VIEWS = ALL_VIEWS.filter(v => v.primary);
    const OVERFLOW_CATEGORIES = VIEW_CATEGORIES.map(cat => ({
      ...cat,
      views: cat.views.filter(v => !v.primary)
    })).filter(cat => cat.views.length > 0);
    const KEYBOARD_SHORTCUTS = Object.fromEntries(ALL_VIEWS.map(v => [v.key, v.id]));

    function navigation() {
      return {
        moreMenuOpen: false,
        mobileMenuOpen: false,
        currentView: 'comfort',
        primaryViews: PRIMARY_VIEWS,
        overflowCategories: OVERFLOW_CATEGORIES,
        allViews: ALL_VIEWS,

        init() {
          // Restore last view from localStorage
          const saved = localStorage.getItem('dashboard-view');
          if (saved && ALL_VIEWS.find(v => v.id === saved)) {
            this.currentView = saved;
          }

          // Sync with app component
          const appEl = document.querySelector('[x-data="app()"]');
          if (appEl && appEl._x_dataStack && appEl._x_dataStack[0]) {
            this.currentView = appEl._x_dataStack[0].currentView || this.currentView;
          }
          // Keyboard shortcuts handled via @keydown.window Alpine directive
        },

        handleKeydown(e) {
          // Ignore if typing in an input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          if (e.ctrlKey || e.metaKey) return;

          const key = e.key.toUpperCase();
          // Letter shortcuts (I, N, H, M)
          if (KEYBOARD_SHORTCUTS[key]) {
            e.preventDefault();
            this.setView(KEYBOARD_SHORTCUTS[key]);
            return;
          }
          // Number shortcuts (1-9, 0)
          if (KEYBOARD_SHORTCUTS[e.key]) {
            e.preventDefault();
            this.setView(KEYBOARD_SHORTCUTS[e.key]);
            return;
          }
        },

        setView(viewId) {
          if (this.currentView !== viewId) {
            this.currentView = viewId;
            localStorage.setItem('dashboard-view', viewId);
            // Sync with app component
            const appEl = document.querySelector('[x-data="app()"]');
            if (appEl && appEl._x_dataStack && appEl._x_dataStack[0]) {
              appEl._x_dataStack[0].currentView = viewId;
            }
          }
          this.moreMenuOpen = false;
          this.mobileMenuOpen = false;
        },

        isActive(viewId) {
          return this.currentView === viewId;
        },

        isOverflowActive() {
          return !PRIMARY_VIEWS.find(v => v.id === this.currentView) &&
                 ALL_VIEWS.find(v => v.id === this.currentView);
        },

        toggleMoreMenu() {
          this.moreMenuOpen = !this.moreMenuOpen;
          this.mobileMenuOpen = false;
        },

        toggleMobileMenu() {
          this.mobileMenuOpen = !this.mobileMenuOpen;
          this.moreMenuOpen = false;
        }
      };
    }

    // ========================================
    // COMFORT SCORE VIEW (Vision 1)
    // ========================================
    function comfortScoreView() {
      return {
        homeScore: 0,
        roomScores: [],
        suggestions: [],
        showBreakdown: false,

        init() {
          this.updateScores();
          this.$watch('$store.rooms.list', () => this.updateScores());
        },

        updateScores() {
          const rooms = this.$store.rooms.list;

          this.roomScores = rooms
            .filter(r => r.temperature !== null && r.humidity !== null)
            .map(room => ({
              ...room,
              score: this.calculateComfort(room.temperature, room.humidity)
            }))
            .sort((a, b) => b.score - a.score);

          this.homeScore = this.calculateHomeScore(rooms);
          this.suggestions = this.generateSuggestions(rooms).slice(0, 2);
        },

        calculateComfort(temp, humidity) {
          if (temp === null || humidity === null) return 0;
          let tempScore = 70;
          if (temp < 20) tempScore = Math.max(0, 70 - (20 - temp) * 10);
          else if (temp > 26) tempScore = Math.max(0, 70 - (temp - 26) * 10);
          else tempScore = 70 - Math.abs(temp - 23) * 2;

          let humidScore = 30;
          if (humidity < 40) humidScore = Math.max(0, 30 - (40 - humidity));
          else if (humidity > 60) humidScore = Math.max(0, 30 - (humidity - 60) * 1.5);
          else humidScore = 30 - Math.abs(humidity - 50) * 0.3;

          return Math.round(Math.max(0, Math.min(100, tempScore + humidScore)));
        },

        calculateHomeScore(rooms) {
          const weights = { 'Living Room': 1.5, 'Bedroom': 1.3, 'Study': 1.0, 'Kitchen': 0.8, 'Bathroom': 0.5 };
          const valid = rooms.filter(r => r.temperature !== null);
          if (valid.length === 0) return 0;

          let sum = 0, total = 0;
          valid.forEach(r => {
            const w = weights[r.name] || 1;
            sum += this.calculateComfort(r.temperature, r.humidity) * w;
            total += w;
          });
          return Math.round(sum / total);
        },

        generateSuggestions(rooms) {
          const valid = rooms.filter(r => r.temperature !== null && r.humidity !== null);
          if (valid.length === 0) return [];

          const suggestions = [];
          const hottest = valid.reduce((a, b) => a.temperature > b.temperature ? a : b);
          const mostHumid = valid.reduce((a, b) => a.humidity > b.humidity ? a : b);

          if (mostHumid.humidity > 65) {
            suggestions.push({ type: 'action', icon: 'üí®', title: 'Improve ventilation',
              message: `${mostHumid.name} humidity is high (${mostHumid.humidity}%)` });
          }
          if (hottest.temperature > 28) {
            const coldest = valid.reduce((a, b) => a.temperature < b.temperature ? a : b);
            suggestions.push({ type: 'tip', icon: 'üèÉ', title: 'Go to cooler room',
              message: `${coldest.name} is ${(hottest.temperature - coldest.temperature).toFixed(1)}¬∞ cooler` });
          }
          return suggestions;
        },

        getLabel() {
          if (this.homeScore >= 90) return 'Perfect';
          if (this.homeScore >= 75) return 'Comfortable';
          if (this.homeScore >= 60) return 'Okay';
          if (this.homeScore >= 40) return 'Uncomfortable';
          return 'Poor';
        },

        getColor() {
          if (this.homeScore >= 90) return '#34C759';
          if (this.homeScore >= 75) return '#30D158';
          if (this.homeScore >= 60) return '#FFD60A';
          if (this.homeScore >= 40) return '#FF9500';
          return '#FF3B30';
        },

        getRoomColor(score) {
          if (score >= 75) return 'var(--color-success)';
          if (score >= 50) return 'var(--color-warning)';
          return 'var(--color-danger)';
        },

        getScoreArc() {
          const percent = this.homeScore / 100;
          const circumference = 2 * Math.PI * 90;
          return `${percent * circumference} ${circumference}`;
        },

        openRoom(room) { this.$store.roomDetail.open(room); }
      };
    }

    // ========================================
    // BAR COMPARE VIEW (Vision 2)
    // ========================================
    function barCompareView() {
      return {
        sortBy: 'temperature',
        sortDirection: 'desc',
        viewMode: 'both',
        insights: [],
        tempScale: { min: 18, max: 32 },
        humidityScale: { min: 0, max: 100 },
        comfortZone: { temp: { min: 22, max: 26 }, humidity: { min: 40, max: 60 } },

        init() {
          const saved = localStorage.getItem('bar-sort');
          if (saved) this.sortBy = saved;
          const savedView = localStorage.getItem('bar-view');
          if (savedView) this.viewMode = savedView;
          this.updateInsights();
          this.$watch('$store.rooms.list', () => this.updateInsights());
        },

        get rooms() { return this.$store.rooms.list.filter(r => r.temperature !== null); },

        get sortedRooms() {
          return [...this.rooms].sort((a, b) => {
            let cmp = 0;
            if (this.sortBy === 'temperature') cmp = a.temperature - b.temperature;
            else if (this.sortBy === 'humidity') cmp = a.humidity - b.humidity;
            else if (this.sortBy === 'name') cmp = a.name.localeCompare(b.name);
            return this.sortDirection === 'desc' ? -cmp : cmp;
          });
        },

        updateInsights() {
          const rooms = this.rooms;
          if (rooms.length === 0) { this.insights = []; return; }

          const insights = [];
          const temps = rooms.map(r => r.temperature);
          const spread = Math.max(...temps) - Math.min(...temps);

          if (spread >= 2) {
            const hottest = rooms.find(r => r.temperature === Math.max(...temps));
            const coldest = rooms.find(r => r.temperature === Math.min(...temps));
            insights.push({ type: spread > 4 ? 'warning' : 'info', icon: 'üî∫', title: 'TEMPERATURE GAP',
              message: `${hottest.name} is ${spread.toFixed(1)}¬∞ warmer than ${coldest.name}` });
          }

          rooms.forEach(r => {
            if (r.humidity > 70) {
              insights.push({ type: 'alert', icon: 'üíß', title: 'HIGH HUMIDITY',
                message: `${r.name} at ${r.humidity}% ‚Äî risk of mold` });
            }
          });

          const comfortable = rooms.filter(r => r.temperature >= 22 && r.temperature <= 26 && r.humidity >= 40 && r.humidity <= 60);
          if (comfortable.length > 0) {
            insights.push({ type: 'success', icon: '‚úì', title: 'COMFORT ZONES',
              message: `${comfortable.map(r => r.name).join(', ')} ${comfortable.length === 1 ? 'is' : 'are'} comfortable` });
          }

          this.insights = insights.slice(0, 4);
        },

        setViewMode(mode) { this.viewMode = mode; localStorage.setItem('bar-view', mode); },

        getBarWidth(value, type) {
          const scale = type === 'temperature' ? this.tempScale : this.humidityScale;
          return Math.max(0, Math.min(100, ((value - scale.min) / (scale.max - scale.min)) * 100));
        },

        getBarColor(value, type) {
          const zone = type === 'temperature' ? this.comfortZone.temp : this.comfortZone.humidity;
          if (type === 'temperature') {
            if (value < zone.min) return 'var(--color-cold)';
            if (value > zone.max) return 'var(--color-hot)';
            return 'var(--color-comfortable)';
          } else {
            if (value < zone.min) return 'var(--color-warning)';
            if (value > zone.max) return 'var(--color-info)';
            return 'var(--color-comfortable)';
          }
        },

        getComfortZoneStyle(type) {
          const scale = type === 'temperature' ? this.tempScale : this.humidityScale;
          const zone = type === 'temperature' ? this.comfortZone.temp : this.comfortZone.humidity;
          const left = ((zone.min - scale.min) / (scale.max - scale.min)) * 100;
          const width = ((zone.max - zone.min) / (scale.max - scale.min)) * 100;
          return { left: left + '%', width: width + '%' };
        },

        getScaleLabels(type) {
          const scale = type === 'temperature' ? this.tempScale : this.humidityScale;
          const unit = type === 'temperature' ? '¬∞' : '%';
          return [scale.min + unit, ((scale.min + scale.max) / 2) + unit, scale.max + unit];
        },

        getInsightClass(type) {
          return { success: 'insight-success', warning: 'insight-warning', alert: 'insight-alert', info: 'insight-info' }[type] || 'insight-info';
        },

        openRoom(room) { this.$store.roomDetail.open(room); }
      };
    }

    // ========================================
    // FLOOR PLAN VIEW (Vision 3)
    // ========================================
    function floorPlanView() {
      return {
        viewType: 'temperature',
        // Layout based on actual floor plan measurements
        // Scale: ~55px per meter for good visualization
        layout: {
          width: 620, height: 470,
          rooms: [
            // Top row: Living Room (left with balcony) + Bedroom (right with main door)
            { id: 'living', x: 70, y: 20, width: 260, height: 200 },      // 4.75m √ó 3.968m
            { id: 'bedroom', x: 340, y: 20, width: 250, height: 200 },    // 4.489m √ó 3.378m
            // Bottom row: Study (left) + Kitchen/Bathroom (right), Hallway in center
            { id: 'study', x: 20, y: 235, width: 216, height: 220 },      // 3.908m √ó 3.697m (20% reduced)
            { id: 'kitchen', x: 430, y: 235, width: 175, height: 115 },   // 3.203m √ó 2.138m
            { id: 'bathroom', x: 430, y: 355, width: 175, height: 95 }    // 3.15m √ó 1.424m
          ]
        },
        tempColors: [
          { value: 18, color: '#90CAF9' }, { value: 22, color: '#A5D6A7' },
          { value: 24, color: '#81C784' }, { value: 26, color: '#FFE082' },
          { value: 28, color: '#FFAB91' }, { value: 32, color: '#EF5350' }
        ],
        humidityColors: [
          { value: 30, color: '#FFCC80' }, { value: 40, color: '#A5D6A7' },
          { value: 50, color: '#81C784' }, { value: 60, color: '#A5D6A7' },
          { value: 70, color: '#90CAF9' }, { value: 85, color: '#5C6BC0' }
        ],

        get rooms() {
          const roomsList = this.$store.rooms.list;
          return this.layout.rooms.map(lr => {
            const dr = roomsList.find(r => r.id === lr.id);
            return { ...lr, ...dr, color: this.getRoomColor(dr) };
          });
        },

        setViewType(type) { this.viewType = type; },

        getRoomColor(room) {
          if (!room || room.temperature === null) return '#E0E0E0';
          const value = this.viewType === 'temperature' ? room.temperature : room.humidity;
          const scale = this.viewType === 'temperature' ? this.tempColors : this.humidityColors;
          return this.interpolateColor(value, scale);
        },

        interpolateColor(value, scale) {
          if (value < scale[0].value) return scale[0].color;
          if (value > scale[scale.length - 1].value) return scale[scale.length - 1].color;

          let lower = scale[0], upper = scale[scale.length - 1];
          for (let i = 0; i < scale.length - 1; i++) {
            if (value >= scale[i].value && value <= scale[i + 1].value) {
              lower = scale[i]; upper = scale[i + 1]; break;
            }
          }

          const factor = (value - lower.value) / (upper.value - lower.value);
          const lRGB = this.hexToRgb(lower.color), uRGB = this.hexToRgb(upper.color);
          const r = Math.round(lRGB.r + factor * (uRGB.r - lRGB.r));
          const g = Math.round(lRGB.g + factor * (uRGB.g - lRGB.g));
          const b = Math.round(lRGB.b + factor * (uRGB.b - lRGB.b));
          return `rgb(${r},${g},${b})`;
        },

        hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 200, g: 200, b: 200 };
        },

        getLegendItems() {
          return this.viewType === 'temperature'
            ? [{ label: '< 20¬∞', color: '#90CAF9' }, { label: '20-24¬∞', color: '#81C784' }, { label: '24-28¬∞', color: '#FFE082' }, { label: '> 28¬∞', color: '#EF5350' }]
            : [{ label: '< 40%', color: '#FFCC80' }, { label: '40-60%', color: '#81C784' }, { label: '60-70%', color: '#90CAF9' }, { label: '> 70%', color: '#5C6BC0' }];
        },

        getValue(room) {
          if (!room) return '--';
          return this.viewType === 'temperature'
            ? (room.temperature !== null ? room.temperature.toFixed(1) + '¬∞' : '--')
            : (room.humidity !== null ? room.humidity.toFixed(0) + '%' : '--');
        },

        openRoom(room) { this.$store.roomDetail.open(room); }
      };
    }

    // ========================================
    // AMBIENT VIEW (Vision 4)
    // ========================================
    function ambientView() {
      return {
        currentRoomIndex: 0,
        isDarkMode: false,
        autoRotate: false,
        showDetails: false,
        detailsTimeout: null,
        touchStartX: 0,

        init() {
          const hour = new Date().getHours();
          this.isDarkMode = hour >= 22 || hour < 6;

          this.$el.addEventListener('touchstart', (e) => { this.touchStartX = e.touches[0].clientX; }, { passive: true });
          this.$el.addEventListener('touchend', (e) => {
            const deltaX = e.changedTouches[0].clientX - this.touchStartX;
            if (Math.abs(deltaX) > 50) deltaX > 0 ? this.previousRoom() : this.nextRoom();
          }, { passive: true });

          let lastTap = 0;
          this.$el.addEventListener('touchend', () => {
            const now = Date.now();
            if (now - lastTap < 300) this.isDarkMode = !this.isDarkMode;
            lastTap = now;
          }, { passive: true });
        },

        get rooms() { return this.$store.rooms.list.filter(r => r.temperature !== null); },

        get currentRoom() {
          return this.rooms.length > 0 ? this.rooms[this.currentRoomIndex % this.rooms.length]
            : { name: 'Loading...', temperature: 0, humidity: 0, icon: 'üè†' };
        },

        nextRoom() { this.currentRoomIndex = (this.currentRoomIndex + 1) % this.rooms.length; },
        previousRoom() { this.currentRoomIndex = (this.currentRoomIndex - 1 + this.rooms.length) % this.rooms.length; },
        selectRoom(index) { this.currentRoomIndex = index; },

        showDetailsOverlay() {
          this.showDetails = true;
          if (this.detailsTimeout) clearTimeout(this.detailsTimeout);
          this.detailsTimeout = setTimeout(() => { this.showDetails = false; }, 5000);
        },

        getBackgroundColor() {
          if (this.isDarkMode) return '#000000';
          const temp = this.currentRoom.temperature;
          if (temp < 20) return '#E3F2FD';
          if (temp < 23) return '#E8F5E9';
          if (temp < 26) return '#FFFFFF';
          if (temp < 28) return '#FFF8E1';
          return '#FFEBEE';
        },

        getMinMaxToday() {
          const room = this.currentRoom;
          if (!room.tempHistory || room.tempHistory.length === 0) return '--';
          const today = new Date(); today.setHours(0, 0, 0, 0);
          const todayHistory = room.tempHistory.filter(h => h.time >= today.getTime());
          if (todayHistory.length === 0) return '--';
          const temps = todayHistory.map(h => h.value);
          return `${Math.min(...temps).toFixed(1)}¬∞ / ${Math.max(...temps).toFixed(1)}¬∞`;
        },

        getTrend() {
          const room = this.currentRoom;
          if (!room.tempHistory || room.tempHistory.length < 2) return '‚Üí';
          const recent = room.tempHistory.slice(-10);
          const diff = recent[recent.length - 1].value - recent[0].value;
          if (diff > 0.5) return '‚Üë';
          if (diff < -0.5) return '‚Üì';
          return '‚Üí';
        },

        formatLastUpdate() {
          if (!this.currentRoom.lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - this.currentRoom.lastSeen) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      };
    }

    // ========================================
    // TIMELINE VIEW (Vision 5)
    // ========================================
    function timelineView() {
      return {
        events: [],
        selectedDate: 'today',
        loading: false,

        init() {
          this.loadEvents();
          this.$watch('$store.rooms.list', () => this.loadEvents());
        },

        loadEvents() {
          this.loading = true;
          const rooms = this.$store.rooms.list;
          const allEvents = [];

          const now = Date.now();
          let startTime;
          if (this.selectedDate === 'yesterday') {
            const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); yesterday.setHours(0, 0, 0, 0);
            startTime = yesterday.getTime();
          } else if (this.selectedDate === 'week') {
            startTime = now - 7 * 24 * 60 * 60 * 1000;
          } else {
            const today = new Date(); today.setHours(0, 0, 0, 0);
            startTime = today.getTime();
          }

          rooms.forEach(room => {
            if (room.tempHistory && room.tempHistory.length > 0) {
              const filtered = room.tempHistory.filter(h => h.time >= startTime);
              allEvents.push(...this.detectEvents(filtered, room.name, room.icon));
            }
          });

          this.events = allEvents.sort((a, b) => b.time - a.time).slice(0, 20);
          this.loading = false;
        },

        detectEvents(history, roomName, roomIcon) {
          if (history.length < 10) return [];
          const events = [];
          const sorted = [...history].sort((a, b) => a.time - b.time);

          // Detect rapid changes
          for (let i = 0; i < sorted.length - 1; i++) {
            const windowMs = 30 * 60 * 1000;
            const start = sorted[i];
            const endIdx = sorted.findIndex(p => p.time >= start.time + windowMs && p.time <= start.time + windowMs * 1.2);
            if (endIdx === -1) continue;

            const end = sorted[endIdx];
            const delta = end.value - start.value;

            if (Math.abs(delta) >= 3) {
              events.push({
                type: delta > 0 ? 'RAPID_RISE' : 'RAPID_DROP',
                time: start.time, room: roomName, icon: roomIcon,
                value: start.value, endValue: end.value, delta: Math.abs(delta),
                duration: Math.round((end.time - start.time) / 60000),
                eventIcon: delta > 0 ? 'üî•' : '‚ùÑÔ∏è',
                title: `${roomName} ${delta > 0 ? 'rose' : 'dropped'} ${Math.abs(delta).toFixed(1)}¬∞ in ${Math.round((end.time - start.time) / 60000)} mins`,
                cause: this.inferCause(delta > 0 ? 'RAPID_RISE' : 'RAPID_DROP', roomName, start.time)
              });
            }
          }

          // Detect peaks
          const windowSize = 6;
          for (let i = windowSize; i < sorted.length - windowSize; i++) {
            const point = sorted[i];
            const before = sorted.slice(i - windowSize, i);
            const after = sorted.slice(i + 1, i + windowSize + 1);
            const maxBefore = Math.max(...before.map(p => p.value));
            const maxAfter = Math.max(...after.map(p => p.value));

            if (point.value > maxBefore && point.value > maxAfter && point.value - Math.min(maxBefore, maxAfter) >= 2) {
              events.push({
                type: 'PEAK', time: point.time, room: roomName, icon: roomIcon,
                value: point.value, eventIcon: 'üìà',
                title: `${roomName} peaked at ${point.value.toFixed(1)}¬∞`,
                cause: this.inferCause('PEAK', roomName, point.time)
              });
            }
          }

          return events;
        },

        inferCause(type, roomName, time) {
          const hour = new Date(time).getHours();
          const room = roomName.toLowerCase();

          if (room.includes('bathroom') && type === 'PEAK' && hour >= 6 && hour <= 9)
            return { text: 'Morning shower' };
          if (room.includes('kitchen') && type === 'RAPID_RISE' && hour >= 18 && hour <= 21)
            return { text: 'Cooking dinner' };
          if (type === 'RAPID_RISE' && hour >= 10 && hour <= 15)
            return { text: 'Sun exposure' };
          return null;
        },

        setDate(date) { this.selectedDate = date; this.loadEvents(); },

        formatTime(timestamp) {
          return new Date(timestamp).toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
        },

        getEventClass(type) {
          return { 'PEAK': 'event-peak', 'VALLEY': 'event-valley', 'RAPID_RISE': 'event-rise', 'RAPID_DROP': 'event-drop' }[type] || '';
        },

        getTodaySummary() {
          const rooms = this.$store.rooms.list.filter(r => r.tempHistory && r.tempHistory.length > 0);
          if (rooms.length === 0) return null;

          const today = new Date(); today.setHours(0, 0, 0, 0);
          let allTemps = [], mostStable = null, minVar = Infinity, mostVolatile = null, maxVar = 0;

          rooms.forEach(room => {
            const todayHistory = room.tempHistory.filter(h => h.time >= today.getTime());
            if (todayHistory.length < 2) return;
            const temps = todayHistory.map(h => h.value);
            allTemps.push(...temps);
            const variation = Math.max(...temps) - Math.min(...temps);
            if (variation < minVar) { minVar = variation; mostStable = room.name; }
            if (variation > maxVar) { maxVar = variation; mostVolatile = room.name; }
          });

          if (allTemps.length === 0) return null;
          return {
            minTemp: Math.min(...allTemps).toFixed(1),
            maxTemp: Math.max(...allTemps).toFixed(1),
            mostStable, mostVolatile,
            eventCount: this.events.length
          };
        },

        openRoom(roomName) {
          const room = this.$store.rooms.list.find(r => r.name === roomName);
          if (room) this.$store.roomDetail.open(room);
        }
      };
    }

    // ========================================
    // VISION 6: CLASSIC CARDS VIEW
    // ========================================
    function classicView() {
      return {
        sparklineUpdateInterval: null,

        get rooms() {
          return this.$store.rooms.list;
        },

        get avgTemperature() {
          return this.$store.rooms.avgTemperature;
        },

        get avgHumidity() {
          return this.$store.rooms.avgHumidity;
        },

        init() {
          // Initial sparkline render
          this.$nextTick(() => this.updateSparklines());

          // Update sparklines every 5 seconds
          this.sparklineUpdateInterval = setInterval(() => this.updateSparklines(), 5000);

          // Watch for room changes
          this.$watch('$store.rooms.list', () => {
            this.$nextTick(() => this.updateSparklines());
          });
        },

        destroy() {
          if (this.sparklineUpdateInterval) {
            clearInterval(this.sparklineUpdateInterval);
          }
        },

        isStale(room) {
          if (!room.lastSeen) return true;
          return Date.now() - room.lastSeen > 5 * 60 * 1000;
        },

        getComfortClass(temp) {
          if (temp === null || temp === undefined) return '';
          if (temp < 20) return 'cold';
          if (temp < 23) return 'cool';
          if (temp <= 26) return 'good';
          if (temp <= 28) return 'warm';
          return 'hot';
        },

        formatUpdate(lastSeen) {
          if (!lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - lastSeen) / 1000);
          if (seconds < 5) return 'Just now';
          if (seconds < 60) return `${seconds}s ago`;
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return `${minutes}m ago`;
          const hours = Math.floor(minutes / 60);
          return `${hours}h ${minutes % 60}m ago`;
        },

        openRoom(room) {
          this.$store.roomDetail.open(room);
        },

        updateSparklines() {
          // Update room sparklines
          this.rooms.forEach(room => {
            const svg = document.getElementById(`classic-spark-${room.id}`);
            if (svg && room.tempHistory && room.tempHistory.length > 1) {
              this.drawSparkline(svg, room.tempHistory.slice(-50));
            }
          });

          // Update average sparkline
          const avgSvg = document.getElementById('classic-spark-avg');
          const avgHistory = this.$store.rooms.avgHistory;
          if (avgSvg && avgHistory && avgHistory.length > 1) {
            this.drawSparkline(avgSvg, avgHistory.slice(-50), true);
          }
        },

        drawSparkline(svg, data, isDark = false) {
          const width = svg.clientWidth || 200;
          const height = svg.clientHeight || 40;

          if (data.length < 2 || width === 0) return;

          const values = data.map(d => d.value);
          const min = Math.min(...values);
          const max = Math.max(...values);
          const range = max - min || 1;

          const points = data.map((d, i) => {
            const x = (i / (data.length - 1)) * width;
            const y = height - ((d.value - min) / range) * (height - 4) - 2;
            return `${x},${y}`;
          }).join(' ');

          const lineColor = isDark ? 'rgba(255,255,255,0.8)' : 'var(--color-primary)';
          const areaColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0, 122, 255, 0.1)';

          svg.innerHTML = `
            <polyline
              points="${points}"
              fill="none"
              stroke="${lineColor}"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <polygon
              points="0,${height} ${points} ${width},${height}"
              fill="${areaColor}"
            />
          `;
        }
      };
    }

    // ========================================
    // VISION 7: LIGHTS CONTROL VIEW
    // ========================================
    function lightsView() {
      return {
        // Helper function for color temperature label
        getColorTempLabel(colorTemp) {
          if (colorTemp <= 280) return 'Cool White';
          if (colorTemp <= 350) return 'Neutral';
          if (colorTemp <= 400) return 'Warm White';
          return 'Warm';
        },

        // Helper function for last update formatting
        formatLastUpdate(timestamp) {
          if (!timestamp) return 'No data';
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      };
    }

    // ========================================
    // VISION 8: 3D FLOOR PLAN VIEW
    // ========================================

    // Store Three.js objects OUTSIDE Alpine to avoid proxy conflicts
    const threeState = {
      scene: null,
      camera: null,
      renderer: null,
      controls: null,
      roomMeshes: {},
      wallMeshes: [],
      labelElements: {},
      animationId: null,
      isInitialized: false
    };

    // Isometric view state (separate from 3D view)
    const isoState = {
      scene: null,
      camera: null,
      renderer: null,
      roomMeshes: {},
      wallMeshes: [],
      labelElements: {},
      animationId: null,
      isInitialized: false,
      panOffset: { x: 0, z: 0 },
      isPanning: false,
      lastPanPos: { x: 0, y: 0 }
    };

    // Floor plan configuration - exact dimensions from floor map
    const FLOOR_PLAN_CONFIG = {
      apartmentWidth: 9.239,
      apartmentDepth: 6.665,  // Reduced from 7.665 (south wall moved 1.0m north)
      wallHeight: 2.0,
      wallThickness: 0.15,
      // Room positions are center coordinates (mirrored layout)
      rooms: [
        { id: 'study', name: 'Study', icon: 'üìö', x: 7.285, z: 1.8485, width: 3.908, depth: 3.697, color: 0x60a5fa, labelY: 3 },
        { id: 'living', name: 'Living Room', icon: 'üõãÔ∏è', x: 6.864, z: 5.181, width: 4.750, depth: 2.968, color: 0x34d399, labelY: 3 },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', x: 2.2445, z: 5.476, width: 4.489, depth: 2.378, color: 0xfbbf24, labelY: 4 },
        { id: 'kitchen', name: 'Kitchen', icon: 'üç≥', x: 1.6655, z: 2.8957, width: 3.331, depth: 2.7827, color: 0xf87171, labelY: 3 },
        { id: 'bathroom', name: 'Bathroom', icon: 'üöø', x: 1.6985, z: 0.7522, width: 3.397, depth: 1.5043, color: 0xa78bfa, labelY: 2 },
        { id: 'hallway', name: 'Hallway', icon: 'üö∂', x: 3.839, z: 2.0, width: 1.5, depth: 2.5, color: 0x94a3b8, labelY: 2 }
      ],
      balcony: { x: 9.764, z: 7.065, width: 1.050, depth: 1.200, color: 0x93c5fd },
      hallway: { x: 3.839, z: 2.0, width: 1.5, depth: 2.5, color: 0x94a3b8 },
      balconyNotch: {
        width: 1.0,    // Cut-out width
        depth: 1.5,    // Cut-out depth (increased to make balcony bigger)
        hasRailing: true,
        floorColor: 0xC0C0C2  // Match base floor
      },
      doors: [
        { x: 9.239, z: 6.465, rotation: Math.PI/2, type: 'french', swingDirection: 'inward' },  // Balcony ‚Üî Living (double glass French doors at east wall)
        { x: 3.706, z: 3.697, rotation: 0, swingDirection: 'south' },           // Living ‚Üî Hallway
        { x: 4.354, z: 1.848, rotation: Math.PI/2, swingDirection: 'east' },    // Study ‚Üî Hallway
        { x: 3.134, z: 3.697, rotation: 0, swingDirection: 'south' },           // Bedroom ‚Üî Hallway
        { x: 3.331, z: 2.818, rotation: Math.PI/2, swingDirection: 'east' },    // Hallway ‚Üî Kitchen
        { x: 3.331, z: 1.338, rotation: Math.PI/2, swingDirection: 'east' },    // Hallway ‚Üî Bathroom
        { x: 0, z: 4.8, rotation: Math.PI/2, type: 'entry', swingDirection: 'east' }  // Main entry door (west wall in mirrored layout)
      ],
      windows: [
        { x: 9.239, z: 1.848, rotation: Math.PI/2, size: 2.5 },   // Study right (mirrored)
        { x: 9.239, z: 4.2, rotation: Math.PI/2, size: 2.5 },     // Living right (east wall)
        { x: 0, z: 5.976, rotation: Math.PI/2, size: 2.5 },       // Bedroom left (mirrored)
        { x: 0, z: 3.218, rotation: Math.PI/2, size: 1.8 },       // Kitchen left (mirrored)
        { x: 0, z: 1.487, rotation: Math.PI/2, size: 1.2 }        // Bathroom left (mirrored)
      ],
      furniture: [
        { type: 'bed', room: 'bedroom', width: 1.8, depth: 2.0, height: 0.6 }
      ]
    };

    // Calculate center for positioning
    const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
    const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

    // Color scales
    const TEMP_COLORS = [
      { value: 18, color: 0x90CAF9 },
      { value: 22, color: 0xA5D6A7 },
      { value: 24, color: 0x81C784 },
      { value: 26, color: 0xFFE082 },
      { value: 28, color: 0xFFAB91 },
      { value: 32, color: 0xEF5350 }
    ];

    const HUMIDITY_COLORS = [
      { value: 30, color: 0xFFCC80 },
      { value: 40, color: 0xA5D6A7 },
      { value: 50, color: 0x81C784 },
      { value: 60, color: 0xA5D6A7 },
      { value: 70, color: 0x90CAF9 },
      { value: 85, color: 0x5C6BC0 }
    ];

    function threeDView() {
      return {
        // Reactive state for UI
        viewMode: 'temperature',
        viewMode3D: 'top',
        wallsVisible: true,
        autoRotate: false,
        darkTheme: false,

        init() {
          // Wait for container to become visible and have dimensions
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.threeContainer;

          // If container doesn't exist or has no dimensions, retry
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          // If already initialized, ensure canvas is in container and resize
          if (threeState.isInitialized && threeState.renderer) {
            // Re-attach canvas if it's not in the container
            if (!container.contains(threeState.renderer.domElement)) {
              container.appendChild(threeState.renderer.domElement);
            }
            this.createLabels(container);  // Recreate labels
            this.onResize();
            return;
          }

          // Clean up any existing Three.js objects
          if (threeState.renderer) {
            threeState.renderer.dispose();
          }
          if (threeState.scene) {
            threeState.scene.clear();
          }
          if (threeState.animationId) {
            cancelAnimationFrame(threeState.animationId);
          }

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.createLabels(container);
          this.animate();
          threeState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          threeState.scene = new THREE.Scene();
          threeState.scene.background = new THREE.Color(0xE8E8EA);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;

          // Use PerspectiveCamera for 3D viewing
          threeState.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
          // Default to top view - zoomed to fill screen, rotated 180¬∞ (scene is centered at 0,0,0)
          threeState.camera.position.set(0, 14, -0.1);
          threeState.camera.lookAt(0, 0, 0);

          // Add OrbitControls for interactive camera
          threeState.controls = new THREE.OrbitControls(threeState.camera, container);
          threeState.controls.enableDamping = true;
          threeState.controls.dampingFactor = 0.05;
          threeState.controls.maxPolarAngle = Math.PI / 2.1;  // Prevent camera below floor
          threeState.controls.minDistance = 5;
          threeState.controls.maxDistance = 40;
          threeState.controls.target.set(0, 0, 0);
          threeState.controls.update();
        },

        initRenderer(container) {
          threeState.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
          });
          threeState.renderer.setSize(container.clientWidth, container.clientHeight);
          threeState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          threeState.renderer.shadowMap.enabled = true;
          threeState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(threeState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.6);
          threeState.scene.add(ambient);

          const directional = new THREE.DirectionalLight(0xffffff, 0.8);
          directional.position.set(15, 20, 15);
          directional.castShadow = true;
          directional.shadow.mapSize.width = 1024;
          directional.shadow.mapSize.height = 1024;
          directional.shadow.camera.near = 0.5;
          directional.shadow.camera.far = 50;
          directional.shadow.camera.left = -15;
          directional.shadow.camera.right = 15;
          directional.shadow.camera.top = 15;
          directional.shadow.camera.bottom = -15;
          threeState.scene.add(directional);

          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          threeState.scene.add(fill);
        },

        buildFloorPlan() {
          // Clear wall meshes array for fresh build
          threeState.wallMeshes = [];

          // Base floor - uses apartment dimensions, centered at origin
          const apW = FLOOR_PLAN_CONFIG.apartmentWidth;
          const apD = FLOOR_PLAN_CONFIG.apartmentDepth;
          const floorGeometry = new THREE.PlaneGeometry(apW + 2, apD + 2);
          const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xC0C0C2,
            roughness: 0.8
          });
          const floor = new THREE.Mesh(floorGeometry, floorMaterial);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(0, -0.01, 0);
          floor.receiveShadow = true;
          threeState.scene.add(floor);

          // Build each room
          FLOOR_PLAN_CONFIG.rooms.forEach(roomConfig => {
            const roomGroup = this.createRoom(roomConfig);
            threeState.roomMeshes[roomConfig.id] = roomGroup;
            threeState.scene.add(roomGroup);
          });

          // Hallway floor (centered coordinates)
          const hw = FLOOR_PLAN_CONFIG.hallway;
          const hallwayGeometry = new THREE.PlaneGeometry(hw.width, hw.depth);
          const hallwayMaterial = new THREE.MeshStandardMaterial({
            color: 0xD0D0D0,
            roughness: 0.7
          });
          const hallway = new THREE.Mesh(hallwayGeometry, hallwayMaterial);
          hallway.rotation.x = -Math.PI / 2;
          hallway.position.set(hw.x - centerX, 0.005, hw.z - centerZ);
          hallway.receiveShadow = true;
          threeState.scene.add(hallway);

          // Balcony floor
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const balconyGeometry = new THREE.PlaneGeometry(bal.width, bal.depth);
          const balconyMaterial = new THREE.MeshStandardMaterial({
            color: 0x93c5fd,
            roughness: 0.5
          });
          const balcony = new THREE.Mesh(balconyGeometry, balconyMaterial);
          balcony.rotation.x = -Math.PI / 2;
          balcony.position.set(bal.x - centerX, 0.003, bal.z - centerZ);
          balcony.receiveShadow = true;
          threeState.scene.add(balcony);

          // Add doors
          FLOOR_PLAN_CONFIG.doors.forEach(door => this.createDoor(door));

          // Add windows
          FLOOR_PLAN_CONFIG.windows.forEach(win => this.createWindow(win));

          // Add balcony railing
          this.createBalconyRailing();

          // Add furniture
          this.createFurniture();
        },

        createRoom(config) {
          const group = new THREE.Group();
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;

          // Room floor - colored transparent box matching room color
          const floorGeometry = new THREE.BoxGeometry(config.width, 0.05, config.depth);
          const floorMaterial = new THREE.MeshStandardMaterial({
            color: config.color,
            transparent: true,
            opacity: 0.3,
            roughness: 0.6,
            metalness: 0.1
          });
          const roomFloor = new THREE.Mesh(floorGeometry, floorMaterial);
          roomFloor.position.set(config.x - centerX, 0.025, config.z - centerZ);
          roomFloor.receiveShadow = true;
          roomFloor.name = 'floor_' + config.id;
          group.add(roomFloor);

          // Glassy wall material - semi-transparent for elegant look
          const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.25,
            metalness: 0.4,
            roughness: 0.08,
            side: THREE.DoubleSide
          });

          // Calculate room boundaries
          const halfW = config.width / 2;
          const halfD = config.depth / 2;
          const rx = config.x - centerX;  // room center X (relative)
          const rz = config.z - centerZ;  // room center Z (relative)

          // Back wall (north)
          const backWall = new THREE.Mesh(
            new THREE.BoxGeometry(config.width, wallHeight, 0.15),
            wallMaterial
          );
          backWall.position.set(rx, wallHeight/2, rz - halfD);
          backWall.castShadow = true;
          group.add(backWall);
          threeState.wallMeshes.push(backWall);

          // Front wall (south) - full height for immersive 3D
          const frontWall = new THREE.Mesh(
            new THREE.BoxGeometry(config.width, wallHeight, 0.15),
            wallMaterial
          );
          frontWall.position.set(rx, wallHeight/2, rz + halfD);
          frontWall.castShadow = true;
          group.add(frontWall);
          threeState.wallMeshes.push(frontWall);

          // Left wall (west)
          const leftWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, wallHeight, config.depth),
            wallMaterial
          );
          leftWall.position.set(rx - halfW, wallHeight/2, rz);
          leftWall.castShadow = true;
          group.add(leftWall);
          threeState.wallMeshes.push(leftWall);

          // Right wall (east)
          const rightWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, wallHeight, config.depth),
            wallMaterial
          );
          rightWall.position.set(rx + halfW, wallHeight/2, rz);
          rightWall.castShadow = true;
          group.add(rightWall);
          threeState.wallMeshes.push(rightWall);

          return group;
        },

        // Create door with handle and swing arc
        createDoor(doorConfig) {
          const doorWidth = 0.9;
          const doorHeight = FLOOR_PLAN_CONFIG.wallHeight * 0.85;
          const posX = doorConfig.x - centerX;
          const posZ = doorConfig.z - centerZ;

          // Check door type
          if (doorConfig.type === 'french') {
            // French doors - double glass doors opening inward
            this.createFrenchDoor(doorConfig, posX, posZ, doorWidth, doorHeight);
            return;
          }

          // Standard door material (brown wood)
          const doorMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            roughness: 0.7,
            metalness: 0.1
          });

          const door = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth, doorHeight, 0.08),
            doorMaterial
          );
          door.position.set(posX, doorHeight / 2, posZ);
          door.rotation.y = doorConfig.rotation || 0;
          door.castShadow = true;
          threeState.scene.add(door);

          // Door handle
          const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.9,
            roughness: 0.2
          });
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.15, 16),
            handleMaterial
          );

          // Position handle based on door rotation
          const handleOffsetX = 0.3 * Math.cos(doorConfig.rotation || 0);
          const handleOffsetZ = 0.3 * Math.sin(doorConfig.rotation || 0);
          handle.position.set(
            posX + handleOffsetX,
            doorHeight * 0.45,
            posZ + handleOffsetZ
          );
          handle.rotation.z = Math.PI / 2;
          threeState.scene.add(handle);

          // Add swing arc on floor
          this.createSwingArc(doorConfig, posX, posZ, doorWidth);
        },

        // Create French doors (double glass doors)
        createFrenchDoor(doorConfig, posX, posZ, doorWidth, doorHeight) {
          const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB,
            transparent: true,
            opacity: 0.4,
            roughness: 0.1,
            metalness: 0.3
          });

          const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x2c3e50,
            roughness: 0.5,
            metalness: 0.2
          });

          // Total width for double doors
          const totalWidth = doorWidth * 2;
          const gap = 0.05;  // Small gap between doors

          // Left door panel
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth - gap/2, doorHeight, 0.06),
            glassMaterial
          );

          // Right door panel
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth - gap/2, doorHeight, 0.06),
            glassMaterial
          );

          // Position based on rotation
          const rot = doorConfig.rotation || 0;
          const offsetLeft = (doorWidth/2 + gap/4) * Math.cos(rot + Math.PI/2);
          const offsetLeftZ = (doorWidth/2 + gap/4) * Math.sin(rot + Math.PI/2);
          const offsetRight = (doorWidth/2 + gap/4) * Math.cos(rot - Math.PI/2);
          const offsetRightZ = (doorWidth/2 + gap/4) * Math.sin(rot - Math.PI/2);

          leftDoor.position.set(posX + offsetLeft, doorHeight/2, posZ + offsetLeftZ);
          leftDoor.rotation.y = rot;
          rightDoor.position.set(posX + offsetRight, doorHeight/2, posZ + offsetRightZ);
          rightDoor.rotation.y = rot;

          threeState.scene.add(leftDoor);
          threeState.scene.add(rightDoor);

          // Add door frames
          const frameThickness = 0.05;

          // Vertical frame divider in center
          const centerFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, doorHeight, 0.08),
            frameMaterial
          );
          centerFrame.position.set(posX, doorHeight/2, posZ);
          centerFrame.rotation.y = rot;
          threeState.scene.add(centerFrame);

          // Add TWO swing arcs (one for each door, opening inward)
          this.createSwingArc({ ...doorConfig, swingDirection: 'inward-left' }, posX + offsetLeft, posZ + offsetLeftZ, doorWidth);
          this.createSwingArc({ ...doorConfig, swingDirection: 'inward-right' }, posX + offsetRight, posZ + offsetRightZ, doorWidth);
        },

        // Create swing arc on floor showing door opening direction
        createSwingArc(doorConfig, posX, posZ, doorWidth) {
          const arcRadius = doorWidth;
          const arcSegments = 32;

          // Determine arc angles based on swing direction
          let startAngle, endAngle;
          const rot = doorConfig.rotation || 0;
          const swing = doorConfig.swingDirection || 'south';

          if (swing === 'inward-left') {
            startAngle = rot;
            endAngle = rot + Math.PI/2;
          } else if (swing === 'inward-right') {
            startAngle = rot - Math.PI/2;
            endAngle = rot;
          } else if (swing === 'south') {
            startAngle = rot;
            endAngle = rot + Math.PI/2;
          } else if (swing === 'north') {
            startAngle = rot + Math.PI/2;
            endAngle = rot + Math.PI;
          } else if (swing === 'east') {
            startAngle = rot - Math.PI/2;
            endAngle = rot;
          } else if (swing === 'west') {
            startAngle = rot + Math.PI;
            endAngle = rot + Math.PI * 1.5;
          } else {
            startAngle = rot;
            endAngle = rot + Math.PI/2;
          }

          // Create arc curve
          const curve = new THREE.EllipseCurve(
            0, 0,           // center
            arcRadius, arcRadius,  // xRadius, yRadius
            startAngle, endAngle,  // start and end angles
            false,          // clockwise
            0               // rotation
          );

          const points = curve.getPoints(arcSegments);
          const geometry = new THREE.BufferGeometry().setFromPoints(points);

          // Arc line material
          const arcMaterial = new THREE.LineBasicMaterial({
            color: 0x333333,
            transparent: true,
            opacity: 0.6
          });

          const arc = new THREE.Line(geometry, arcMaterial);
          arc.rotation.x = -Math.PI / 2;  // Lay flat on floor
          arc.position.set(posX, 0.02, posZ);  // Slightly above floor

          threeState.scene.add(arc);
        },

        // Create window with glass pane
        createWindow(winConfig) {
          const winWidth = winConfig.size || 2.0;
          const winHeight = 1.3;
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;

          // Window frame
          const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x2c3e50,
            roughness: 0.5,
            metalness: 0.2
          });
          const frame = new THREE.Mesh(
            new THREE.BoxGeometry(winWidth, winHeight, 0.15),
            frameMaterial
          );
          frame.position.set(
            winConfig.x - centerX,
            wallHeight * 0.55,
            winConfig.z - centerZ
          );
          frame.rotation.y = winConfig.rotation || 0;
          threeState.scene.add(frame);

          // Window glass
          const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x87CEEB,
            metalness: 0.3,
            roughness: 0.1,
            transparent: true,
            opacity: 0.4
          });
          const glass = new THREE.Mesh(
            new THREE.BoxGeometry(winWidth * 0.9, winHeight * 0.85, 0.06),
            glassMaterial
          );
          glass.position.set(
            winConfig.x - centerX,
            wallHeight * 0.55,
            winConfig.z - centerZ
          );
          glass.rotation.y = winConfig.rotation || 0;
          threeState.scene.add(glass);
        },

        // Create balcony railing
        createBalconyRailing() {
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const railingHeight = 1.0;
          const railingMaterial = new THREE.MeshStandardMaterial({
            color: 0x374151,
            metalness: 0.7,
            roughness: 0.3
          });

          // Front railing (facing outward)
          const frontRailing = new THREE.Mesh(
            new THREE.BoxGeometry(bal.width, railingHeight, 0.05),
            railingMaterial
          );
          frontRailing.position.set(
            bal.x - centerX,
            railingHeight / 2,
            bal.z - centerZ + bal.depth / 2
          );
          threeState.scene.add(frontRailing);

          // Left railing
          const leftRailing = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, railingHeight, bal.depth),
            railingMaterial
          );
          leftRailing.position.set(
            bal.x - centerX - bal.width / 2,
            railingHeight / 2,
            bal.z - centerZ
          );
          threeState.scene.add(leftRailing);

          // Vertical posts (glass panel supports)
          const postMaterial = new THREE.MeshStandardMaterial({
            color: 0x374151,
            metalness: 0.8,
            roughness: 0.2
          });

          const postPositions = [
            { x: bal.x - bal.width / 2, z: bal.z + bal.depth / 2 },
            { x: bal.x + bal.width / 2, z: bal.z + bal.depth / 2 },
            { x: bal.x, z: bal.z + bal.depth / 2 }
          ];

          postPositions.forEach(pos => {
            const post = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, railingHeight, 8),
              postMaterial
            );
            post.position.set(
              pos.x - centerX,
              railingHeight / 2,
              pos.z - centerZ
            );
            threeState.scene.add(post);
          });

          // Glass panel for railing
          const glassRailing = new THREE.MeshStandardMaterial({
            color: 0xccf0ff,
            transparent: true,
            opacity: 0.3,
            metalness: 0.2,
            roughness: 0.1
          });
          const glassPanel = new THREE.Mesh(
            new THREE.BoxGeometry(bal.width, railingHeight * 0.7, 0.02),
            glassRailing
          );
          glassPanel.position.set(
            bal.x - centerX,
            railingHeight * 0.4,
            bal.z - centerZ + bal.depth / 2
          );
          threeState.scene.add(glassPanel);
        },

        // Create furniture
        createFurniture() {
          const furnitureMaterial = new THREE.MeshStandardMaterial({
            color: 0x64748b,
            roughness: 0.6,
            metalness: 0.1
          });

          FLOOR_PLAN_CONFIG.furniture.forEach(item => {
            const roomConfig = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === item.room);
            if (!roomConfig) return;

            const mesh = new THREE.Mesh(
              new THREE.BoxGeometry(item.width, item.height, item.depth),
              furnitureMaterial
            );
            mesh.position.set(
              roomConfig.x - centerX,
              item.height / 2,
              roomConfig.z - centerZ
            );
            mesh.castShadow = true;
            threeState.scene.add(mesh);

            // Add bedding for bed
            if (item.type === 'bed') {
              const beddingMaterial = new THREE.MeshStandardMaterial({
                color: 0x94a3b8,
                roughness: 0.8
              });
              const bedding = new THREE.Mesh(
                new THREE.BoxGeometry(item.width * 0.95, 0.1, item.depth * 0.8),
                beddingMaterial
              );
              bedding.position.set(
                roomConfig.x - centerX,
                item.height + 0.05,
                roomConfig.z - centerZ
              );
              threeState.scene.add(bedding);
            }
          });
        },

        createLabels(container) {
          // Clear any existing labels first
          Object.values(threeState.labelElements).forEach(label => {
            if (label && label.parentNode) {
              label.parentNode.removeChild(label);
            }
          });
          threeState.labelElements = {};

          // Also remove any orphaned labels
          container.querySelectorAll('.room-3d-label').forEach(el => el.remove());

          FLOOR_PLAN_CONFIG.rooms.forEach(roomConfig => {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'room-3d-label';
            labelDiv.innerHTML = `
              <div class="label-icon">${roomConfig.icon}</div>
              <div class="label-name">${roomConfig.name}</div>
              <div class="label-value" data-room="${roomConfig.id}">--</div>
              <div class="label-secondary" data-room-secondary="${roomConfig.id}">--</div>
            `;
            container.appendChild(labelDiv);
            threeState.labelElements[roomConfig.id] = labelDiv;
          });
        },

        updateLabels() {
          const container = this.$refs.threeContainer;
          if (!container || !threeState.camera) return;

          const rooms = Alpine.store('rooms')?.list || [];
          const viewMode = this.viewMode;
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;

          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const label = threeState.labelElements[config.id];
            if (!label) return;

            const roomData = rooms.find(r => r.id === config.id);
            const valueEl = label.querySelector(`[data-room="${config.id}"]`);
            const secondaryEl = label.querySelector(`[data-room-secondary="${config.id}"]`);

            if (valueEl && roomData) {
              if (viewMode === 'temperature') {
                valueEl.textContent = roomData.temperature !== null
                  ? `${roomData.temperature.toFixed(1)}¬∞` : '--';
                if (secondaryEl) {
                  secondaryEl.textContent = roomData.humidity !== null
                    ? `${roomData.humidity.toFixed(0)}%` : '';
                }
              } else {
                valueEl.textContent = roomData.humidity !== null
                  ? `${roomData.humidity.toFixed(0)}%` : '--';
                if (secondaryEl) {
                  secondaryEl.textContent = roomData.temperature !== null
                    ? `${roomData.temperature.toFixed(1)}¬∞` : '';
                }
              }
            }

            // Project 3D to 2D - use labelY offset to prevent overlap
            // config.x, config.z are center coordinates; convert to world space
            const position = new THREE.Vector3(
              config.x - centerX,
              config.labelY || 3,
              config.z - centerZ
            );
            position.project(threeState.camera);

            const x = (position.x * 0.5 + 0.5) * containerWidth;
            const y = (-position.y * 0.5 + 0.5) * containerHeight;

            label.style.left = `${x}px`;
            label.style.top = `${y}px`;

            // Only show label if within container bounds and container is visible
            const margin = 20;
            const isVisible = containerWidth > 0 && containerHeight > 0 &&
                              x > margin && x < containerWidth - margin &&
                              y > margin && y < containerHeight - margin;

            if (isVisible) {
              label.classList.add('visible');
            } else {
              label.classList.remove('visible');
            }
          });
        },

        updateRoomColors() {
          const rooms = Alpine.store('rooms')?.list || [];
          const viewMode = this.viewMode;

          rooms.forEach(roomData => {
            const meshGroup = threeState.roomMeshes[roomData.id];
            if (!meshGroup) return;

            // Find floor mesh directly in children
            const floorMesh = meshGroup.children.find(child =>
              child.name === 'floor_' + roomData.id
            );

            if (floorMesh && floorMesh.material) {
              const color = this.getRoomColor(roomData, viewMode);
              floorMesh.material.color.setHex(color);
            }
          });
        },

        getRoomColor(room, viewMode) {
          if (!room) return 0xE0E0E0;

          const value = viewMode === 'temperature' ? room.temperature : room.humidity;
          if (value === null || value === undefined) return 0xE0E0E0;

          const scale = viewMode === 'temperature' ? TEMP_COLORS : HUMIDITY_COLORS;
          return this.interpolateColor(value, scale);
        },

        interpolateColor(value, scale) {
          if (value <= scale[0].value) return scale[0].color;
          if (value >= scale[scale.length - 1].value) return scale[scale.length - 1].color;

          let lower = scale[0], upper = scale[scale.length - 1];
          for (let i = 0; i < scale.length - 1; i++) {
            if (value >= scale[i].value && value <= scale[i + 1].value) {
              lower = scale[i];
              upper = scale[i + 1];
              break;
            }
          }

          const factor = (value - lower.value) / (upper.value - lower.value);

          const lowerColor = new THREE.Color(lower.color);
          const upperColor = new THREE.Color(upper.color);
          const result = new THREE.Color();
          result.lerpColors(lowerColor, upperColor, factor);

          return result.getHex();
        },

        animate() {
          const self = this;
          function loop() {
            threeState.animationId = requestAnimationFrame(loop);

            // Update OrbitControls (required for damping)
            if (threeState.controls) {
              threeState.controls.update();
            }

            self.updateRoomColors();
            self.updateLabels();

            if (threeState.renderer && threeState.scene && threeState.camera) {
              threeState.renderer.render(threeState.scene, threeState.camera);
            }
          }
          loop();
        },

        onResize() {
          const container = this.$refs.threeContainer;
          if (!container || !threeState.camera || !threeState.renderer) return;

          const aspect = container.clientWidth / container.clientHeight;

          // Update PerspectiveCamera aspect ratio
          threeState.camera.aspect = aspect;
          threeState.camera.updateProjectionMatrix();

          threeState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        setViewMode(mode) {
          this.viewMode = mode;
        },

        // View control functions
        set3DView() {
          this.viewMode3D = '3d';
          if (threeState.camera && threeState.controls) {
            threeState.camera.position.set(12, 12, 12);
            threeState.controls.target.set(0, 0, 0);
            threeState.controls.update();
          }
        },

        setTopView() {
          this.viewMode3D = 'top';
          if (threeState.camera && threeState.controls) {
            threeState.camera.position.set(0, 14, -0.1);
            threeState.controls.target.set(0, 0, 0);
            threeState.controls.update();
          }
        },

        toggleWalls() {
          this.wallsVisible = !this.wallsVisible;
          threeState.wallMeshes.forEach(wall => {
            wall.visible = this.wallsVisible;
          });
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (threeState.controls) {
            threeState.controls.autoRotate = this.autoRotate;
            threeState.controls.autoRotateSpeed = 2.0;
          }
        },

        toggleDarkTheme() {
          this.darkTheme = !this.darkTheme;
          if (this.darkTheme) {
            threeState.scene.background = new THREE.Color(0x0f172a);
            threeState.scene.fog = new THREE.Fog(0x0f172a, 10, 50);
          } else {
            threeState.scene.background = new THREE.Color(0xE8E8EA);
            threeState.scene.fog = null;
          }
        },

        zoomIn() {
          if (threeState.camera && threeState.controls) {
            const direction = new THREE.Vector3();
            direction.subVectors(threeState.controls.target, threeState.camera.position).normalize();
            threeState.camera.position.addScaledVector(direction, 2);
            threeState.controls.update();
          }
        },

        zoomOut() {
          if (threeState.camera && threeState.controls) {
            const direction = new THREE.Vector3();
            direction.subVectors(threeState.controls.target, threeState.camera.position).normalize();
            threeState.camera.position.addScaledVector(direction, -2);
            threeState.controls.update();
          }
        },

        getLegendItems() {
          if (this.viewMode === 'temperature') {
            return [
              { label: '< 20¬∞', color: '#90CAF9' },
              { label: '20-24¬∞', color: '#81C784' },
              { label: '24-28¬∞', color: '#FFE082' },
              { label: '> 28¬∞', color: '#EF5350' }
            ];
          } else {
            return [
              { label: '< 40%', color: '#FFCC80' },
              { label: '40-60%', color: '#81C784' },
              { label: '60-70%', color: '#90CAF9' },
              { label: '> 70%', color: '#5C6BC0' }
            ];
          }
        }
      };
    }

    // ========================================
    // ISOMETRIC FLOOR PLAN VIEW
    // ========================================
    function isometricView() {
      const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
      const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

      return {
        viewMode: 'temperature',
        zoomLevel: 1.0,
        wallsVisible: true,
        darkTheme: false,
        autoRotate: false,
        rotationAngle: 0,

        init() {
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.isoContainer;
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          if (isoState.isInitialized && isoState.renderer) {
            if (!container.contains(isoState.renderer.domElement)) {
              container.appendChild(isoState.renderer.domElement);
            }
            this.createLabels(container);
            this.onResize();
            return;
          }

          if (isoState.renderer) isoState.renderer.dispose();
          if (isoState.scene) isoState.scene.clear();
          if (isoState.animationId) cancelAnimationFrame(isoState.animationId);

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.createLabels(container);
          this.setupPanControls(container);
          this.animate();
          isoState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          isoState.scene = new THREE.Scene();
          isoState.scene.background = new THREE.Color(0xE8E8EA);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15;
          isoState.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2, 0.1, 1000
          );
          isoState.camera.position.set(10, 10, 10);
          isoState.camera.lookAt(0, 0, 0);
        },

        initRenderer(container) {
          isoState.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          isoState.renderer.setSize(container.clientWidth, container.clientHeight);
          isoState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          isoState.renderer.shadowMap.enabled = true;
          isoState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(isoState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.6);
          isoState.scene.add(ambient);
          const directional = new THREE.DirectionalLight(0xffffff, 0.8);
          directional.position.set(15, 20, 15);
          directional.castShadow = true;
          isoState.scene.add(directional);
          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          isoState.scene.add(fill);
        },

        buildFloorPlan() {
          isoState.wallMeshes = [];
          const apW = FLOOR_PLAN_CONFIG.apartmentWidth;
          const apD = FLOOR_PLAN_CONFIG.apartmentDepth;

          // Base floor
          const floorGeometry = new THREE.PlaneGeometry(apW + 2, apD + 2);
          const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xC0C0C2, roughness: 0.8 });
          const floor = new THREE.Mesh(floorGeometry, floorMaterial);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(0, -0.01, 0);
          floor.receiveShadow = true;
          isoState.scene.add(floor);

          // Rooms
          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const roomGroup = this.createRoom(config);
            isoState.roomMeshes[config.id] = roomGroup;
            isoState.scene.add(roomGroup);
          });

          // Hallway
          const hw = FLOOR_PLAN_CONFIG.hallway;
          const hallway = new THREE.Mesh(
            new THREE.PlaneGeometry(hw.width, hw.depth),
            new THREE.MeshStandardMaterial({ color: 0xD0D0D0, roughness: 0.7 })
          );
          hallway.rotation.x = -Math.PI / 2;
          hallway.position.set(hw.x - centerX, 0.005, hw.z - centerZ);
          isoState.scene.add(hallway);

          // Balcony
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const balcony = new THREE.Mesh(
            new THREE.PlaneGeometry(bal.width, bal.depth),
            new THREE.MeshStandardMaterial({ color: 0x93c5fd, roughness: 0.5 })
          );
          balcony.rotation.x = -Math.PI / 2;
          balcony.position.set(bal.x - centerX, 0.003, bal.z - centerZ);
          isoState.scene.add(balcony);

          // Doors, windows, railing, furniture
          FLOOR_PLAN_CONFIG.doors.forEach(door => this.createDoor(door));
          FLOOR_PLAN_CONFIG.windows.forEach(win => this.createWindow(win));
          this.createBalconyRailing();
          this.createFurniture();
        },

        createRoom(config) {
          const group = new THREE.Group();
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;
          const halfW = config.width / 2, halfD = config.depth / 2;
          const rx = config.x - centerX, rz = config.z - centerZ;

          // Floor
          const floorMaterial = new THREE.MeshStandardMaterial({
            color: config.color, transparent: true, opacity: 0.3, roughness: 0.6, metalness: 0.1
          });
          const roomFloor = new THREE.Mesh(new THREE.BoxGeometry(config.width, 0.05, config.depth), floorMaterial);
          roomFloor.position.set(rx, 0.025, rz);
          roomFloor.receiveShadow = true;
          roomFloor.name = 'floor_' + config.id;
          group.add(roomFloor);

          // Walls
          const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff, transparent: true, opacity: 0.25, metalness: 0.4, roughness: 0.08, side: THREE.DoubleSide
          });
          const walls = [
            { geo: [config.width, wallHeight, 0.15], pos: [rx, wallHeight/2, rz - halfD] },
            { geo: [config.width, wallHeight, 0.15], pos: [rx, wallHeight/2, rz + halfD] },
            { geo: [0.15, wallHeight, config.depth], pos: [rx - halfW, wallHeight/2, rz] },
            { geo: [0.15, wallHeight, config.depth], pos: [rx + halfW, wallHeight/2, rz] }
          ];
          walls.forEach(w => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(...w.geo), wallMaterial);
            wall.position.set(...w.pos);
            wall.castShadow = true;
            group.add(wall);
            isoState.wallMeshes.push(wall);
          });
          return group;
        },

        createDoor(doorConfig) {
          const doorWidth = 0.9, doorHeight = FLOOR_PLAN_CONFIG.wallHeight * 0.85;
          const posX = doorConfig.x - centerX, posZ = doorConfig.z - centerZ;

          if (doorConfig.type === 'french') {
            const glassMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4 });
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const rot = doorConfig.rotation || 0;
            const offset = doorWidth/2 + 0.01;

            [-1, 1].forEach(side => {
              const door = new THREE.Mesh(new THREE.BoxGeometry(doorWidth - 0.02, doorHeight, 0.06), glassMaterial);
              const ox = offset * Math.cos(rot + side * Math.PI/2);
              const oz = offset * Math.sin(rot + side * Math.PI/2);
              door.position.set(posX + ox, doorHeight/2, posZ + oz);
              door.rotation.y = rot;
              isoState.scene.add(door);
            });
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.05, doorHeight, 0.08), frameMaterial);
            frame.position.set(posX, doorHeight/2, posZ);
            frame.rotation.y = rot;
            isoState.scene.add(frame);
          } else {
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
            const door = new THREE.Mesh(new THREE.BoxGeometry(doorWidth, doorHeight, 0.08), doorMaterial);
            door.position.set(posX, doorHeight/2, posZ);
            door.rotation.y = doorConfig.rotation || 0;
            isoState.scene.add(door);
          }
        },

        createWindow(winConfig) {
          const winWidth = winConfig.size || 2.0, winHeight = 1.3;
          const wallHeight = FLOOR_PLAN_CONFIG.wallHeight;
          const posX = winConfig.x - centerX, posZ = winConfig.z - centerZ;

          const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.5 });
          const glassMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.4 });

          const frame = new THREE.Mesh(new THREE.BoxGeometry(winWidth, winHeight, 0.15), frameMaterial);
          frame.position.set(posX, wallHeight * 0.55, posZ);
          frame.rotation.y = winConfig.rotation || 0;
          isoState.scene.add(frame);

          const glass = new THREE.Mesh(new THREE.BoxGeometry(winWidth * 0.9, winHeight * 0.85, 0.06), glassMaterial);
          glass.position.set(posX, wallHeight * 0.55, posZ);
          glass.rotation.y = winConfig.rotation || 0;
          isoState.scene.add(glass);
        },

        createBalconyRailing() {
          const bal = FLOOR_PLAN_CONFIG.balcony;
          const railingHeight = 1.0;
          const railingMaterial = new THREE.MeshStandardMaterial({ color: 0x374151, metalness: 0.7 });

          const front = new THREE.Mesh(new THREE.BoxGeometry(bal.width, railingHeight, 0.05), railingMaterial);
          front.position.set(bal.x - centerX, railingHeight/2, bal.z - centerZ + bal.depth/2);
          isoState.scene.add(front);

          const left = new THREE.Mesh(new THREE.BoxGeometry(0.05, railingHeight, bal.depth), railingMaterial);
          left.position.set(bal.x - centerX - bal.width/2, railingHeight/2, bal.z - centerZ);
          isoState.scene.add(left);

          const glassMaterial = new THREE.MeshStandardMaterial({ color: 0xccf0ff, transparent: true, opacity: 0.3 });
          const glassPanel = new THREE.Mesh(new THREE.BoxGeometry(bal.width, railingHeight * 0.7, 0.02), glassMaterial);
          glassPanel.position.set(bal.x - centerX, railingHeight * 0.4, bal.z - centerZ + bal.depth/2);
          isoState.scene.add(glassPanel);
        },

        createFurniture() {
          const furnitureMaterial = new THREE.MeshStandardMaterial({ color: 0x64748b, roughness: 0.6 });
          FLOOR_PLAN_CONFIG.furniture.forEach(item => {
            const roomConfig = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === item.room);
            if (!roomConfig) return;
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(item.width, item.height, item.depth), furnitureMaterial);
            mesh.position.set(roomConfig.x - centerX, item.height/2, roomConfig.z - centerZ);
            mesh.castShadow = true;
            isoState.scene.add(mesh);
            if (item.type === 'bed') {
              const bedding = new THREE.Mesh(
                new THREE.BoxGeometry(item.width * 0.95, 0.1, item.depth * 0.8),
                new THREE.MeshStandardMaterial({ color: 0x94a3b8, roughness: 0.8 })
              );
              bedding.position.set(roomConfig.x - centerX, item.height + 0.05, roomConfig.z - centerZ);
              isoState.scene.add(bedding);
            }
          });
        },

        setupPanControls(container) {
          container.addEventListener('pointerdown', (e) => {
            isoState.isPanning = true;
            isoState.lastPanPos = { x: e.clientX, y: e.clientY };
            container.setPointerCapture(e.pointerId);
            container.style.cursor = 'grabbing';
          });
          container.addEventListener('pointermove', (e) => {
            if (!isoState.isPanning) return;
            const dx = e.clientX - isoState.lastPanPos.x;
            const dy = e.clientY - isoState.lastPanPos.y;
            const panSpeed = 0.02 / this.zoomLevel;
            isoState.panOffset.x -= (dx - dy) * panSpeed * 0.7;
            isoState.panOffset.z -= (dx + dy) * panSpeed * 0.7;
            isoState.camera.lookAt(isoState.panOffset.x, 0, isoState.panOffset.z);
            isoState.lastPanPos = { x: e.clientX, y: e.clientY };
          });
          container.addEventListener('pointerup', (e) => {
            isoState.isPanning = false;
            container.releasePointerCapture(e.pointerId);
            container.style.cursor = 'grab';
          });
          container.addEventListener('pointerleave', () => {
            isoState.isPanning = false;
            container.style.cursor = 'grab';
          });
          container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
            this.setZoom(this.zoomLevel * zoomDelta);
          }, { passive: false });
        },

        setZoom(level) {
          this.zoomLevel = Math.max(0.5, Math.min(3.0, level));
          this.updateCameraZoom();
        },

        updateCameraZoom() {
          const container = this.$refs.isoContainer;
          if (!container || !isoState.camera) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          isoState.camera.left = frustumSize * aspect / -2;
          isoState.camera.right = frustumSize * aspect / 2;
          isoState.camera.top = frustumSize / 2;
          isoState.camera.bottom = frustumSize / -2;
          isoState.camera.updateProjectionMatrix();
        },

        zoomIn() { this.setZoom(this.zoomLevel * 1.2); },
        zoomOut() { this.setZoom(this.zoomLevel / 1.2); },

        resetView() {
          this.zoomLevel = 1.0;
          this.autoRotate = false;
          this.rotationAngle = Math.PI / 4; // 45 degrees (default isometric angle)
          isoState.panOffset = { x: 0, z: 0 };
          isoState.camera.position.set(10, 10, 10);
          isoState.camera.lookAt(0, 0, 0);
          this.updateCameraZoom();
        },

        createLabels(container) {
          Object.values(isoState.labelElements).forEach(label => {
            if (label && label.parentNode) label.parentNode.removeChild(label);
          });
          isoState.labelElements = {};
          container.querySelectorAll('.iso-label').forEach(el => el.remove());

          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'iso-label';
            labelDiv.innerHTML = `
              <div class="label-name">${config.icon} ${config.name}</div>
              <div class="label-value" data-room="${config.id}">--</div>
              <div class="label-secondary" data-room-secondary="${config.id}">--</div>
            `;
            container.appendChild(labelDiv);
            isoState.labelElements[config.id] = labelDiv;
          });
        },

        updateLabels() {
          const container = this.$refs.isoContainer;
          if (!container || !isoState.camera) return;
          const rooms = Alpine.store('rooms')?.list || [];
          const viewMode = this.viewMode;

          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            const label = isoState.labelElements[config.id];
            if (!label) return;
            const roomData = rooms.find(r => r.id === config.id);
            const valueEl = label.querySelector(`[data-room="${config.id}"]`);
            const secondaryEl = label.querySelector(`[data-room-secondary="${config.id}"]`);

            if (valueEl && roomData) {
              if (viewMode === 'temperature') {
                valueEl.textContent = roomData.temperature !== null ? `${roomData.temperature.toFixed(1)}¬∞` : '--';
                if (secondaryEl) secondaryEl.textContent = roomData.humidity !== null ? `${roomData.humidity.toFixed(0)}%` : '';
              } else {
                valueEl.textContent = roomData.humidity !== null ? `${roomData.humidity.toFixed(0)}%` : '--';
                if (secondaryEl) secondaryEl.textContent = roomData.temperature !== null ? `${roomData.temperature.toFixed(1)}¬∞` : '';
              }
            }

            const position = new THREE.Vector3(config.x - centerX, config.labelY || 3, config.z - centerZ);
            position.project(isoState.camera);
            const x = (position.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-position.y * 0.5 + 0.5) * container.clientHeight;
            label.style.left = `${x}px`;
            label.style.top = `${y}px`;

            const margin = 20;
            const isVisible = container.clientWidth > 0 && x > margin && x < container.clientWidth - margin && y > margin && y < container.clientHeight - margin;
            label.classList.toggle('visible', isVisible);
          });
        },

        updateRoomColors() {
          const rooms = Alpine.store('rooms')?.list || [];
          rooms.forEach(roomData => {
            const meshGroup = isoState.roomMeshes[roomData.id];
            if (!meshGroup) return;
            const floorMesh = meshGroup.children.find(child => child.name === 'floor_' + roomData.id);
            if (floorMesh && floorMesh.material) {
              floorMesh.material.color.setHex(this.getRoomColor(roomData, this.viewMode));
            }
          });
        },

        getRoomColor(room, viewMode) {
          if (!room) return 0xE0E0E0;
          const value = viewMode === 'temperature' ? room.temperature : room.humidity;
          if (value === null || value === undefined) return 0xE0E0E0;
          const scale = viewMode === 'temperature' ? TEMP_COLORS : HUMIDITY_COLORS;
          return this.interpolateColor(value, scale);
        },

        interpolateColor(value, scale) {
          if (value <= scale[0].value) return scale[0].color;
          if (value >= scale[scale.length - 1].value) return scale[scale.length - 1].color;
          let lower = scale[0], upper = scale[scale.length - 1];
          for (let i = 0; i < scale.length - 1; i++) {
            if (value >= scale[i].value && value <= scale[i + 1].value) {
              lower = scale[i];
              upper = scale[i + 1];
              break;
            }
          }
          const factor = (value - lower.value) / (upper.value - lower.value);
          const lowerColor = new THREE.Color(lower.color);
          const upperColor = new THREE.Color(upper.color);
          const result = new THREE.Color();
          result.lerpColors(lowerColor, upperColor, factor);
          return result.getHex();
        },

        toggleWalls() {
          this.wallsVisible = !this.wallsVisible;
          isoState.wallMeshes.forEach(wall => { wall.visible = this.wallsVisible; });
        },

        toggleDarkTheme() {
          this.darkTheme = !this.darkTheme;
          if (this.darkTheme) {
            isoState.scene.background = new THREE.Color(0x0f172a);
            isoState.scene.fog = new THREE.Fog(0x0f172a, 10, 50);
          } else {
            isoState.scene.background = new THREE.Color(0xE8E8EA);
            isoState.scene.fog = null;
          }
        },

        animate() {
          const self = this;
          const radius = 17.32; // Distance from center (sqrt(10^2 + 10^2 + 10^2) ‚âà 17.32)
          const height = 10;    // Camera height

          function loop() {
            isoState.animationId = requestAnimationFrame(loop);

            // Auto-rotate camera around the center
            if (self.autoRotate && isoState.camera) {
              self.rotationAngle += 0.005; // ~0.3 degrees per frame
              const x = Math.sin(self.rotationAngle) * radius;
              const z = Math.cos(self.rotationAngle) * radius;
              isoState.camera.position.set(x, height, z);
              isoState.camera.lookAt(isoState.panOffset.x, 0, isoState.panOffset.z);
            }

            self.updateRoomColors();
            self.updateLabels();
            if (isoState.renderer && isoState.scene && isoState.camera) {
              isoState.renderer.render(isoState.scene, isoState.camera);
            }
          }
          loop();
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (this.autoRotate) {
            // Calculate current angle from camera position
            const pos = isoState.camera.position;
            this.rotationAngle = Math.atan2(pos.x, pos.z);
          }
        },

        onResize() {
          const container = this.$refs.isoContainer;
          if (!container || !isoState.camera || !isoState.renderer) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          isoState.camera.left = frustumSize * aspect / -2;
          isoState.camera.right = frustumSize * aspect / 2;
          isoState.camera.top = frustumSize / 2;
          isoState.camera.bottom = frustumSize / -2;
          isoState.camera.updateProjectionMatrix();
          isoState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        setViewMode(mode) { this.viewMode = mode; },
        getZoomPercent() { return Math.round(this.zoomLevel * 100); }
      };
    }

    // ========================================
    // ZIGBEE NETWORK VIEW
    // Warm beige monochromatic visualization
    // ========================================

    const networkState = {
      scene: null,
      camera: null,
      renderer: null,
      roomMeshes: {},
      wallMeshes: [],
      wallNumberSprites: [],
      deviceMeshes: {},
      labelElements: {},
      signalElements: {},
      animationId: null,
      isInitialized: false,
      panOffset: { x: 0, z: 0 },
      isPanning: false,
      lastPanPos: { x: 0, y: 0 }
    };

    // Device configuration with types and icons
    const ZIGBEE_DEVICES = [
      { id: 'coordinator', name: 'ZBBridge-P', type: 'coordinator', icon: 'üì°', room: 'living', x: 0.5, z: 0.4 },
      { id: 'router1', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'study', x: 0.8, z: 0.2 },
      { id: 'router2', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'living', x: 0.3, z: 0.3 },
      { id: 'sensor1', name: 'SNZB-02P', type: 'end-device', icon: 'üå°Ô∏è', room: 'bedroom', x: 0.2, z: 0.15 },
      { id: 'sensor2', name: 'SNZB-03P', type: 'end-device', icon: 'üö∂', room: 'kitchen', x: 0.5, z: 0.1 },
      { id: 'sensor3', name: 'SNZB-04P', type: 'end-device', icon: 'üö™', room: 'bathroom', x: 0.85, z: 0.1 },
      { id: 'trv', name: 'TRVZB', type: 'end-device', icon: 'üî•', room: 'bedroom', x: 0.1, z: 0.25 },
    ];

    function networkView() {
      const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
      const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

      return {
        showSignalRange: false,
        showLabels: false,
        showWallNumbers: false,
        autoRotate: false,
        rotationAngle: 0,
        zoomLevel: 2.0,
        deviceCount: ZIGBEE_DEVICES.length,
        routerCount: ZIGBEE_DEVICES.filter(d => d.type === 'router').length,
        endDeviceCount: ZIGBEE_DEVICES.filter(d => d.type === 'end-device').length,

        init() {
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.networkContainer;
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          if (networkState.isInitialized && networkState.renderer) {
            if (!container.contains(networkState.renderer.domElement)) {
              container.appendChild(networkState.renderer.domElement);
            }
            this.createLabels(container);
            this.onResize();
            return;
          }

          if (networkState.renderer) networkState.renderer.dispose();
          if (networkState.scene) networkState.scene.clear();
          if (networkState.animationId) cancelAnimationFrame(networkState.animationId);

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.addWallNumbers();
          this.createDevices();
          this.createLabels(container);
          this.setupPanControls(container);
          this.animate();
          networkState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          networkState.scene = new THREE.Scene();
          // Warm beige gradient background
          networkState.scene.background = new THREE.Color(0xE8DFD4);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15;
          networkState.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2, 0.1, 1000
          );
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
        },

        initRenderer(container) {
          networkState.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
          networkState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          networkState.renderer.shadowMap.enabled = true;
          networkState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(networkState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.7);
          networkState.scene.add(ambient);
          const directional = new THREE.DirectionalLight(0xffffff, 0.6);
          directional.position.set(15, 20, 15);
          directional.castShadow = false;  // No shadows anywhere
          networkState.scene.add(directional);
          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          networkState.scene.add(fill);
        },

        addWallNumbers() {
          // Clear existing wall number sprites
          networkState.wallNumberSprites.forEach(sprite => {
            networkState.scene.remove(sprite);
            if (sprite.material.map) sprite.material.map.dispose();
            sprite.material.dispose();
          });
          networkState.wallNumberSprites = [];

          // Add number labels at start, middle, end of each wall for precise identification
          const createNumberSprite = (text, color = '#FF0000') => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(String(text), 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(0.4, 0.4, 1);
            return sprite;
          };

          // Direction labels by POSITION (reliable regardless of wall creation order)
          // Outer walls are identified by: edge position + full length
          const getOuterWallDirection = (wall) => {
            const apartmentWidth = FLOOR_PLAN_CONFIG.apartmentWidth;   // 9.239
            const apartmentDepth = FLOOR_PLAN_CONFIG.apartmentDepth;   // 7.665
            const halfW = apartmentWidth / 2;  // 4.6195
            const halfD = apartmentDepth / 2;  // 3.8325
            const tolerance = 0.05;  // Position tolerance (5cm) - outer walls are at exact edges
            const lengthTolerance = 0.2;  // Length must be within 20cm of full apartment dimension

            const params = wall.geometry.parameters;
            const isHorizontal = params.width > params.depth;  // Runs along X axis
            const isVertical = params.depth > params.width;    // Runs along Z axis

            let result = null;

            // Check for full-length horizontal walls (North/South)
            // In isometric view: z=-halfD appears at TOP (North), z=+halfD at BOTTOM (South)
            if (isHorizontal && Math.abs(params.width - apartmentWidth) < lengthTolerance) {
              if (Math.abs(wall.position.z - (-halfD)) < tolerance) result = 'N';  // Top edge
              else if (Math.abs(wall.position.z - halfD) < tolerance) result = 'S';  // Bottom edge
            }

            // Check for full-length vertical walls (West/East)
            // In isometric view: x=-halfW appears at LEFT (West), x=+halfW at RIGHT (East)
            if (isVertical && Math.abs(params.depth - apartmentDepth) < lengthTolerance) {
              if (Math.abs(wall.position.x - (-halfW)) < tolerance) result = 'W';  // Left edge
              else if (Math.abs(wall.position.x - halfW) < tolerance) result = 'E';  // Right edge
            }

            return result;
          };

          networkState.wallMeshes.forEach((wall, index) => {
            const geom = wall.geometry;
            const params = geom.parameters;
            const wx = wall.position.x;
            const wy = wall.position.y + 0.5;
            const wz = wall.position.z;

            // Check if this is an outer wall with direction label (by position)
            const directionLabel = getOuterWallDirection(wall);

            // Determine if wall is horizontal (along X) or vertical (along Z)
            const isHorizontal = params.width > params.depth;
            const wallLength = isHorizontal ? params.width : params.depth;
            const halfLen = wallLength / 2 * 0.8; // 80% to stay within wall bounds

            // Create 3 sprites: start, middle, end
            const positions = isHorizontal
              ? [[wx - halfLen, wy, wz], [wx, wy, wz], [wx + halfLen, wy, wz]]
              : [[wx, wy, wz - halfLen], [wx, wy, wz], [wx, wy, wz + halfLen]];

            positions.forEach((pos, i) => {
              // Use direction label (N/S/E/W) for outer walls, index number for inner walls
              const label = directionLabel || index.toString();
              // Green for direction labels, Red/Blue for numbered walls
              const color = directionLabel ? '#228B22' : (i === 1 ? '#FF0000' : '#0066CC');
              const sprite = createNumberSprite(label, color);
              sprite.position.set(pos[0], pos[1], pos[2]);
              sprite.visible = false;  // Hidden by default
              networkState.scene.add(sprite);
              networkState.wallNumberSprites.push(sprite);
            });
          });
        },

        toggleWallNumbers() {
          this.showWallNumbers = !this.showWallNumbers;
          networkState.wallNumberSprites.forEach(sprite => {
            sprite.visible = this.showWallNumbers;
          });
        },

        /**
         * WALL INDEX REFERENCE (Fully consolidated walls)
         * =================================================
         * Walls are pushed to networkState.wallMeshes in this EXACT order:
         *
         * FIRST: Room walls via createRoom() for each room in config order:
         *   Study:    0=left (back‚Üínorth wall, front skipped, right‚Üíeast wall)
         *   Living:   (none - all consolidated)
         *   Bedroom:  1=right divider (back skipped, left‚Üíwest wall, front‚Üísouth wall)
         *   Kitchen:  (none - all consolidated)
         *   Bathroom: 2=front (back‚Üínorth wall, left‚Üíwest wall, right‚Üíeast wall)
         *
         * THEN: Consolidated walls created in buildFloorPlan():
         *   3 = Study‚ÜîLiving horizontal divider
         *   4 = Coat hanging wall (hallway, 30% from north)
         *   5 = North wall (z=0, full apartment width)
         *   6 = West wall (x=0, full apartment depth)
         *   7 = East wall upper (Bathroom+Kitchen right, z=0 to z=3.697)
         *   8 = East wall lower (Study+Living right, z=0 to z=7.665)
         *   9 = South wall (full apartment width at z=7.665)
         *
         * TOTAL: 10 walls (indices 0-9)
         */
        buildFloorPlan() {
          networkState.wallMeshes = [];
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;  // 4.6195
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;  // 3.8325
          const floorColor = 0xC9B89A;  // Warm beige (same as rooms)

          // Base floor covering entire apartment (fills all gaps)
          const baseFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(FLOOR_PLAN_CONFIG.apartmentWidth + 2, FLOOR_PLAN_CONFIG.apartmentDepth + 2),
            new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 })
          );
          baseFloor.rotation.x = -Math.PI / 2;
          baseFloor.position.set(0, 0.001, 0);  // Lowest level, centered
          baseFloor.receiveShadow = true;
          networkState.scene.add(baseFloor);

          // Build rooms (each room has its own floor and outer walls)
          // NOTE: This runs FIRST, creating walls 0-15
          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            this.createRoom(config);
          });

          // Interior divider walls (created AFTER room walls, so these are walls 16-17)
          const wallHeight = 0.8;
          const wallMat = new THREE.MeshStandardMaterial({ color: 0xB5A080, roughness: 0.7, transparent: true, opacity: 0.6 });

          // Get room references
          const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
          const living = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'living');
          const kitchen = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'kitchen');
          const bedroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bedroom');
          const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');

          // Wall 3: Study ‚Üî Living (horizontal divider wall with 2 door openings)
          // Moved 0.5m towards study (into study area)
          const studyFrontZ = study.z + study.depth/2 - 0.5;  // 3.197 (moved towards study)

          // Door openings (0.42m wide each - reduced 30%)
          const doorWidth = 0.42;
          const door4X = 3.8;  // Bedroom ‚Üî Hallway (west door)
          const door2X = 4.8;  // Living ‚Üî Hallway (east door)

          const door4Left = door4X - doorWidth/2;   // 3.2
          const door4Right = door4X + doorWidth/2;  // 3.8
          const door2Left = door2X - doorWidth/2;   // 4.5
          const door2Right = door2X + doorWidth/2;  // 5.1

          // Left segment: from west edge (0) to door4 left edge
          const wall3LeftWidth = door4Left;
          const wall3Left = new THREE.Mesh(new THREE.BoxGeometry(wall3LeftWidth, wallHeight, 0.08), wallMat);
          wall3Left.position.set(door4Left/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Left);
          networkState.wallMeshes.push(wall3Left);

          // Middle segment: from door4 right edge to door2 left edge
          const wall3MidWidth = door2Left - door4Right;  // 4.5 - 3.8 = 0.7
          const wall3Mid = new THREE.Mesh(new THREE.BoxGeometry(wall3MidWidth, wallHeight, 0.08), wallMat);
          wall3Mid.position.set(door4Right + wall3MidWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Mid);
          networkState.wallMeshes.push(wall3Mid);

          // Right segment: from door2 right edge to east edge
          const wall3RightWidth = FLOOR_PLAN_CONFIG.apartmentWidth - door2Right;
          const wall3Right = new THREE.Mesh(new THREE.BoxGeometry(wall3RightWidth, wallHeight, 0.08), wallMat);
          wall3Right.position.set(door2Right + wall3RightWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Right);
          networkState.wallMeshes.push(wall3Right);

          // Wall 2: Kitchen ‚Üî Bedroom - REMOVED (was wall index 17)
          // This interior divider was redundant - bedroom's back wall already defines the boundary

          // Wall 4: Coat hanging wall in hallway (30% from north towards Study‚ÜîLiving divider)
          const wall16Z = 0;  // North connector position
          const wall15Z = study.z + study.depth/2;  // 3.697 (Study‚ÜîLiving divider)
          const coatWallLength = (wall15Z - wall16Z) * 0.30;  // 30% of distance ‚âà 1.1m
          const coatWallCenterZ = wall16Z + coatWallLength / 2;  // Start from wall 16

          // Position towards study (middle of hallway-study boundary)
          const coatWallX = 4.6;  // Moved from hallway center (3.839) towards study

          const coatWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, coatWallLength), wallMat);
          coatWall.position.set(coatWallX - centerX, wallHeight/2, coatWallCenterZ - centerZ);
          networkState.scene.add(coatWall);
          networkState.wallMeshes.push(coatWall);

          // Wall 5: North wall (consolidated from Study back + connector + Bathroom back)
          // Split into 2 segments with main entry door at x=3.5
          const mainDoorX = 4.0;
          const mainDoorWidth = 0.42;
          const mainDoorLeft = mainDoorX - mainDoorWidth/2;  // 3.29
          const mainDoorRight = mainDoorX + mainDoorWidth/2;  // 3.71

          // Segment 1: x=0 to door left edge (west side)
          const northSeg1Width = mainDoorLeft;  // 3.29
          const northWall1 = new THREE.Mesh(new THREE.BoxGeometry(northSeg1Width, wallHeight, 0.08), wallMat);
          northWall1.position.set(northSeg1Width/2 - centerX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall1);
          networkState.wallMeshes.push(northWall1);

          // Segment 2: door right edge to apartment east edge (east side)
          const northSeg2Width = FLOOR_PLAN_CONFIG.apartmentWidth - mainDoorRight;  // 9.239 - 3.71 = 5.529
          const northSeg2CenterX = (mainDoorRight + FLOOR_PLAN_CONFIG.apartmentWidth) / 2 - centerX;
          const northWall2 = new THREE.Mesh(new THREE.BoxGeometry(northSeg2Width, wallHeight, 0.08), wallMat);
          northWall2.position.set(northSeg2CenterX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall2);
          networkState.wallMeshes.push(northWall2);

          // Wall 7: West wall (FULL depth - balcony is on EAST side)
          const notch = FLOOR_PLAN_CONFIG.balconyNotch;
          const westWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, wallHeight, FLOOR_PLAN_CONFIG.apartmentDepth),
            wallMat
          );
          westWall.position.set(-centerX, wallHeight/2, 0);  // Centered in z (full depth)
          networkState.scene.add(westWall);
          networkState.wallMeshes.push(westWall);

          // Wall 10: East wall upper (Bathroom+Kitchen right consolidated)
          // Split into 3 segments with 2 door openings: bathroom (z=0.7) and kitchen (z=2.5)
          const wall10X = bathroom.x + bathroom.width/2;  // Right edge of bathroom/kitchen area (3.15)
          const wall10DoorWidth = 0.42;

          // Bathroom door at z=0.7
          const bathDoorZ = 0.7;
          const bathDoorTop = bathDoorZ - wall10DoorWidth/2;  // 0.49
          const bathDoorBottom = bathDoorZ + wall10DoorWidth/2;  // 0.91

          // Kitchen door at z=2.5
          const kitchenDoorZ = 2.5;
          const kitchenDoorTop = kitchenDoorZ - wall10DoorWidth/2;  // 2.29
          const kitchenDoorBottom = kitchenDoorZ + wall10DoorWidth/2;  // 2.71

          // Segment 1: z=0 to bathroom door top
          const wall10Seg1Depth = bathDoorTop;  // 0.49
          const eastWallUpper1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg1Depth), wallMat);
          eastWallUpper1.position.set(wall10X - centerX, wallHeight/2, wall10Seg1Depth/2 - centerZ);
          networkState.scene.add(eastWallUpper1);
          networkState.wallMeshes.push(eastWallUpper1);

          // Segment 2: bathroom door bottom to kitchen door top
          const wall10Seg2Depth = kitchenDoorTop - bathDoorBottom;  // 2.29 - 0.91 = 1.38
          const wall10Seg2CenterZ = (bathDoorBottom + kitchenDoorTop) / 2 - centerZ;
          const eastWallUpper2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg2Depth), wallMat);
          eastWallUpper2.position.set(wall10X - centerX, wallHeight/2, wall10Seg2CenterZ);
          networkState.scene.add(eastWallUpper2);
          networkState.wallMeshes.push(eastWallUpper2);

          // Segment 3: kitchen door bottom to studyFrontZ
          const wall10Seg3Depth = studyFrontZ - kitchenDoorBottom;  // 3.197 - 2.71 = 0.487
          const wall10Seg3CenterZ = (kitchenDoorBottom + studyFrontZ) / 2 - centerZ;
          const eastWallUpper3 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg3Depth), wallMat);
          eastWallUpper3.position.set(wall10X - centerX, wallHeight/2, wall10Seg3CenterZ);
          networkState.scene.add(eastWallUpper3);
          networkState.wallMeshes.push(eastWallUpper3);

          // Wall 9: East wall lower (Study+Living right - SHORTENED for balcony notch)
          // From z=0 to z=6.165 (stops before notch) at x = apartment east edge
          const wall9X = FLOOR_PLAN_CONFIG.apartmentWidth;  // 9.239 (east edge)
          const eastWallEndZ = FLOOR_PLAN_CONFIG.apartmentDepth - notch.depth;  // 7.665 - 1.5 = 6.165
          const eastWallCenterZ = eastWallEndZ / 2 - centerZ;  // Center of shortened wall
          const eastWallLower = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, eastWallEndZ), wallMat);
          eastWallLower.position.set(wall9X - centerX, wallHeight/2, eastWallCenterZ);
          networkState.scene.add(eastWallLower);
          networkState.wallMeshes.push(eastWallLower);

          // Wall 10: South wall (gap on EAST side for balcony notch)
          const southWallZ = FLOOR_PLAN_CONFIG.apartmentDepth;  // 7.665
          const southWallWidth = FLOOR_PLAN_CONFIG.apartmentWidth - notch.width;  // 9.239 - 1.5 = 7.739
          const southWallCenterX = southWallWidth / 2 - centerX;  // Gap on EAST side
          const southWall = new THREE.Mesh(
            new THREE.BoxGeometry(southWallWidth, wallHeight, 0.08),
            wallMat
          );
          southWall.position.set(southWallCenterX, wallHeight/2, southWallZ - centerZ);
          networkState.scene.add(southWall);
          networkState.wallMeshes.push(southWall);

          // ========== BALCONY AT SE CORNER, EXTENDS EAST ==========

          // Balcony positions
          const balconyOuterX = FLOOR_PLAN_CONFIG.apartmentWidth + notch.width;  // 9.239 + 1.5 = 10.739
          const balconyStartZ = FLOOR_PLAN_CONFIG.apartmentDepth - notch.depth;  // 6.165
          const notchFloorZ = (FLOOR_PLAN_CONFIG.apartmentDepth - notch.depth / 2) - centerZ;

          // Balcony floor - covers BOTH notch (inside) AND extension (outside east)
          const balconyFloorColor = 0xC0C0C2;  // Same as base floor
          const balconyFloorMat = new THREE.MeshStandardMaterial({
            color: balconyFloorColor,
            roughness: 0.8
          });

          // Notch floor (inside building) - from x=7.739 to x=9.239
          const notchFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(notch.width, notch.depth),
            balconyFloorMat
          );
          notchFloor.rotation.x = -Math.PI / 2;
          const notchFloorX = (FLOOR_PLAN_CONFIG.apartmentWidth - notch.width / 2) - centerX;
          notchFloor.position.set(notchFloorX, 0.01, notchFloorZ);
          networkState.scene.add(notchFloor);

          // Extension floor (outside building) - from x=9.239 to x=10.739
          const extFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(notch.width, notch.depth),
            balconyFloorMat
          );
          extFloor.rotation.x = -Math.PI / 2;
          const extFloorX = (FLOOR_PLAN_CONFIG.apartmentWidth + notch.width / 2) - centerX;
          extFloor.position.set(extFloorX, 0.01, notchFloorZ);
          networkState.scene.add(extFloor);

          // Wall 16: North balcony wall (along z = 6.165, extends EAST from notch to outer edge)
          const northBalconyWall = new THREE.Mesh(
            new THREE.BoxGeometry(notch.width * 2, wallHeight, 0.08),  // Double width to cover notch + extension
            wallMat
          );
          const wall16CenterX = FLOOR_PLAN_CONFIG.apartmentWidth - centerX;  // Centered at building edge
          northBalconyWall.position.set(wall16CenterX, wallHeight / 2, balconyStartZ - centerZ);
          networkState.scene.add(northBalconyWall);
          networkState.wallMeshes.push(northBalconyWall);

          // Wall 17: West notch wall (along x = 7.739, from z=6.165 to z=7.665)
          const vertStepWallX = (FLOOR_PLAN_CONFIG.apartmentWidth - notch.width) - centerX;
          const westNotchWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, wallHeight, notch.depth),
            wallMat
          );
          westNotchWall.position.set(vertStepWallX, wallHeight / 2, notchFloorZ);
          networkState.scene.add(westNotchWall);
          networkState.wallMeshes.push(westNotchWall);

          // Balcony railings (if enabled) - same color as walls
          if (notch.hasRailing) {
            const railingHeight = 0.5;  // Lower than walls
            const railingThickness = 0.05;
            const railingMat = new THREE.MeshStandardMaterial({
              color: 0xB5A080,  // Same as other walls
              roughness: 0.7,
              transparent: true,
              opacity: 0.6
            });

            // Wall 18: East railing (outer edge at x = 10.739)
            const eastRailing = new THREE.Mesh(
              new THREE.BoxGeometry(railingThickness, railingHeight, notch.depth),
              railingMat
            );
            eastRailing.position.set(balconyOuterX - centerX, railingHeight / 2, notchFloorZ);
            networkState.scene.add(eastRailing);
            networkState.wallMeshes.push(eastRailing);

            // Wall 19: South balcony wall (along z = 7.665, extends EAST across notch + extension)
            const southBalconyWall = new THREE.Mesh(
              new THREE.BoxGeometry(notch.width * 2, railingHeight, railingThickness),  // Double width
              railingMat
            );
            southBalconyWall.position.set(wall16CenterX, railingHeight / 2, southWallZ - centerZ);
            networkState.scene.add(southBalconyWall);
            networkState.wallMeshes.push(southBalconyWall);

            // Corner posts at outer edge
            const cornerPost1 = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, railingHeight, 8),
              railingMat
            );
            cornerPost1.position.set(balconyOuterX - centerX, railingHeight / 2, balconyStartZ - centerZ);
            networkState.scene.add(cornerPost1);

            const cornerPost2 = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, railingHeight, 8),
              railingMat
            );
            cornerPost2.position.set(balconyOuterX - centerX, railingHeight / 2, southWallZ - centerZ);
            networkState.scene.add(cornerPost2);
          }

          // Door X markers - adding from FLOOR_PLAN_CONFIG.doors
          const doorMarkerMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
          const markerSize = 0.3;
          const markerThickness = 0.05;
          const markerHeight = 0.02;

          // Helper function to add door marker
          const addDoorMarker = (x, z) => {
            const posX = x - centerX;
            const posZ = z - centerZ;

            // Bar 1 (diagonal \)
            const bar1 = new THREE.Mesh(
              new THREE.BoxGeometry(markerSize, markerHeight, markerThickness),
              doorMarkerMat
            );
            bar1.rotation.y = Math.PI / 4;
            bar1.position.set(posX, markerHeight/2, posZ);
            networkState.scene.add(bar1);

            // Bar 2 (diagonal /)
            const bar2 = new THREE.Mesh(
              new THREE.BoxGeometry(markerSize, markerHeight, markerThickness),
              doorMarkerMat
            );
            bar2.rotation.y = -Math.PI / 4;
            bar2.position.set(posX, markerHeight/2, posZ);
            networkState.scene.add(bar2);
          };

          // Door 2: Living ‚Üî Hallway - on Wall 3 (Study‚ÜîLiving divider at z=3.197)
          addDoorMarker(4.8, 3.197);

          // Door 3: Study door - on Wall 0 (study's left wall at x=5.331)
          addDoorMarker(5.331, 2.5);

          // Door 4: Bedroom ‚Üî Hallway - on Wall 3 (at x=3.8)
          addDoorMarker(3.8, 3.197);

          // Door 5: Kitchen door - on wall 10 (east wall upper at x=3.15)
          addDoorMarker(3.15, 2.5);

          // Door 6: Bathroom door - on wall 10 (east wall upper at x=3.15)
          addDoorMarker(3.15, 0.7);

          // Door 7: Main Entry - on north wall (z=0)
          addDoorMarker(4.0, 0);

          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          // WINDOW X MARKERS - Blue X on floor (like door markers but blue)
          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          const windowMarkerMat = new THREE.MeshBasicMaterial({ color: 0x0066FF });
          const winMarkerSize = 0.5;  // Larger than door markers

          const addWindowMarker = (x, z, index) => {
            // Offset x inside apartment for wall positions
            let actualX = x;
            if (x < 0.1) actualX = 0.5;  // West wall - offset 0.5m inside
            if (x > FLOOR_PLAN_CONFIG.apartmentWidth - 0.1) actualX = FLOOR_PLAN_CONFIG.apartmentWidth - 0.5;  // East wall

            const posX = actualX - centerX;
            const posZ = z - centerZ;

            // Bar 1 (diagonal \) - flat on floor
            const bar1 = new THREE.Mesh(
              new THREE.BoxGeometry(winMarkerSize, 0.05, 0.08),
              windowMarkerMat
            );
            bar1.rotation.y = Math.PI / 4;
            bar1.position.set(posX, 0.03, posZ);
            networkState.scene.add(bar1);

            // Bar 2 (diagonal /) - flat on floor
            const bar2 = new THREE.Mesh(
              new THREE.BoxGeometry(winMarkerSize, 0.05, 0.08),
              windowMarkerMat
            );
            bar2.rotation.y = -Math.PI / 4;
            bar2.position.set(posX, 0.03, posZ);
            networkState.scene.add(bar2);

            // Window number label (blue circle with W#)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0066FF';
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('W' + index, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const labelMat = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMat);
            label.scale.set(0.6, 0.6, 1);
            label.position.set(posX, 0.6, posZ);
            networkState.scene.add(label);
          };

          // Add window markers from config
          FLOOR_PLAN_CONFIG.windows.forEach((win, i) => {
            addWindowMarker(win.x, win.z, i + 1);
          });

          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          // COMPASS DIRECTION LABELS - N/S/E/W outside the building
          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          const halfW = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const halfD = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const compassOffset = 1.0;  // Distance outside building

          const compassLabels = [
            { label: 'N', x: 0, z: -halfD - compassOffset, color: '#2563EB' },  // North (blue)
            { label: 'S', x: 0, z: halfD + compassOffset, color: '#DC2626' },   // South (red)
            { label: 'W', x: -halfW - compassOffset, z: 0, color: '#059669' },  // West (green)
            { label: 'E', x: halfW + compassOffset, z: 0, color: '#D97706' }    // East (orange)
          ];

          compassLabels.forEach(({ label, x, z, color }) => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Circle background
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();

            // White letter
            ctx.fillStyle = 'white';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.8, 0.8, 1);
            sprite.position.set(x, 0.5, z);
            networkState.scene.add(sprite);
          });
        },

        createRoom(config) {
          const group = new THREE.Group();
          const floorColor = 0xC9B89A;  // Warm beige
          const wallColor = 0xB5A080;
          const wallHeight = 0.8;

          // Correct center coordinates (x,z are already center positions)
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const rx = config.x - centerX;
          const rz = config.z - centerZ;

          // Room floor at correct position
          const floorGeom = new THREE.PlaneGeometry(config.width, config.depth);
          const floorMat = new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 });
          const floor = new THREE.Mesh(floorGeom, floorMat);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(rx, 0.01, rz);
          floor.receiveShadow = true;
          group.add(floor);

          // Helipad-style room label on floor
          const helipadSize = Math.min(config.width, config.depth) * 0.6;
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');

          // Outer circle
          ctx.strokeStyle = 'rgba(90, 70, 50, 0.4)';
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.arc(128, 128, 110, 0, Math.PI * 2);
          ctx.stroke();

          // Inner circle
          ctx.strokeStyle = 'rgba(90, 70, 50, 0.3)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(128, 128, 85, 0, Math.PI * 2);
          ctx.stroke();

          // Room name text
          ctx.fillStyle = 'rgba(90, 70, 50, 0.5)';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(config.name.toUpperCase(), 128, 128);

          const helipadTexture = new THREE.CanvasTexture(canvas);
          const helipadGeom = new THREE.PlaneGeometry(helipadSize, helipadSize);
          const helipadMat = new THREE.MeshBasicMaterial({
            map: helipadTexture,
            transparent: true,
            depthWrite: false
          });
          const helipad = new THREE.Mesh(helipadGeom, helipadMat);
          helipad.rotation.x = -Math.PI / 2;
          helipad.position.set(rx, 0.02, rz);
          group.add(helipad);

          // Create all 4 walls automatically
          const halfW = config.width / 2;
          const halfD = config.depth / 2;
          const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.7, transparent: true, opacity: 0.6 });

          // Back wall (north) - skip for all rooms at z=0 edge (consolidated into single north wall)
          // Only bathroom has a front wall (interior divider at z=1.504)
          // Study, Living, Bedroom, Kitchen, Bathroom back walls are all consolidated
          if (false) {  // All back walls consolidated into single north wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
            backWall.position.set(rx, wallHeight/2, rz - halfD);
            group.add(backWall);
            networkState.wallMeshes.push(backWall);
          }

          // Front wall (south) - skip for study, kitchen, bedroom, living (consolidated into single south wall)
          if (config.id !== 'study' && config.id !== 'kitchen' && config.id !== 'bedroom' && config.id !== 'living') {
            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
            frontWall.position.set(rx, wallHeight/2, rz + halfD);
            group.add(frontWall);
            networkState.wallMeshes.push(frontWall);
          }

          // Left wall (west) - skip for living room and west-edge rooms (single west wall created in buildFloorPlan)
          const roomAtWestEdge = ['bathroom', 'kitchen', 'bedroom'].includes(config.id);
          if (config.id !== 'living' && !roomAtWestEdge) {
            // For study, use studyFrontZ (3.197) to join Wall 3
            // Split into 2 segments with door opening at z=1.85
            if (config.id === 'study') {
              const studyObj = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
              const studyFrontZ = studyObj.z + studyObj.depth/2 - 0.5;  // 3.197 (joins Wall 3)
              const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

              // Door opening parameters
              const doorZ = 2.5;  // Door center position (towards living room)
              const doorWidth = 0.42;  // Same as other doors
              const doorTop = doorZ - doorWidth/2;  // 1.64
              const doorBottom = doorZ + doorWidth/2;  // 2.06

              // Segment 1: from z=0 to door top edge
              const seg1Depth = doorTop;  // 1.64
              const seg1CenterZ = seg1Depth/2 - centerZ;
              const leftWall1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, seg1Depth), wallMat);
              leftWall1.position.set(rx - halfW, wallHeight/2, seg1CenterZ);
              leftWall1.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall1);
              networkState.wallMeshes.push(leftWall1);

              // Segment 2: from door bottom edge to studyFrontZ
              const seg2Depth = studyFrontZ - doorBottom;  // 3.197 - 2.06 = 1.137
              const seg2CenterZ = (doorBottom + studyFrontZ)/2 - centerZ;
              const leftWall2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, seg2Depth), wallMat);
              leftWall2.position.set(rx - halfW, wallHeight/2, seg2CenterZ);
              leftWall2.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall2);
              networkState.wallMeshes.push(leftWall2);
            } else {
              const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
              leftWall.position.set(rx - halfW, wallHeight/2, rz);
              leftWall.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall);
              networkState.wallMeshes.push(leftWall);
            }
          }

          // Right wall (east) - skip for rooms using consolidated east walls
          // Bathroom, Kitchen ‚Üí consolidated into east wall upper (Wall 8)
          // Study, Living ‚Üí consolidated into east wall lower (Wall 9)
          // Only Bedroom keeps its individual right wall (divider between bedroom and living)
          const roomsWithConsolidatedEastWall = ['bathroom', 'kitchen', 'study', 'living'];
          if (!roomsWithConsolidatedEastWall.includes(config.id)) {
            if (config.id === 'bedroom') {
              // Bedroom's right wall (Wall 1) serves as divider between bedroom and living
              // Extends from studyFrontZ (z=3.197) to south edge (z=7.665) - joins Wall 3
              const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
              const wall15Z = study.z + study.depth/2 - 0.5;  // 3.197 (same as Wall 3, joins it)
              const bedroomFrontZ = config.z + config.depth/2;  // 7.665 (apartment south edge)
              const extendedDepth = bedroomFrontZ - wall15Z;  // 4.468 (extended to join Wall 3)
              const extendedCenterZ = (wall15Z + bedroomFrontZ) / 2 - FLOOR_PLAN_CONFIG.apartmentDepth / 2;

              // Position moved towards living room (increased x by 0.8m)
              const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');
              const wall7X = bathroom.x + bathroom.width/2 + 0.8 - FLOOR_PLAN_CONFIG.apartmentWidth / 2;

              const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, extendedDepth), wallMat);
              rightWall.position.set(wall7X, wallHeight/2, extendedCenterZ);
              group.add(rightWall);
              networkState.wallMeshes.push(rightWall);
            } else {
              // Default right wall for any other rooms
              const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
              rightWall.position.set(rx + halfW, wallHeight/2, rz);
              group.add(rightWall);
              networkState.wallMeshes.push(rightWall);
            }
          }

          // Furniture
          this.createFurniture(group, config, rx, rz);

          networkState.scene.add(group);
          networkState.roomMeshes[config.id] = { group, floor, config };
        },

        createFurniture(group, config, rx, rz) {
          const furnitureColor = 0xBFA98A;
          const furnitureMat = new THREE.MeshStandardMaterial({ color: furnitureColor, roughness: 0.6 });

          if (config.id === 'bedroom') {
            // Bed
            const bedGeom = new THREE.BoxGeometry(1.4, 0.3, 2.0);
            const bed = new THREE.Mesh(bedGeom, furnitureMat);
            bed.position.set(rx - config.width/4, 0.15, rz);
            group.add(bed);
          } else if (config.id === 'living') {
            // Sofa
            const sofaGeom = new THREE.BoxGeometry(2.0, 0.4, 0.8);
            const sofa = new THREE.Mesh(sofaGeom, furnitureMat);
            sofa.position.set(rx, 0.2, rz + config.depth/4);
            group.add(sofa);
          } else if (config.id === 'study') {
            // Desk
            const deskGeom = new THREE.BoxGeometry(1.2, 0.5, 0.6);
            const desk = new THREE.Mesh(deskGeom, furnitureMat);
            desk.position.set(rx + config.width/4, 0.25, rz - config.depth/4);
            group.add(desk);
          }
        },

        createDevices() {
          networkState.deviceMeshes = {};
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

          ZIGBEE_DEVICES.forEach(device => {
            // Create device marker (sphere)
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            let color;
            switch (device.type) {
              case 'coordinator': color = 0xFF6B6B; break;
              case 'router': color = 0x4DABF7; break;
              default: color = 0x51CF66;
            }
            const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geometry, material);

            // Position based on room (room.x, room.z are center coords)
            const room = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === device.room);
            if (room) {
              const roomCenterX = room.x - centerX;
              const roomCenterZ = room.z - centerZ;  // FIX: use z not y
              mesh.position.set(
                roomCenterX + (device.x - 0.5) * room.width * 0.8,
                0.5,
                roomCenterZ + (device.z - 0.5) * room.depth * 0.8
              );
            }

            mesh.castShadow = true;
            networkState.scene.add(mesh);
            networkState.deviceMeshes[device.id] = { mesh, config: device };
          });
        },

        createLabels(container) {
          // Clear existing labels
          Object.values(networkState.labelElements).forEach(el => el?.remove());
          Object.values(networkState.signalElements).forEach(el => el?.remove());
          networkState.labelElements = {};
          networkState.signalElements = {};

          ZIGBEE_DEVICES.forEach(device => {
            // Device label
            const label = document.createElement('div');
            label.className = 'device-label visible';
            label.innerHTML = `
              <div class="device-icon ${device.type}">${device.icon}</div>
              <div class="device-name">${device.name}</div>
            `;
            container.appendChild(label);
            networkState.labelElements[device.id] = label;

            // Signal range circle (for coordinator and routers)
            if (device.type === 'coordinator' || device.type === 'router') {
              const signal = document.createElement('div');
              signal.className = `signal-range ${device.type}`;
              signal.style.width = device.type === 'coordinator' ? '200px' : '150px';
              signal.style.height = device.type === 'coordinator' ? '200px' : '150px';
              container.appendChild(signal);
              networkState.signalElements[device.id] = signal;
            }
          });
        },

        updateLabels() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;

          ZIGBEE_DEVICES.forEach(device => {
            const deviceData = networkState.deviceMeshes[device.id];
            const label = networkState.labelElements[device.id];
            const signal = networkState.signalElements[device.id];

            if (!deviceData || !label) return;

            const pos = deviceData.mesh.position.clone();
            pos.y += 0.3;
            pos.project(networkState.camera);

            const x = (pos.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-pos.y * 0.5 + 0.5) * container.clientHeight;

            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.style.display = this.showLabels ? 'flex' : 'none';

            if (signal) {
              signal.style.left = x + 'px';
              signal.style.top = (y + 40) + 'px';
              signal.style.display = this.showSignalRange ? 'block' : 'none';
            }
          });
        },

        setupPanControls(container) {
          container.addEventListener('pointerdown', (e) => {
            if (this.autoRotate) return;
            networkState.isPanning = true;
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
            container.style.cursor = 'grabbing';
          });

          container.addEventListener('pointermove', (e) => {
            if (!networkState.isPanning) return;
            const dx = e.clientX - networkState.lastPanPos.x;
            const dy = e.clientY - networkState.lastPanPos.y;
            networkState.panOffset.x -= dx * 0.02;
            networkState.panOffset.z -= dy * 0.02;
            networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
          });

          container.addEventListener('pointerup', () => {
            networkState.isPanning = false;
            container.style.cursor = 'grab';
          });

          container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.setZoom(this.zoomLevel * delta);
          }, { passive: false });
        },

        setZoom(level) {
          this.zoomLevel = Math.max(0.5, Math.min(3.0, level));
          this.updateCameraZoom();
        },

        updateCameraZoom() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
        },

        zoomIn() { this.setZoom(this.zoomLevel * 1.2); },
        zoomOut() { this.setZoom(this.zoomLevel / 1.2); },

        resetView() {
          this.zoomLevel = 1.0;
          this.autoRotate = false;
          this.rotationAngle = Math.PI / 4;
          networkState.panOffset = { x: 0, z: 0 };
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
          this.updateCameraZoom();
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (this.autoRotate) {
            const pos = networkState.camera.position;
            this.rotationAngle = Math.atan2(pos.x, pos.z);
          }
        },

        animate() {
          const self = this;
          const radius = 17.32;
          const height = 10;

          function loop() {
            networkState.animationId = requestAnimationFrame(loop);

            if (self.autoRotate && networkState.camera) {
              self.rotationAngle += 0.003;
              const x = Math.sin(self.rotationAngle) * radius;
              const z = Math.cos(self.rotationAngle) * radius;
              networkState.camera.position.set(x, height, z);
              networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            }

            self.updateLabels();
            if (networkState.renderer && networkState.scene && networkState.camera) {
              networkState.renderer.render(networkState.scene, networkState.camera);
            }
          }
          loop();
        },

        onResize() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera || !networkState.renderer) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        getZoomPercent() { return Math.round(this.zoomLevel * 100); }
      };
    }
  </script>
</body>
</html>
