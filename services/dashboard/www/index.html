<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Home Climate</title>

  <!-- FOIT Prevention: Set theme before any CSS loads -->
  <script>
    (function() {
      const stored = localStorage.getItem('dashboard-theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      let theme = 'light';
      if (stored === 'dark' || (stored === 'system' && prefersDark) || (!stored && prefersDark)) {
        theme = 'dark';
      }
      document.documentElement.setAttribute('data-theme', theme);
      document.documentElement.setAttribute('data-theme-preference', stored || 'system');
    })();
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Modularized CSS -->
  <link rel="stylesheet" href="styles/base.css">
  <link rel="stylesheet" href="styles/layout.css?v=3">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/views/timeline.css">
  <link rel="stylesheet" href="styles/views/logs.css">
  <link rel="stylesheet" href="styles/views/classic.css">
  <link rel="stylesheet" href="styles/views/lights.css">
  <link rel="stylesheet" href="styles/views/co2-view.css">
  <link rel="stylesheet" href="styles/views/network.css">
  <link rel="stylesheet" href="styles/views/thermostat.css?v=6">
  <link rel="stylesheet" href="styles/views/mailbox.css">

  <!-- Three.js for 3D Floor Plan -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // OrbitControls for Three.js r128 (inline to ensure compatibility)
    THREE.OrbitControls = function(object, domElement) {
      this.object = object;
      this.domElement = domElement;
      this.target = new THREE.Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.autoRotate = false;
      this.autoRotateSpeed = 2.0;

      var scope = this;
      var spherical = new THREE.Spherical();
      var sphericalDelta = new THREE.Spherical();
      var scale = 1;
      var panOffset = new THREE.Vector3();
      var rotateStart = new THREE.Vector2();
      var rotateEnd = new THREE.Vector2();
      var rotateDelta = new THREE.Vector2();
      var panStart = new THREE.Vector2();
      var panEnd = new THREE.Vector2();
      var panDelta = new THREE.Vector2();
      var dollyStart = new THREE.Vector2();
      var dollyEnd = new THREE.Vector2();
      var dollyDelta = new THREE.Vector2();

      var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
      var state = STATE.NONE;

      this.update = function() {
        var offset = new THREE.Vector3();
        var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
        var quatInverse = quat.clone().invert();
        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        return function update() {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state === STATE.NONE) sphericalDelta.theta -= 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping) scope.target.addScaledVector(panOffset, scope.dampingFactor);
          else scope.target.add(panOffset);
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping) {
            sphericalDelta.theta *= (1 - scope.dampingFactor);
            sphericalDelta.phi *= (1 - scope.dampingFactor);
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          return false;
        };
      }();

      function onPointerDown(event) {
        if (event.pointerType === 'touch') {
          // Skip for now - simplified
        } else {
          onMouseDown(event);
        }
      }

      function onPointerMove(event) {
        if (event.pointerType === 'touch') {
          // Skip for now - simplified
        } else {
          onMouseMove(event);
        }
      }

      function onPointerUp(event) {
        state = STATE.NONE;
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener('pointermove', onPointerMove);
        scope.domElement.removeEventListener('pointerup', onPointerUp);
      }

      function onMouseDown(event) {
        event.preventDefault();
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener('pointermove', onPointerMove);
        scope.domElement.addEventListener('pointerup', onPointerUp);
        if (event.button === 0) {
          state = STATE.ROTATE;
          rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === 2) {
          state = STATE.PAN;
          panStart.set(event.clientX, event.clientY);
        }
      }

      function onMouseMove(event) {
        if (state === STATE.ROTATE) {
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(0.005);
          sphericalDelta.theta -= rotateDelta.x;
          sphericalDelta.phi -= rotateDelta.y;
          rotateStart.copy(rotateEnd);
        } else if (state === STATE.PAN) {
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart).multiplyScalar(0.02);
          var v = new THREE.Vector3();
          v.setFromMatrixColumn(scope.object.matrix, 0);
          v.multiplyScalar(-panDelta.x);
          panOffset.add(v);
          v.setFromMatrixColumn(scope.object.matrix, 1);
          v.multiplyScalar(panDelta.y);
          panOffset.add(v);
          panStart.copy(panEnd);
        }
      }

      function onMouseWheel(event) {
        event.preventDefault();
        if (event.deltaY < 0) scale /= 0.95;
        else if (event.deltaY > 0) scale *= 0.95;
      }

      function onContextMenu(event) {
        event.preventDefault();
      }

      this.domElement.addEventListener('pointerdown', onPointerDown);
      this.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
      this.domElement.addEventListener('contextmenu', onContextMenu);

      this.dispose = function() {
        scope.domElement.removeEventListener('pointerdown', onPointerDown);
        scope.domElement.removeEventListener('wheel', onMouseWheel);
        scope.domElement.removeEventListener('contextmenu', onContextMenu);
      };

      this.update();
    };
  </script>
</head>
<body>
  <div class="app-container" x-data="app()" x-init="init()">

    <!-- Unified Header with Navigation -->
    <header class="app-header" x-data="navigation()" x-init="init()"
            @keydown.window="handleKeydown($event)"
            @keydown.escape.window="moreMenuOpen = false">
      <div class="header-content">
        <!-- Left: Logo + Status + Nav -->
        <div class="header-nav">
          <span class="header-logo">üè†</span>
          <div class="status-indicator">
            <span class="loading-indicator loading-sm" x-show="$store.mqtt.connecting"></span>
            <span class="status-dot" x-show="!$store.mqtt.connecting" :class="{ 'online': $store.mqtt.connected, 'offline': !$store.mqtt.connected }"></span>
          </div>

          <!-- Navigation tabs - all views in single line -->
          <div class="nav-primary">
            <template x-for="view in allViews" :key="view.id">
              <button class="nav-tab"
                      :class="{ active: currentView === view.id }"
                      @click="setView(view.id)"
                      :title="view.title + ' (' + view.key + ')'">
                <span class="nav-icon" x-text="view.icon"></span>
                <span class="nav-label" x-text="view.name"></span>
              </button>
            </template>
          </div>

        </div>

        <!-- Right: Kiosk Controls + Theme Toggle + Date/Time -->
        <div class="header-right">
          <div class="header-top">
            <!-- Hard Refresh Button (for kiosk mode) -->
            <button class="refresh-btn"
                    @click="location.reload(true)"
                    title="Hard refresh (bypass cache)">
              üîÑ
            </button>
            <!-- Theme Toggle -->
            <div class="theme-toggle" x-data>
              <button class="theme-toggle-btn"
                      :class="{ active: $store.theme.preference === 'light' }"
                      @click="$store.theme.setPreference('light')"
                      title="Light mode">‚òÄÔ∏è</button>
              <button class="theme-toggle-btn"
                      :class="{ active: $store.theme.preference === 'dark' }"
                      @click="$store.theme.setPreference('dark')"
                      title="Dark mode">üåô</button>
              <button class="theme-toggle-btn"
                      :class="{ active: $store.theme.preference === 'system' }"
                      @click="$store.theme.setPreference('system')"
                      title="System preference">‚öôÔ∏è</button>
            </div>
            <div class="date-time" x-text="currentDateTime"></div>
            <button class="panel-toggle"
                    @click="togglePanel()"
                    :title="panelOpen ? 'Hide overview panel' : 'Show overview panel'">
              <span x-text="panelOpen ? '¬ª' : '¬´'"></span>
            </button>
          </div>
          <div class="last-update" x-text="'Last update: ' + lastUpdateText"></div>
        </div>
      </div>
    </header>

    <!-- Main Content + Overview Panel -->
    <div class="app-body">
    <main class="app-main">
      <div class="view-container">

        <!-- Vision 5: Timeline (All Zigbee Events) -->
        <div x-show="currentView === 'timeline'" x-cloak x-data="timelineView()">
          <div class="timeline-view">
            <!-- Header -->
            <div class="timeline-header">
              <div class="timeline-title-row">
                <h2 class="timeline-title">Event Timeline</h2>
                <button class="btn btn-icon" @click="refresh()">Refresh</button>
              </div>

              <!-- Date Range Selector -->
              <div class="date-selector">
                <button class="btn btn-secondary" :class="{ active: currentDateRange === 'today' }"
                        @click="setDateRange('today')">Today</button>
                <button class="btn btn-secondary" :class="{ active: currentDateRange === 'yesterday' }"
                        @click="setDateRange('yesterday')">Yesterday</button>
                <button class="btn btn-secondary" :class="{ active: currentDateRange === 'week' }"
                        @click="setDateRange('week')">This Week</button>
              </div>
            </div>

            <!-- Filter Bar (Always Visible) -->
            <div class="timeline-filter-bar">
              <!-- Room Dropdown -->
              <select class="filter-select" x-model="selectedRoom" @change="setRoom($event.target.value)">
                <option value="">All Rooms</option>
                <template x-for="room in availableRooms" :key="room">
                  <option :value="room" x-text="room"></option>
                </template>
              </select>

              <!-- Device Type Dropdown -->
              <select class="filter-select" x-model="selectedDeviceType" @change="setDeviceType($event.target.value)">
                <option value="">All Types</option>
                <template x-for="type in availableDeviceTypes" :key="type.id">
                  <option :value="type.id" x-text="type.label"></option>
                </template>
              </select>

              <!-- Device Dropdown -->
              <select class="filter-select" x-model="selectedDevice" @change="setDevice($event.target.value)">
                <option value="">All Devices</option>
                <template x-for="device in availableDevices" :key="device">
                  <option :value="device" x-text="device"></option>
                </template>
              </select>

              <!-- Clear Filters -->
              <button class="btn btn-secondary btn-small" @click="clearFilters()"
                      x-show="selectedRoom || selectedDeviceType || selectedDevice">Clear</button>
            </div>

            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                 DAILY SUMMARY CARD
                 "A quiet morning. Front door opened once, air quality excellent."
                 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
            <div class="timeline-summary">
              <p class="summary-text" x-text="dailySummary"></p>
              <div class="summary-stats">
                <span class="summary-stat" :class="{ 'has-value': stats.doorCount > 0 }">
                  üö™ <span x-text="stats.doorCount"></span>
                </span>
                <span class="summary-stat" :class="{ 'has-value': stats.motionCount > 0 }">
                  üëÅÔ∏è <span x-text="stats.motionCount"></span>
                </span>
                <span class="summary-stat" :class="{ 'has-value': stats.mailboxCount > 0 }">
                  üì¨ <span x-text="stats.mailboxCount"></span>
                </span>
                <span class="summary-stat air-status" x-text="airQualityStatus"></span>
              </div>
            </div>

            <!-- Loading State -->
            <template x-if="$store.events.loading">
              <div class="loading-events">
                <span class="loading-indicator"></span>
                <span>Loading events...</span>
              </div>
            </template>

            <!-- No Events State -->
            <template x-if="events.length === 0 && !$store.events.loading">
              <div class="no-events">
                <span class="no-events-icon">üì≠</span>
                <span class="no-events-text">No events found</span>
                <span class="no-events-hint">Events will appear here as devices report activity</span>
              </div>
            </template>

            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                 IMPORTANT EVENTS - Security & Alerts (Full Cards)
                 Door opened, Mail arrived, Air: Poor, Device offline
                 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
            <div class="timeline-section" x-show="groupedEvents.important.length > 0">
              <h3 class="section-title section-important">
                <span class="section-icon">üî¥</span> Important
                <span class="section-count" x-text="groupedEvents.important.length"></span>
              </h3>
              <div class="important-events">
                <template x-for="event in groupedEvents.important" :key="event.time + event.deviceName">
                  <div class="event-important" :style="{ borderLeftColor: getEventInfo(event.eventType).color }">
                    <div class="important-icon" x-text="getEventInfo(event.eventType).icon"></div>
                    <div class="important-content">
                      <div class="important-title" x-text="getEventInfo(event.eventType).label"></div>
                      <div class="important-device" x-text="getHumanDescription(event) || formatDeviceName(event.deviceName)"></div>
                      <div class="important-room" x-show="event.room && event.room !== 'unknown'" x-text="event.room"></div>
                    </div>
                    <div class="important-time">
                      <span class="time-absolute" x-text="formatTime(event.time)"></span>
                      <span class="time-relative" x-text="formatRelativeTime(event.time)"></span>
                    </div>
                  </div>
                </template>
              </div>
            </div>

            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                 ACTIVITY EVENTS - Routine but Interesting (Compact Lines)
                 Motion, Lights, Door closed, Plugs
                 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
            <div class="timeline-section" x-show="groupedEvents.activity.length > 0">
              <h3 class="section-title section-activity">
                <span class="section-icon">üü°</span> Activity
                <span class="section-count" x-text="groupedEvents.activity.length"></span>
              </h3>
              <div class="activity-events">
                <template x-for="event in groupedEvents.activity.slice(0, 20)" :key="event.time + event.deviceName + event.eventType">
                  <div class="event-line" :class="getEventClass(event.eventType)">
                    <span class="line-time" x-text="formatTime(event.time)"></span>
                    <span class="line-icon" x-text="getEventInfo(event.eventType).icon"></span>
                    <span class="line-label" x-text="getEventInfo(event.eventType).label"></span>
                    <span class="line-room" x-text="event.room !== 'unknown' ? event.room : ''"></span>
                    <span class="line-detail" x-text="getHumanDescription(event)"></span>
                  </div>
                </template>
                <!-- Show more indicator -->
                <div class="activity-more" x-show="groupedEvents.activity.length > 20">
                  <span x-text="'+ ' + (groupedEvents.activity.length - 20) + ' more activity events'"></span>
                </div>
              </div>
            </div>

            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                 BACKGROUND EVENTS - Noise (Collapsed Groups)
                 Device online, Air quality readings
                 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
            <div class="timeline-section background-section" x-show="backgroundCount > 0">
              <button class="section-header-btn" @click="showBackground = !showBackground">
                <h3 class="section-title section-background">
                  <span class="section-icon">‚ö™</span> Background
                  <span class="section-count" x-text="backgroundCount + ' events'"></span>
                </h3>
                <span class="expand-icon" x-text="showBackground ? '‚ñ≤' : '‚ñº'"></span>
              </button>

              <div class="background-groups" x-show="showBackground" x-transition>
                <template x-for="(events, group) in groupedEvents.background" :key="group">
                  <div class="background-group" x-show="events.length > 0">
                    <span class="group-icon" x-text="getGroupIcon(group)"></span>
                    <span class="group-count" x-text="events.length + '√ó'"></span>
                    <span class="group-label" x-text="getGroupLabel(group)"></span>
                    <span class="group-detail" x-text="getGroupSummary(group, events)"></span>
                  </div>
                </template>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 6: Classic Cards View - Multi-Sensor -->
        <div x-show="currentView === 'classic'" x-cloak x-data="classicView()">
          <div class="classic-view">
            <!-- Room Grid -->
            <div class="classic-grid">
              <template x-for="room in rooms" :key="room.id">
                <div class="classic-card-v2"
                     :class="{
                       'has-co2': room.sensors && room.sensors.some(s => s.type === 'co2')
                     }">

                  <!-- Comfort indicator strip -->
                  <div class="classic-comfort-strip" :class="{
                    'cold': (room.avgTemperature || room.temperature) < 20,
                    'cool': (room.avgTemperature || room.temperature) >= 20 && (room.avgTemperature || room.temperature) < 23,
                    'good': (room.avgTemperature || room.temperature) >= 23 && (room.avgTemperature || room.temperature) <= 26,
                    'warm': (room.avgTemperature || room.temperature) > 26 && (room.avgTemperature || room.temperature) <= 28,
                    'hot': (room.avgTemperature || room.temperature) > 28
                  }"></div>

                  <!-- Card Header -->
                  <div class="classic-header-v2">
                    <div class="room-title">
                      <span class="room-icon" x-text="room.icon"></span>
                      <span class="room-name" x-text="room.name"></span>
                    </div>
                  </div>

                  <!-- Average Values - Prominent Display -->
                  <div class="room-averages-section">
                    <div class="avg-temp-display">
                      <span x-html="formatTempStyled(room.avgTemperature ?? room.temperature, false)"></span>
                      <span class="avg-unit">¬∞C</span>
                      <span class="trend-indicator" :class="'trend-' + $store.rooms.getTempTrend(room)" x-text="$store.rooms.getTempTrend(room) === 'rising' ? '‚ñ≤' : ($store.rooms.getTempTrend(room) === 'falling' ? '‚ñº' : '')"></span>
                    </div>
                    <div class="avg-humid-display">
                      <span class="humid-icon">üíß</span>
                      <span x-text="room.avgHumidity != null ? room.avgHumidity.toFixed(0) + '%' : (room.humidity != null ? room.humidity.toFixed(0) + '%' : '--%')"></span>
                      <span class="trend-indicator" :class="'trend-' + $store.rooms.getHumidTrend(room)" x-text="$store.rooms.getHumidTrend(room) === 'rising' ? '‚ñ≤' : ($store.rooms.getHumidTrend(room) === 'falling' ? '‚ñº' : '')"></span>
                    </div>
                  </div>

                  <!-- Sensor List - show if multiple sensors OR has CO2/special sensors -->
                  <div class="sensor-list" x-show="room.sensors && (room.sensors.length > 1 || room.sensors.some(s => s.type === 'co2'))">
                    <template x-for="sensor in (room.sensors || [])" :key="sensor.name + '-' + sensor.type">
                      <div class="sensor-row" :class="{ 'stale': !sensor.lastSeen || (Date.now() - sensor.lastSeen > 300000), 'no-data': sensor.temperature == null && sensor.co2 == null }">
                        <span class="sensor-icon" x-text="sensor.type === 'motion' ? 'üëÅ' : (sensor.type === 'contact' ? '‚óØ' : '')"></span>
                        <span class="sensor-label" x-text="sensor.label + (sensor.type === 'thermostat' ? ' ‚ñ≥' : '')"></span>
                        <template x-if="sensor.type === 'climate' || !sensor.type">
                          <div class="sensor-values">
                            <span class="sensor-temp" x-html="formatTempStyled(sensor.temperature)"></span>
                            <span class="sensor-humid" x-show="sensor.humidity != null">üíß<span x-text="sensor.humidity ? sensor.humidity.toFixed(0) + '%' : ''"></span></span>
                          </div>
                        </template>
                        <template x-if="sensor.type === 'thermostat'">
                          <div class="sensor-values">
                            <span class="sensor-temp" x-html="formatTempStyled(sensor.temperature)"></span>
                          </div>
                        </template>
                        <template x-if="sensor.type === 'co2'">
                          <div class="sensor-values">
                            <span class="sensor-co2" x-text="sensor.co2 != null ? sensor.co2 + ' ppm' : '-- ppm'"></span>
                          </div>
                        </template>
                        <span class="sensor-status" :class="{ 'fresh': sensor.lastSeen && (Date.now() - sensor.lastSeen <= 300000) && (sensor.temperature != null || sensor.co2 != null), 'stale': !sensor.lastSeen || (Date.now() - sensor.lastSeen > 300000) || (sensor.temperature == null && sensor.co2 == null) }"></span>
                      </div>
                    </template>
                  </div>

                  <!-- Sparkline -->
                  <div class="classic-sparkline">
                    <svg :id="'classic-spark-' + room.id" class="sparkline-svg" preserveAspectRatio="none"></svg>
                  </div>

                  <!-- Card Footer -->
                  <div class="card-footer-v2">
                    <span class="temp-spread" x-show="room.tempSpread && room.tempSpread >= 0.1">
                      Spread: <span x-text="room.tempSpread ? '¬±' + (room.tempSpread / 2).toFixed(1) + '¬∞' : ''"></span>
                    </span>
                    <button class="detail-btn" @click.stop="$store.roomDetail.open(room)">Details</button>
                  </div>
                </div>
              </template>
            </div>

            <!-- Average Card -->
            <div class="classic-average">
              <div class="avg-section">
                <div class="avg-label">Home Average Temperature</div>
                <div class="avg-value">
                  <template x-if="avgTemperature !== null">
                    <span><span x-text="avgTemperature.toFixed(1)"></span><span class="avg-unit">¬∞C</span></span>
                  </template>
                  <template x-if="avgTemperature === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider"></div>
              <div class="avg-section">
                <div class="avg-label">Home Average Humidity</div>
                <div class="avg-value">
                  <template x-if="avgHumidity !== null">
                    <span><span x-text="avgHumidity.toFixed(0)"></span><span class="avg-unit">%</span></span>
                  </template>
                  <template x-if="avgHumidity === null">
                    <span class="no-data">--</span>
                  </template>
                </div>
              </div>
              <div class="avg-divider hidden-mobile"></div>
              <div class="avg-chart">
                <svg id="classic-spark-avg" class="sparkline-svg" preserveAspectRatio="none"></svg>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 7: Lights Control -->
        <div x-show="currentView === 'lights'" x-cloak x-data="lightsView()">
          <div class="lights-view">
            <!-- Master Control Toggle -->
            <div class="master-control"
                 :class="{
                   'master-on': $store.lights.list.every(l => l.state === 'ON'),
                   'master-syncing': $store.lights.syncing,
                   'master-disabled': !$store.mqtt.connected || $store.lights.initializing
                 }">
              <div class="master-info">
                <span class="master-icon">üí°</span>
                <div class="master-text">
                  <span class="master-label">Master Control</span>
                  <span class="master-status" x-text="$store.lights.lightsOnCount + ' of ' + $store.lights.list.length + ' lights on'"></span>
                </div>
              </div>
              <button class="light-toggle master-toggle"
                      :class="{ 'toggle-on': $store.lights.list.every(l => l.state === 'ON'), 'toggle-syncing': $store.lights.syncing }"
                      @click="$store.lights.toggleAllLights()"
                      :disabled="$store.lights.syncing || !$store.mqtt.connected || $store.lights.initializing">
                <div class="toggle-track">
                  <div class="toggle-thumb"></div>
                </div>
              </button>
            </div>

            <!-- Initializing overlay -->
            <div class="lights-initializing" x-show="$store.lights.initializing && $store.mqtt.connected" x-transition>
              <span class="loading-indicator loading-lg"></span>
              <span>Loading light states...</span>
            </div>

            <!-- Not connected warning -->
            <div class="lights-warning" x-show="!$store.mqtt.connected">
              <span class="loading-indicator"></span>
              <span>Connecting to MQTT...</span>
            </div>

            <!-- Light Cards -->
            <div class="lights-grid" :class="{ 'lights-disabled': !$store.mqtt.connected || $store.lights.initializing }">
              <template x-for="light in $store.lights.list" :key="light.id">
                <div class="light-card" :class="{ 'light-on': light.state === 'ON' && light.available, 'light-off': light.state === 'OFF' && light.available, 'light-syncing': light.syncing, 'light-unavailable': !light.available }">
                  <!-- Syncing overlay -->
                  <div class="light-syncing-overlay" x-show="light.syncing && light.available" x-transition.opacity>
                    <span class="loading-indicator"></span>
                  </div>

                  <div class="light-header">
                    <div class="light-info">
                      <span class="light-icon" x-text="light.icon"></span>
                      <div class="light-details">
                        <span class="light-name" x-text="light.name"></span>
                        <span class="light-status">
                          <span x-show="light.available && light.syncing" class="syncing-text">Syncing...</span>
                          <span x-show="light.available && !light.syncing" x-text="light.state === 'ON' ? 'On' : 'Off'"></span>
                        </span>
                      </div>
                    </div>
                    <button class="light-toggle" :class="{ 'toggle-on': light.state === 'ON' && light.available, 'toggle-syncing': light.syncing, 'toggle-unavailable': !light.available }"
                            @click="$store.lights.toggleLight(light)" :disabled="light.syncing || !light.available">
                      <div class="toggle-track">
                        <div class="toggle-thumb">
                          <span class="loading-indicator loading-sm" x-show="light.syncing"></span>
                        </div>
                      </div>
                    </button>
                  </div>

                  <!-- Brightness Slider -->
                  <div class="light-control" x-show="light.state === 'ON' && light.available" x-transition
                       :class="{ 'control-disabled': !$store.mqtt.connected || $store.lights.initializing || light.syncing }">
                    <div class="control-row">
                      <label class="control-label">
                        <span class="control-icon">üîÜ</span>
                        Brightness
                      </label>
                      <span class="control-value">
                        <span x-show="light.syncing" class="control-syncing">‚ü≥</span>
                      </span>
                    </div>
                    <div class="slider-wrapper">
                      <input type="range" class="slider brightness-slider" min="1" max="254"
                             x-model="light.brightness"
                             :disabled="!$store.mqtt.connected || $store.lights.initializing"
                             @input="$store.lights.setBrightness(light, $event.target.value)"
                             :style="'background: linear-gradient(90deg, rgba(255,220,180,0.8) 0%, rgba(255,240,210,0.6) ' + (light.brightness / 254 * 100) + '%, rgba(245,245,247,1) ' + (light.brightness / 254 * 100) + '%, rgba(245,245,247,1) 100%)'">
                      <span class="slider-percent" x-text="Math.round(light.brightness / 254 * 100) + '%'"></span>
                    </div>
                  </div>

                  <!-- Color Temperature Slider -->
                  <div class="light-control" x-show="light.state === 'ON' && light.available" x-transition
                       :class="{ 'control-disabled': !$store.mqtt.connected || $store.lights.initializing || light.syncing }">
                    <div class="control-row">
                      <label class="control-label">
                        <span class="control-icon">üå°Ô∏è</span>
                        Color Temp
                      </label>
                      <span class="control-value">
                        <span x-show="light.syncing" class="control-syncing">‚ü≥</span>
                        <span x-text="getColorTempLabel(light.colorTemp)"></span>
                      </span>
                    </div>
                    <input type="range" class="slider colortemp-slider" min="250" max="454"
                           x-model="light.colorTemp"
                           :disabled="!$store.mqtt.connected || $store.lights.initializing"
                           @input="$store.lights.setColorTemp(light, $event.target.value)">
                    <div class="colortemp-labels">
                      <span>Cool</span>
                      <span>Warm</span>
                    </div>
                  </div>

                  <!-- Quick Presets -->
                  <div class="light-presets" x-show="light.state === 'ON' && light.available" x-transition>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'reading')" title="Reading">üìñ</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'relax')" title="Relax">üåÖ</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'bright')" title="Bright">‚òÄÔ∏è</button>
                    <button class="preset-btn" @click="$store.lights.applyPreset(light, 'night')" title="Night">üåô</button>
                  </div>

                  <!-- Link Quality -->
                  <div class="light-meta">
                    <span class="light-availability" :class="{ 'available': light.available, 'unavailable': !light.available }">
                      <span x-text="light.available ? 'üü¢' : 'üî¥'"></span>
                      <span x-text="light.available ? 'Online' : 'Offline'"></span>
                    </span>
                    <span class="light-linkquality" x-show="light.available" :title="'Link Quality: ' + light.linkquality">
                      üì∂ <span x-text="light.linkquality || '--'"></span>
                    </span>
                    <span class="light-update" x-text="formatLastUpdate(light.lastSeen)"></span>
                  </div>
                </div>
              </template>
            </div>

            <!-- Scene Buttons -->
            <div class="lights-scenes" :class="{ 'lights-disabled': !$store.mqtt.connected || $store.lights.initializing }">
              <h3 class="scenes-title">Quick Scenes</h3>
              <div class="scenes-grid">
                <button class="scene-btn" @click="$store.lights.applyScene('movie')">
                  <span class="scene-icon">üé¨</span>
                  <span class="scene-name">Movie</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('work')">
                  <span class="scene-icon">üíº</span>
                  <span class="scene-name">Work</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('evening')">
                  <span class="scene-icon">üåÜ</span>
                  <span class="scene-name">Evening</span>
                </button>
                <button class="scene-btn" @click="$store.lights.applyScene('goodnight')">
                  <span class="scene-icon">üò¥</span>
                  <span class="scene-name">Goodnight</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 10: Heater Control -->
        <div x-show="currentView === 'heater'" x-cloak x-data="thermostatView()">
          <div class="thermostat-view">
            <!-- Compact Header: Title + Stats + Tabs in one line -->
            <div class="thermostat-compact-header">
              <h2>Heater</h2>
              <div class="compact-stats">
                <span class="compact-stat heating">üî•<span x-text="activeHeatingCount"></span></span>
                <span class="compact-stat idle">‚ùÑÔ∏è<span x-text="thermostats.length - activeHeatingCount"></span></span>
                <span class="compact-stat cycles">üìä<span x-text="stats.heatingCycles"></span></span>
                <span class="compact-stat offline" x-show="offlineCount > 0">üì°<span x-text="offlineCount"></span></span>
              </div>
              <div class="compact-tabs">
                <button class="tab-btn-sm" :class="{ active: activeTab === 'overview' }" @click="setTab('overview')">Overview</button>
                <button class="tab-btn-sm" :class="{ active: activeTab === 'timeline' }" @click="setTab('timeline')">Timeline</button>
                <button class="tab-btn-sm" :class="{ active: activeTab === 'trends' }" @click="setTab('trends')">Trends</button>
                <button class="tab-btn-sm" :class="{ active: activeTab === 'efficiency' }" @click="setTab('efficiency')">Efficiency</button>
              </div>
            </div>

            <!-- ========================================
                 OVERVIEW TAB
                 ======================================== -->
            <div x-show="activeTab === 'overview'">

              <!-- Thermostat Cards Grid -->
              <div class="thermostats-grid">
                <template x-for="t in thermostats" :key="t.id">
                  <div class="thermostat-card"
                       :class="{
                         heating: t.runningState === 'heat' && t.systemMode !== 'off',
                         off: t.systemMode === 'off',
                         unavailable: !t.available,
                         syncing: t.syncing,
                         'left-network': t.leftNetwork
                       }">

                    <!-- Offline/Left Network Overlay -->
                    <div class="offline-overlay" x-show="!t.available || t.leftNetwork" x-cloak>
                      <div class="offline-content">
                        <span class="offline-icon" x-text="t.leftNetwork ? 'üö®' : 'üì°'"></span>
                        <span class="offline-text" x-text="t.leftNetwork ? 'DEVICE LEFT NETWORK' : 'DEVICE OFFLINE'"></span>
                        <span class="offline-action" x-show="t.leftNetwork">Needs re-pairing</span>
                        <span class="offline-since" x-show="t.leftAt" x-text="getOfflineDuration(t)"></span>
                      </div>
                    </div>

                    <!-- Card Header -->
                    <div class="thermostat-card-header">
                      <div class="thermostat-info">
                        <span class="thermostat-icon" x-text="t.icon"></span>
                        <div>
                          <div class="thermostat-name" x-text="t.name"></div>
                        </div>
                      </div>
                      <div class="status-badge"
                           :class="{
                             heating: t.runningState === 'heat' && t.systemMode !== 'off',
                             idle: t.runningState !== 'heat' && t.systemMode !== 'off' && t.available,
                             off: t.systemMode === 'off',
                             offline: !t.available
                           }">
                        <span class="status-icon" :class="{ 'heating-glow': t.runningState === 'heat' }"
                              x-text="getStatusIcon(t)"></span>
                        <span x-text="getStatusText(t)"></span>
                      </div>
                    </div>

                    <!-- Stacked Neumorphic Temperature Display -->
                    <div class="temp-stack" x-data="{ holdInterval: null, holdDelay: null }">
                      <div class="now-container">
                        <span class="now-label">NOW</span>
                        <span class="now-temp"><span x-text="tempParts(t.localTemp).whole"></span><span class="temp-degree">¬∞</span><span class="temp-decimal" x-text="tempParts(t.localTemp).decimal"></span></span>
                      </div>

                      <!-- Temperature Progress Bar -->
                      <div class="temp-progress-container">
                        <div class="temp-progress-labels">
                          <span class="temp-progress-status" x-text="getTempProgressLabel(t)"></span>
                          <span class="temp-progress-percent" x-text="getTempProgressPercent(t) + '%'"></span>
                        </div>
                        <div class="temp-progress-track">
                          <div class="temp-progress-fill"
                               :style="{ width: getTempProgressPercent(t) + '%', background: getTempProgressColor(t) }"></div>
                        </div>
                      </div>

                      <div class="target-container" :class="{ syncing: t.syncing, heating: t.runningState === 'heat' }">
                        <span class="target-label">TARGET</span>
                        <div class="target-row">
                          <button class="ctrl-btn"
                                  @mousedown="holdDelay = setTimeout(() => { adjustTemp(t.id, -1); holdInterval = setInterval(() => adjustTemp(t.id, -1), 150) }, 300)"
                                  @mouseup="clearTimeout(holdDelay); clearInterval(holdInterval)"
                                  @mouseleave="clearTimeout(holdDelay); clearInterval(holdInterval)"
                                  @touchstart.prevent="holdDelay = setTimeout(() => { adjustTemp(t.id, -1); holdInterval = setInterval(() => adjustTemp(t.id, -1), 150) }, 300)"
                                  @touchend="clearTimeout(holdDelay); clearInterval(holdInterval)"
                                  @click="if(!holdInterval) adjustTemp(t.id, -1)"
                                  :disabled="!t.available || t.syncing || (getDisplayTemp(t) || 17) <= 5">‚àí</button>
                          <span class="target-temp"><span x-text="tempParts(getDisplayTemp(t) || 17).whole"></span><span class="temp-degree">¬∞</span><span class="temp-decimal" x-text="tempParts(getDisplayTemp(t) || 17).decimal"></span></span>
                          <button class="ctrl-btn"
                                  @mousedown="holdDelay = setTimeout(() => { adjustTemp(t.id, 1); holdInterval = setInterval(() => adjustTemp(t.id, 1), 150) }, 300)"
                                  @mouseup="clearTimeout(holdDelay); clearInterval(holdInterval)"
                                  @mouseleave="clearTimeout(holdDelay); clearInterval(holdInterval)"
                                  @touchstart.prevent="holdDelay = setTimeout(() => { adjustTemp(t.id, 1); holdInterval = setInterval(() => adjustTemp(t.id, 1), 150) }, 300)"
                                  @touchend="clearTimeout(holdDelay); clearInterval(holdInterval)"
                                  @click="if(!holdInterval) adjustTemp(t.id, 1)"
                                  :disabled="!t.available || t.syncing || (getDisplayTemp(t) || 17) >= 22">+</button>
                        </div>
                      </div>
                    </div>

                    <!-- Mode Buttons -->
                    <div class="mode-buttons">
                      <button class="mode-btn heat"
                              :class="{ active: t.systemMode === 'heat' }"
                              @click="setMode(t.id, 'heat')"
                              :disabled="!t.available || t.syncing">
                        üî• Heat
                      </button>
                      <button class="mode-btn off"
                              :class="{ active: t.systemMode === 'off' }"
                              @click="setMode(t.id, 'off')"
                              :disabled="!t.available || t.syncing">
                        ‚èª Off
                      </button>
                    </div>

                    <!-- Heater Stats (Professional) -->
                    <div class="heater-stats">
                      <div class="stats-row">
                        <span class="stats-value" x-text="getLastCycleText(t)"></span>
                        <span class="stats-value secondary" x-text="getCycleCount(t) + ' cycles'"></span>
                      </div>
                      <div class="stats-row">
                        <span class="stats-value secondary" x-text="getTotalTime(t) + ' total'"></span>
                        <span class="stats-value secondary" x-show="getAvgTime(t)" x-text="getAvgTime(t) + ' avg'"></span>
                      </div>
                    </div>

                    <!-- Card Meta -->
                    <div class="thermostat-meta">
                      <div class="meta-item" :class="{ 'low-battery': t.battery !== null && t.battery < 20 }">
                        <span x-text="getBatteryIcon(t.battery)"></span>
                        <span x-text="t.battery !== null ? t.battery + '%' : '--'"></span>
                      </div>
                      <div class="meta-item">
                        <span>üì∂</span>
                        <span x-text="t.linkquality !== null ? t.linkquality : '--'"></span>
                      </div>
                      <div class="meta-item availability-dot">
                        <span class="status-dot" :class="{ 'online': t.available, 'offline': !t.available }"></span>
                      </div>
                    </div>
                  </div>
                </template>
              </div>
            </div>

            <!-- ========================================
                 TIMELINE TAB
                 ======================================== -->
            <div x-show="activeTab === 'timeline'">
              <!-- Time Range Selector -->
              <div class="timeline-time-range">
                <template x-for="preset in timeRangePresets" :key="preset.key">
                  <button class="time-range-btn"
                          :class="{ active: timelineTimeRange === preset.key }"
                          @click="setTimelineTimeRange(preset.key)"
                          x-text="preset.label"></button>
                </template>
              </div>

              <!-- Filters -->
              <div class="timeline-filters">
                <div class="filter-group">
                  <select class="filter-select" x-model="filterRoom">
                    <option value="">All Rooms</option>
                    <template x-for="room in uniqueRooms" :key="room">
                      <option :value="room" x-text="room"></option>
                    </template>
                  </select>
                  <select class="filter-select" x-model="filterEventType">
                    <option value="">All Events</option>
                    <template x-for="type in uniqueEventTypes" :key="type">
                      <option :value="type" x-text="getEventInfo(type).label"></option>
                    </template>
                  </select>
                </div>
                <div class="filter-group">
                  <button class="filter-btn" @click="clearFilters()">Clear Filters</button>
                </div>
              </div>

              <!-- Empty State -->
              <div class="events-empty" x-show="events.length === 0">
                <div class="events-empty-icon">üìã</div>
                <p>No events recorded yet</p>
                <p style="font-size: var(--font-size-sm)">Events will appear here as thermostats change state</p>
              </div>

              <!-- Alerts & Warnings -->
              <div class="alerts-section" x-show="alertsAndWarnings.length > 0">
                <div class="section-header">
                  <span class="section-title">üö® Alerts & Warnings</span>
                  <span class="section-count" :class="{ 'alert-badge': hasActiveAlerts }" x-text="alertsAndWarnings.length"></span>
                </div>
                <div class="alerts-list">
                  <template x-for="event in alertsAndWarnings" :key="event.time + event.eventType">
                    <div class="alert-card" :class="{ warning: event.info.priority === 'warning' }">
                      <div class="alert-icon" x-text="event.info.icon"></div>
                      <div class="alert-content">
                        <div class="alert-title" x-text="event.info.label"></div>
                        <div class="alert-device" x-text="event.deviceName"></div>
                        <div class="alert-action" x-show="event.info.action" x-text="event.info.action"></div>
                      </div>
                      <div class="alert-time" x-text="formatRelativeTime(event.time)"></div>
                    </div>
                  </template>
                </div>
              </div>

              <!-- Activity Events (formerly Important) -->
              <div class="events-section" x-show="importantEvents.length > 0">
                <div class="section-header">
                  <span class="section-title">Recent Activity</span>
                  <span class="section-count" x-text="importantEvents.length"></span>
                </div>
                <div class="important-events">
                  <template x-for="event in importantEvents" :key="event.time + event.eventType">
                    <div class="event-card" :style="'border-left-color: ' + event.info.color">
                      <div class="event-card-header">
                        <div class="event-type">
                          <span class="event-icon" x-text="event.info.icon"></span>
                          <span class="event-label" x-text="event.info.label"></span>
                        </div>
                        <div class="event-time">
                          <div class="event-time-absolute" x-text="formatTime(event.time)"></div>
                          <div class="event-time-relative" x-text="formatRelativeTime(event.time)"></div>
                        </div>
                      </div>
                      <div class="event-details">
                        <span class="event-device" x-text="event.deviceIcon + ' ' + event.deviceName"></span>
                        <div class="event-context" x-show="event.currentTemp">
                          Current: <span x-text="formatTemp(event.currentTemp) + '¬∞C'"></span>
                          <span x-show="event.targetTemp"> ‚Üí Target: <span x-text="formatTemp(event.targetTemp) + '¬∞C'"></span></span>
                        </div>
                        <div class="event-context" x-show="event.previousValue !== undefined && event.newValue !== undefined">
                          <span x-text="event.previousValue"></span> ‚Üí <span x-text="event.newValue"></span>
                        </div>
                      </div>
                    </div>
                  </template>
                </div>
              </div>

              <!-- Activity Events -->
              <div class="events-section" x-show="activityEvents.length > 0">
                <div class="section-header">
                  <span class="section-title">Activity</span>
                  <span class="section-count" x-text="activityEvents.length"></span>
                </div>
                <div class="activity-events">
                  <template x-for="event in activityEvents" :key="event.time + event.eventType">
                    <div class="event-row">
                      <span class="event-row-time" x-text="formatTime(event.time)"></span>
                      <span class="event-row-icon" x-text="event.info.icon"></span>
                      <span class="event-row-label" x-text="event.info.label"></span>
                      <span class="event-row-device" x-text="event.deviceName"></span>
                      <span class="event-row-value" x-show="event.previousValue !== undefined"
                            x-text="event.previousValue + ' ‚Üí ' + event.newValue"></span>
                    </div>
                  </template>
                </div>
              </div>

              <!-- Background Events (Collapsed) -->
              <div class="events-section" x-show="backgroundEvents.length > 0">
                <div class="background-toggle" @click="showBackground = !showBackground">
                  <div class="background-toggle-info">
                    <span class="toggle-arrow" :class="{ expanded: showBackground }">‚ñ∂</span>
                    <span>System Events</span>
                    <span class="section-count" x-text="backgroundEvents.length"></span>
                  </div>
                </div>
                <div class="background-events activity-events" x-show="showBackground" x-collapse>
                  <template x-for="event in backgroundEvents" :key="event.time + event.eventType">
                    <div class="event-row">
                      <span class="event-row-time" x-text="formatTime(event.time)"></span>
                      <span class="event-row-icon" x-text="event.info.icon"></span>
                      <span class="event-row-label" x-text="event.info.label"></span>
                      <span class="event-row-device" x-text="event.deviceName"></span>
                    </div>
                  </template>
                </div>
              </div>
            </div>

            <!-- ========================================
                 TRENDS TAB
                 ======================================== -->
            <div x-show="activeTab === 'trends'">
              <!-- Time Range Selector -->
              <div class="time-range-selector">
                <template x-for="range in ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d']" :key="range">
                  <button class="range-btn" :class="{ active: timeRange === range }" @click="setTimeRange(range)" x-text="range"></button>
                </template>
              </div>

              <!-- Loading State -->
              <div class="loading-overlay" x-show="loading">
                <div class="loading-spinner"></div>
                <span class="loading-text">Loading historical data...</span>
              </div>

              <!-- Trends Grid -->
              <div class="trends-grid" x-show="!loading">
                <template x-for="t in thermostats" :key="t.id">
                  <div class="trend-card">
                    <div class="trend-header">
                      <div class="trend-title">
                        <span x-text="t.icon"></span>
                        <span x-text="t.name"></span>
                      </div>
                      <div class="trend-current">
                        <span x-text="formatTemp(t.localTemp) + '¬∞C'"></span>
                      </div>
                    </div>
                    <div class="chart-container" :id="'chart-' + t.id"></div>
                    <div class="trend-legend">
                      <div class="legend-item">
                        <div class="legend-color temp"></div>
                        <span>TEMPERATURE</span>
                      </div>
                      <div class="legend-item">
                        <div class="legend-color target"></div>
                        <span>TARGET</span>
                      </div>
                    </div>
                  </div>
                </template>
              </div>
            </div>

            <!-- ========================================
                 EFFICIENCY TAB
                 ======================================== -->
            <div x-show="activeTab === 'efficiency'">
              <!-- Per-Device Efficiency -->
              <div class="efficiency-grid">
                <template x-for="t in thermostats" :key="t.id">
                  <div class="efficiency-card">
                    <div class="efficiency-header">
                      <span class="efficiency-icon" x-text="t.icon"></span>
                      <span class="efficiency-name" x-text="t.name"></span>
                    </div>
                    <div class="efficiency-stats" x-data="{ stats: getDeviceStats(t.id) }">
                      <div class="efficiency-stat">
                        <span class="efficiency-stat-label">Cycles</span>
                        <span class="efficiency-stat-value" x-text="stats.heatingCycles"></span>
                      </div>
                      <div class="efficiency-stat">
                        <span class="efficiency-stat-label">Heating Time</span>
                        <span class="efficiency-stat-value" x-text="formatDuration(stats.heatingMinutes)"></span>
                      </div>
                      <div class="efficiency-stat">
                        <span class="efficiency-stat-label">Setpoint Changes</span>
                        <span class="efficiency-stat-value" x-text="stats.setpointChanges"></span>
                      </div>
                      <div class="efficiency-stat">
                        <span class="efficiency-stat-label">Targets Reached</span>
                        <span class="efficiency-stat-value" x-text="stats.targetReached"></span>
                      </div>
                    </div>
                  </div>
                </template>
              </div>

              <!-- Comparison Card -->
              <div class="comparison-card" x-data="{ comp: getComparisonStats() }">
                <div class="comparison-title">Today vs Yesterday</div>
                <div class="comparison-rows">
                  <div class="comparison-row">
                    <span class="comparison-label">Heating Cycles</span>
                    <span class="comparison-value" x-text="comp.today.heatingCycles"></span>
                    <span class="comparison-value" x-text="comp.yesterday.heatingCycles"></span>
                    <span class="comparison-delta"
                          :class="{
                            positive: comp.today.heatingCycles < comp.yesterday.heatingCycles,
                            negative: comp.today.heatingCycles > comp.yesterday.heatingCycles
                          }"
                          x-text="(comp.today.heatingCycles - comp.yesterday.heatingCycles > 0 ? '+' : '') + (comp.today.heatingCycles - comp.yesterday.heatingCycles)"></span>
                  </div>
                  <div class="comparison-row">
                    <span class="comparison-label">Setpoint Changes</span>
                    <span class="comparison-value" x-text="comp.today.setpointChanges"></span>
                    <span class="comparison-value" x-text="comp.yesterday.setpointChanges"></span>
                    <span class="comparison-delta"
                          :class="{
                            positive: comp.today.setpointChanges < comp.yesterday.setpointChanges,
                            negative: comp.today.setpointChanges > comp.yesterday.setpointChanges
                          }"
                          x-text="(comp.today.setpointChanges - comp.yesterday.setpointChanges > 0 ? '+' : '') + (comp.today.setpointChanges - comp.yesterday.setpointChanges)"></span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Activity Logs View -->
        <div x-show="currentView === 'logs'" x-cloak x-data="logsView()" x-init="init()">
          <div class="logs-view">
            <!-- Filter Sidebar -->
            <div class="logs-sidebar" x-show="showFilters">
              <!-- Time Range -->
              <div class="logs-sidebar-section">
                <div class="logs-sidebar-title">Time Range</div>
                <div class="logs-time-range">
                  <button class="logs-time-btn" :class="{ active: timeRange === 'live' }" @click="setTimeRange('live')">Live</button>
                  <button class="logs-time-btn" :class="{ active: timeRange === '1h' }" @click="setTimeRange('1h')">1h</button>
                  <button class="logs-time-btn" :class="{ active: timeRange === '6h' }" @click="setTimeRange('6h')">6h</button>
                  <button class="logs-time-btn" :class="{ active: timeRange === '24h' }" @click="setTimeRange('24h')">24h</button>
                </div>
              </div>

              <!-- Categories -->
              <div class="logs-sidebar-section">
                <div class="logs-sidebar-title">Categories</div>
                <div class="logs-category-list">
                  <template x-for="(info, key) in categories" :key="key">
                    <div class="logs-category-item"
                         :class="{ inactive: filters.categories.length > 0 && !filters.categories.includes(key) }"
                         @click="toggleCategory(key)">
                      <span class="logs-category-icon" x-text="info.icon"></span>
                      <span class="logs-category-label" x-text="info.label"></span>
                      <span class="logs-category-count" x-text="stats.byCategory[key] || 0"></span>
                    </div>
                  </template>
                </div>
              </div>

              <!-- Severity -->
              <div class="logs-sidebar-section">
                <div class="logs-sidebar-title">Severity</div>
                <div class="logs-severity-list">
                  <button class="logs-severity-btn error" :class="{ active: filters.severities.includes('error') }" @click="toggleSeverity('error')">Errors</button>
                  <button class="logs-severity-btn warning" :class="{ active: filters.severities.includes('warning') }" @click="toggleSeverity('warning')">Warnings</button>
                </div>
              </div>

              <!-- Quick Presets -->
              <div class="logs-sidebar-section">
                <div class="logs-sidebar-title">Quick Filters</div>
                <div class="logs-presets">
                  <button class="logs-preset-btn" @click="applyPreset('errors')">Errors Only</button>
                  <button class="logs-preset-btn" @click="applyPreset('doors')">Doors</button>
                  <button class="logs-preset-btn" @click="applyPreset('heating')">Heating</button>
                  <button class="logs-preset-btn" @click="applyPreset('anomalies')">Anomalies</button>
                  <button class="logs-preset-btn" @click="clearFilters()">Clear All</button>
                </div>
              </div>

              <!-- Device Filter -->
              <div class="logs-sidebar-section">
                <div class="logs-sidebar-title">Device</div>
                <select class="logs-device-select" @change="setDevice($event.target.value)">
                  <option value="">All Devices</option>
                  <template x-for="device in availableDevices" :key="device">
                    <option :value="device" x-text="device"></option>
                  </template>
                </select>
              </div>
            </div>

            <!-- Main Content -->
            <div class="logs-main">
              <!-- Header -->
              <div class="logs-header">
                <h2 class="logs-title">Activity Logs</h2>
                <div class="logs-search">
                  <input type="text" class="logs-search-input" placeholder="Search logs..."
                         x-model="searchQuery" @input="onSearchInput()">
                </div>
                <div class="logs-controls">
                  <button class="logs-control-btn" :class="{ active: isPaused }" @click="togglePause()">
                    <span x-text="isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'"></span>
                  </button>
                  <button class="logs-control-btn" @click="showFilters = !showFilters">
                    <span x-text="showFilters ? '‚óÄÔ∏è Hide Filters' : '‚ñ∂Ô∏è Filters'"></span>
                  </button>
                  <button class="logs-control-btn" @click="showStats = !showStats">
                    <span>üìä Stats</span>
                  </button>
                  <button class="logs-control-btn danger" @click="clearLogs()">
                    <span>üóëÔ∏è Clear</span>
                  </button>
                </div>
              </div>

              <!-- Statistics Panel -->
              <div class="logs-stats" x-show="showStats" x-collapse>
                <div class="logs-stat-card">
                  <div class="logs-stat-value" x-text="stats.total"></div>
                  <div class="logs-stat-label">Total Events</div>
                </div>
                <div class="logs-stat-card">
                  <div class="logs-stat-value" x-text="stats.lastHour"></div>
                  <div class="logs-stat-label">Last Hour</div>
                </div>
                <div class="logs-stat-card">
                  <div class="logs-stat-value error" x-text="stats.errors"></div>
                  <div class="logs-stat-label">Errors</div>
                </div>
                <div class="logs-stat-card">
                  <div class="logs-stat-value warning" x-text="stats.warnings"></div>
                  <div class="logs-stat-label">Warnings</div>
                </div>
                <div class="logs-stat-card">
                  <div class="logs-stat-value" x-text="stats.anomalies"></div>
                  <div class="logs-stat-label">Anomalies</div>
                </div>
                <div class="logs-stat-card">
                  <div class="logs-sidebar-title">Messages/Hour</div>
                  <div class="logs-sparkline">
                    <template x-for="(val, idx) in getHourlySparkline()" :key="idx">
                      <div class="logs-sparkline-bar" :style="{ height: val + '%' }"></div>
                    </template>
                  </div>
                </div>
              </div>

              <!-- Log Entries List -->
              <div class="logs-list">
                <div class="logs-list-header">
                  <span class="logs-count" x-text="'Showing ' + logs.length + ' of ' + totalLogs + ' entries'"></span>
                  <span x-show="isLoading" class="logs-loading">Loading...</span>
                </div>

                <div class="logs-entries" x-show="logs.length > 0">
                  <template x-for="log in logs" :key="log.id">
                    <div class="log-entry"
                         :class="{ anomaly: log.isAnomaly, expanded: isExpanded(log.id) }"
                         @click="expandLog(log.id)">

                      <!-- Compact View -->
                      <template x-if="!isExpanded(log.id)">
                        <div class="log-entry-header" style="display: contents;">
                          <span class="log-entry-icon" x-text="getCategoryInfo(log.category).icon"></span>
                          <span class="log-entry-time" x-text="formatTime(log.timestamp)"></span>
                          <span class="log-entry-device" x-text="log.device"></span>
                          <span class="log-entry-values" x-text="formatValues(log.values)"></span>
                          <span class="log-entry-severity" :class="log.severity" x-show="log.severity !== 'info'" x-text="log.severity"></span>
                          <span class="log-entry-anomaly-badge" x-show="log.isAnomaly">‚ö†Ô∏è</span>
                        </div>
                      </template>

                      <!-- Expanded View -->
                      <template x-if="isExpanded(log.id)">
                        <div class="log-entry-expanded">
                          <div class="log-entry-header">
                            <span class="log-entry-icon" x-text="getCategoryInfo(log.category).icon"></span>
                            <span class="log-entry-time" x-text="formatTime(log.timestamp)"></span>
                            <span class="log-entry-device" x-text="log.device"></span>
                            <span class="log-entry-severity" :class="log.severity" x-text="log.severity"></span>
                          </div>

                          <div class="log-entry-details">
                            <div class="log-entry-detail">
                              <span class="log-entry-detail-label">Category</span>
                              <span class="log-entry-detail-value" x-text="getCategoryInfo(log.category).label"></span>
                            </div>
                            <div class="log-entry-detail">
                              <span class="log-entry-detail-label">Event Type</span>
                              <span class="log-entry-detail-value" x-text="log.eventType"></span>
                            </div>
                            <div class="log-entry-detail">
                              <span class="log-entry-detail-label">Room</span>
                              <span class="log-entry-detail-value" x-text="log.roomId"></span>
                            </div>
                            <div class="log-entry-detail">
                              <span class="log-entry-detail-label">Source</span>
                              <span class="log-entry-detail-value" x-text="log.source"></span>
                            </div>
                            <div class="log-entry-detail">
                              <span class="log-entry-detail-label">Values</span>
                              <span class="log-entry-detail-value" x-text="formatValues(log.values)"></span>
                            </div>
                            <div class="log-entry-detail" x-show="log.topic">
                              <span class="log-entry-detail-label">Topic</span>
                              <span class="log-entry-detail-value" x-text="log.topic" style="font-size: 0.7rem;"></span>
                            </div>
                          </div>

                          <!-- TTS-specific section -->
                          <div class="log-entry-tts" x-show="log.category === 'tts'" style="margin-top: var(--space-sm); padding: var(--space-sm); background: var(--color-bg); border-radius: var(--radius-sm);">
                            <div class="logs-sidebar-title">üîä TTS Notification Details</div>
                            <div style="margin-top: var(--space-xs);">
                              <div style="font-weight: 500; margin-bottom: var(--space-xs);">Message:</div>
                              <div style="font-style: italic; padding: var(--space-xs); background: var(--color-surface); border-radius: var(--radius-sm); font-size: 0.85rem;" x-text="log.ttsMessage || 'No message'"></div>
                            </div>
                            <div style="margin-top: var(--space-sm);">
                              <div style="font-weight: 500; margin-bottom: var(--space-xs);">Target Devices:</div>
                              <template x-for="device in (log.ttsDevices || [])" :key="device.device">
                                <div style="display: flex; align-items: center; gap: var(--space-xs); padding: 2px 0; font-size: 0.85rem;">
                                  <span x-text="device.available ? '‚úÖ' : '‚ùå'"></span>
                                  <span x-text="device.device"></span>
                                  <span style="color: var(--color-text-tertiary);" x-text="device.available ? '(available)' : '(unavailable)'"></span>
                                </div>
                              </template>
                            </div>
                            <div style="margin-top: var(--space-sm); padding-top: var(--space-sm); border-top: 1px solid var(--color-border);">
                              <span :style="{ color: log.ttsSuccess ? '#22c55e' : '#ef4444', fontWeight: 500 }" x-text="log.ttsSuccess ? '‚úÖ TTS sent successfully' : '‚ùå TTS failed - no available devices'"></span>
                            </div>
                          </div>

                          <div class="log-entry-payload" x-show="log.payload && log.category !== 'tts'">
                            <div class="logs-sidebar-title">Raw Payload</div>
                            <pre x-text="formatPayload(log.payload)"></pre>
                          </div>

                          <div class="log-entry-actions">
                            <button class="log-entry-action-btn" @click.stop="copyPayload(log)">üìã Copy Payload</button>
                          </div>
                        </div>
                      </template>
                    </div>
                  </template>

                  <!-- Load More -->
                  <div class="logs-load-more" x-show="hasMore">
                    <button class="logs-load-more-btn" @click="loadMore()">
                      Load More (<span x-text="totalLogs - visibleCount"></span> remaining)
                    </button>
                  </div>
                </div>

                <!-- Empty State -->
                <div class="logs-empty" x-show="logs.length === 0 && !isLoading">
                  <div class="logs-empty-icon">üìã</div>
                  <div class="logs-empty-text">No logs yet. Messages will appear here as they arrive.</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Vision 10: CO2 Monitor -->
        <div x-show="currentView === 'co2'" x-cloak x-data="co2View()" x-init="init()">
          <div class="co2-view">

            <!-- Giant Circular Gauge -->
            <div class="co2-gauge-section">
              <div class="co2-gauge-header">AIR QUALITY</div>
              <div class="co2-gauge">
                <svg viewBox="0 0 200 200" class="co2-gauge-ring">
                  <circle cx="100" cy="100" r="90" class="co2-gauge-bg"/>
                  <circle cx="100" cy="100" r="90"
                          class="co2-gauge-arc"
                          :class="{ pulse: !isStale }"
                          :stroke="co2Color"
                          :stroke-dasharray="gaugeArc"
                          transform="rotate(-90 100 100)"/>
                </svg>
                <div class="co2-gauge-content">
                  <span class="co2-value" :style="{ color: co2Color }" x-text="co2Value ?? '--'"></span>
                  <span class="co2-unit">ppm</span>
                  <span class="co2-status" :style="{ color: co2Color }" x-text="airQualityLevel"></span>
                  <div class="co2-trend" :class="trendDirection" x-show="trendDirection !== 'stable'">
                    <span class="co2-trend-arrow" x-text="trendArrow"></span>
                    <span x-text="trendValue + ' ppm'"></span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Air Quality Dashboard (3 Cards) -->
            <div class="air-quality-dashboard">
              <!-- CO2 Card -->
              <div class="air-quality-card highlight">
                <div class="air-quality-icon">üí®</div>
                <div class="air-quality-label">CO2</div>
                <div class="air-quality-value" :style="{ color: co2Color }" x-text="(co2Value ?? '--') + ' ppm'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: co2Percent + '%', background: co2Color }"></div>
                </div>
                <div class="air-quality-status" x-text="airQualityLevel"></div>
              </div>

              <!-- Temperature Card -->
              <div class="air-quality-card">
                <div class="air-quality-icon">üå°Ô∏è</div>
                <div class="air-quality-label">Temperature</div>
                <div class="air-quality-value" :style="{ color: tempColor }" x-text="temperature !== null ? temperature.toFixed(1) + '¬∞C' : '--'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: tempPercent + '%', background: tempColor }"></div>
                </div>
                <div class="air-quality-status" x-text="tempLevel"></div>
              </div>

              <!-- Humidity Card -->
              <div class="air-quality-card">
                <div class="air-quality-icon">üíß</div>
                <div class="air-quality-label">Humidity</div>
                <div class="air-quality-value" :style="{ color: humidityColor }" x-text="humidity !== null ? Math.round(humidity) + '%' : '--'"></div>
                <div class="air-quality-bar">
                  <div class="air-quality-fill" :style="{ width: humidityPercent + '%', background: humidityColor }"></div>
                </div>
                <div class="air-quality-status" x-text="humidityLevel"></div>
              </div>
            </div>

            <!-- History Chart -->
            <div class="co2-chart-section">
              <div class="chart-header">
                <div class="chart-title">CO2 History</div>
                <div class="time-range-selector">
                  <template x-for="range in timeRanges" :key="range">
                    <button class="time-range-btn"
                            :class="{ active: timeRange === range }"
                            @click="setTimeRange(range)"
                            x-text="range"></button>
                  </template>
                </div>
              </div>

              <div class="co2-chart-container">
                <div class="chart-loading" x-show="loading">
                  <span class="loading-indicator"></span>
                  Loading history...
                </div>
                <div class="chart-no-data" x-show="!loading && co2History.length === 0">
                  No data in this time range
                </div>
                <svg id="co2-history-chart" class="co2-chart" x-show="!loading && co2History.length > 0"></svg>
              </div>

              <!-- Chart Stats -->
              <div class="chart-stats" x-show="co2History.length > 0">
                <div class="chart-stat">
                  <div class="chart-stat-label">Min</div>
                  <div class="chart-stat-value" x-text="minMax.min + ' ppm'"></div>
                </div>
                <div class="chart-stat">
                  <div class="chart-stat-label">Avg</div>
                  <div class="chart-stat-value" x-text="avgCo2 + ' ppm'"></div>
                </div>
                <div class="chart-stat">
                  <div class="chart-stat-label">Max</div>
                  <div class="chart-stat-value" x-text="minMax.max + ' ppm'"></div>
                </div>
              </div>
            </div>

            <!-- Legend -->
            <div class="co2-legend">
              <div class="legend-item">
                <div class="legend-dot" style="background: #34C759;"></div>
                <span>Excellent (&lt;600)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #30D158;"></div>
                <span>Good (600-1000)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FFD60A;"></div>
                <span>Moderate (1000-1500)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FF9500;"></div>
                <span>Poor (1500-2000)</span>
              </div>
              <div class="legend-item">
                <div class="legend-dot" style="background: #FF3B30;"></div>
                <span>Bad (&gt;2000)</span>
              </div>
            </div>

            <!-- Footer -->
            <div class="co2-footer">
              <div class="co2-footer-item" :class="{ 'stale-indicator': isStale }">
                <span x-text="isStale ? '‚ö†Ô∏è' : '‚úì'"></span>
                <span x-text="'Last update: ' + formatLastUpdate()"></span>
              </div>
              <div class="co2-footer-item">
                <span>üìç</span>
                <span x-text="sensorRoom"></span>
              </div>
              <div class="co2-footer-item" x-show="co2History.length > 0">
                <span>üìä</span>
                <span x-text="co2History.length + ' readings'"></span>
              </div>
            </div>

            <!-- Ambient Mode Toggle Button -->
            <button class="ambient-toggle" @click="toggleAmbient()">
              üåô Ambient Mode
            </button>

            <!-- Ambient Mode Overlay -->
            <div class="co2-ambient-overlay" :class="{ hidden: !ambientMode }" @click="ambientMode = false">
              <div class="ambient-co2-value" :style="{ color: co2Color }" x-text="co2Value ?? '--'"></div>
              <div class="ambient-co2-unit">ppm</div>
              <div class="ambient-status" :style="{ color: co2Color }" x-text="airQualityLevel"></div>
              <div class="ambient-trend" x-text="trendArrow"></div>
              <div class="ambient-room" x-text="sensorRoom"></div>
              <div class="ambient-hint">Tap anywhere to exit</div>
            </div>

          </div>
        </div>

        <!-- Zigbee Network View -->
        <div x-show="currentView === 'network'" x-cloak x-data="networkView()" x-init="init()">
          <div class="network-view">
            <!-- Controls -->
            <div class="network-controls">
              <button class="network-control-btn" :class="{ active: showSignalRange }"
                      @click="showSignalRange = !showSignalRange">
                üì∂ <span x-text="showSignalRange ? 'Hide Range' : 'Show Range'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: showLabels }"
                      @click="showLabels = !showLabels">
                üè∑Ô∏è <span x-text="showLabels ? 'Hide Labels' : 'Show Labels'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: autoRotate }"
                      @click="toggleAutoRotate()">
                üîÑ <span x-text="autoRotate ? 'Stop' : 'Rotate'"></span>
              </button>
              <button class="network-control-btn" :class="{ active: showWallNumbers }"
                      @click="toggleWallNumbers()">
                üî¢ <span x-text="showWallNumbers ? 'Hide #' : 'Show #'"></span>
              </button>
              <button class="network-control-btn" @click="resetView()">
                üéØ Reset
              </button>
              <div class="network-zoom-controls">
                <button class="network-control-btn network-zoom-btn" @click="zoomOut()">‚ûñ</button>
                <span class="network-zoom-indicator" x-text="getZoomPercent() + '%'"></span>
                <button class="network-control-btn network-zoom-btn" @click="zoomIn()">‚ûï</button>
              </div>
            </div>

            <!-- Network Canvas Container -->
            <div class="network-container" x-ref="networkContainer"></div>

            <!-- Legend -->
            <div class="network-legend">
              <div class="legend-item">
                <div class="legend-badge coordinator">Z</div>
                <span>Zigbee Coordinator</span>
              </div>
              <div class="legend-item">
                <div class="legend-badge router">R</div>
                <span>Zigbee Router</span>
              </div>
              <div class="legend-item">
                <div class="legend-badge end-device">E</div>
                <span>Zigbee End Device</span>
              </div>
            </div>

            <!-- Stats -->
            <div class="network-stats">
              <div class="network-stat">
                <span>üì°</span>
                <span x-text="deviceCount + ' devices'"></span>
              </div>
              <div class="network-stat">
                <span>üîó</span>
                <span x-text="routerCount + ' routers'"></span>
              </div>
              <div class="network-stat">
                <span>üìç</span>
                <span x-text="endDeviceCount + ' end devices'"></span>
              </div>
            </div>
          </div>
        </div>

        <!-- Mailbox Monitor View -->
        <div x-show="currentView === 'mailbox'" x-cloak x-data="mailboxView()">
          <div class="mailbox-view">

            <!-- Hero Section - Last Delivery -->
            <div class="mailbox-hero" :class="{ 'has-mail': hasMailToday, 'no-mail': !hasMailToday }">
              <div class="mailbox-hero-icon">üì¨</div>
              <template x-if="lastDelivery">
                <div>
                  <div class="mailbox-hero-status" x-text="hasMailToday ? 'Mail Arrived!' : 'No Mail Today'"></div>
                  <div class="mailbox-hero-time" x-text="formatDateTime(lastDelivery.time)"></div>
                  <div class="mailbox-hero-relative" x-text="formatRelativeTime(lastDelivery.time)"></div>
                </div>
              </template>
              <template x-if="!lastDelivery">
                <div>
                  <div class="mailbox-hero-status">No Mail Activity</div>
                  <div class="mailbox-hero-time">Waiting for first delivery...</div>
                </div>
              </template>
            </div>

            <!-- Statistics Grid -->
            <div class="mailbox-stats">
              <div class="mailbox-stat-card">
                <div class="mailbox-stat-icon">üì¨</div>
                <div class="mailbox-stat-value" x-text="stats.todayCount"></div>
                <div class="mailbox-stat-label">Today</div>
              </div>
              <div class="mailbox-stat-card">
                <div class="mailbox-stat-icon">üìÖ</div>
                <div class="mailbox-stat-value" x-text="stats.weekCount"></div>
                <div class="mailbox-stat-label">This Week</div>
              </div>
              <div class="mailbox-stat-card">
                <div class="mailbox-stat-icon">‚è∞</div>
                <div class="mailbox-stat-value" x-text="stats.avgDeliveryTime"></div>
                <div class="mailbox-stat-label">Avg. Time</div>
              </div>
              <div class="mailbox-stat-card">
                <div class="mailbox-stat-icon">üìä</div>
                <div class="mailbox-stat-value" x-text="stats.totalCount"></div>
                <div class="mailbox-stat-label">All Time</div>
              </div>
            </div>

            <!-- Two Column Row: Signal Health + Pattern Chart -->
            <div class="mailbox-row">
              <!-- Signal Health Card -->
              <div class="signal-health-card">
                <div class="signal-health-header">
                  <h3 class="signal-health-title">üì° Signal Health</h3>
                  <div class="signal-health-badge" :class="signalHealth.status">
                    <span x-text="signalHealth.status === 'healthy' ? '‚úì' : signalHealth.status === 'warning' ? '‚ö†' : signalHealth.status === 'critical' ? '‚úï' : '?'"></span>
                    <span x-text="signalHealth.label"></span>
                  </div>
                </div>
                <div class="signal-health-bar">
                  <div class="signal-health-bar-fill"
                       :class="{ warning: signalHealth.uptimePercent < 70, critical: signalHealth.uptimePercent < 40 }"
                       :style="'width: ' + signalHealth.uptimePercent + '%'"></div>
                </div>
                <div class="signal-health-metrics">
                  <div>
                    <div class="signal-metric-value" x-text="formatRelativeTime(signalHealth.lastSeen)"></div>
                    <div class="signal-metric-label">Last Seen</div>
                  </div>
                  <div>
                    <div class="signal-metric-value" x-text="signalHealth.eventCount"></div>
                    <div class="signal-metric-label">Events (24h)</div>
                  </div>
                  <div>
                    <div class="signal-metric-value" x-text="signalHealth.gaps"></div>
                    <div class="signal-metric-label">Gaps</div>
                  </div>
                </div>
              </div>

              <!-- Delivery Pattern Chart -->
              <div class="pattern-chart-section">
                <div class="pattern-chart-header">
                  <h3 class="pattern-chart-title">üìà Patterns</h3>
                  <div class="pattern-view-toggle">
                    <button class="pattern-toggle-btn" :class="{ active: patternMode === 'hourly' }"
                            @click="setPatternMode('hourly')">By Hour</button>
                    <button class="pattern-toggle-btn" :class="{ active: patternMode === 'daily' }"
                            @click="setPatternMode('daily')">By Day</button>
                  </div>
                </div>
                <div class="pattern-chart">
                  <template x-for="bar in patternData" :key="patternMode + '-' + (bar.hour !== undefined ? bar.hour : bar.day)">
                    <div class="pattern-bar-wrapper">
                      <div class="pattern-bar" :class="{ empty: bar.isEmpty }" :style="'height: ' + bar.height + '%'">
                        <div class="pattern-bar-tooltip" x-text="bar.count + ' deliveries'"></div>
                      </div>
                      <div class="pattern-bar-label" x-text="bar.label"></div>
                    </div>
                  </template>
                </div>
              </div>
            </div>

            <!-- Event Timeline -->
            <div class="mailbox-timeline">
              <div class="timeline-header">
                <h3 class="timeline-title">üìã Event History</h3>
                <div class="timeline-date-filter">
                  <button class="timeline-filter-btn" :class="{ active: dateRange === 'today' }"
                          @click="setDateRange('today')">Today</button>
                  <button class="timeline-filter-btn" :class="{ active: dateRange === 'yesterday' }"
                          @click="setDateRange('yesterday')">Yesterday</button>
                  <button class="timeline-filter-btn" :class="{ active: dateRange === 'week' }"
                          @click="setDateRange('week')">Week</button>
                </div>
              </div>

              <!-- Loading State -->
              <template x-if="loading">
                <div class="mailbox-loading">
                  <div class="mailbox-loading-spinner"></div>
                  <span>Loading events...</span>
                </div>
              </template>

              <!-- Empty State -->
              <template x-if="!loading && filteredEvents.length === 0">
                <div class="mailbox-empty">
                  <div class="mailbox-empty-icon">üì≠</div>
                  <div class="mailbox-empty-text">No events found</div>
                  <div class="mailbox-empty-hint">Events will appear here as the mailbox sensor detects activity</div>
                </div>
              </template>

              <!-- Event List -->
              <div class="mailbox-event-list" x-show="!loading && filteredEvents.length > 0">
                <template x-for="event in filteredEvents.slice(0, 50)" :key="event.time + '-' + event.eventType">
                  <div class="mailbox-event">
                    <div class="mailbox-event-icon" :class="getEventClass(event.eventType)">
                      <span x-text="getEventIcon(event.eventType)"></span>
                    </div>
                    <div class="mailbox-event-content">
                      <div class="mailbox-event-title" x-text="getEventLabel(event.eventType)"></div>
                      <div class="mailbox-event-subtitle" x-text="event.deviceName"></div>
                    </div>
                    <div class="mailbox-event-time">
                      <div class="mailbox-event-time-abs" x-text="formatTime(event.time)"></div>
                      <div class="mailbox-event-time-rel" x-text="formatRelativeTime(event.time)"></div>
                    </div>
                  </div>
                </template>
              </div>
            </div>

          </div>
        </div>

      </div>
    </main>

    <!-- Overview Panel (Right Sidebar) -->
    <aside class="overview-panel" :class="{ collapsed: !panelOpen }">
      <div class="panel-content">

        <!-- Section: Home Average -->
        <div class="panel-section panel-section-primary home-section">
          <div class="panel-section-title">HOME</div>
          <!-- Primary: Large temperature -->
          <div class="panel-metric">
            <span class="panel-icon">üè†</span>
            <span class="panel-value temp-primary" x-html="formatTempStyled($store.rooms.avgTemperature)"></span>
          </div>
          <!-- Secondary: Humidity and CO2 on next line with color coding -->
          <div class="panel-secondary-row">
            <div class="panel-metric">
              <span class="panel-icon">üíß</span>
              <span class="panel-value"
                    :class="{
                      'metric-good': $store.rooms.avgHumidity >= 40 && $store.rooms.avgHumidity <= 60,
                      'metric-warning': ($store.rooms.avgHumidity >= 30 && $store.rooms.avgHumidity < 40) || ($store.rooms.avgHumidity > 60 && $store.rooms.avgHumidity <= 70),
                      'metric-bad': $store.rooms.avgHumidity < 30 || $store.rooms.avgHumidity > 70
                    }"
                    x-text="($store.rooms.avgHumidity?.toFixed(0) || '--') + '%'"></span>
            </div>
            <div class="panel-metric" x-show="$store.rooms.co2Value">
              <span class="panel-icon">üí®</span>
              <span class="panel-value"
                    :class="{
                      'metric-good': $store.rooms.co2Value < 800,
                      'metric-warning': $store.rooms.co2Value >= 800 && $store.rooms.co2Value <= 1000,
                      'metric-bad': $store.rooms.co2Value > 1000
                    }"
                    x-text="$store.rooms.co2Value"></span>
            </div>
          </div>
        </div>

        <!-- Section: Outside -->
        <div class="panel-section panel-section-primary outside-section">
          <div class="panel-section-title">OUTSIDE</div>
          <div class="panel-metrics-grid">
            <div class="panel-metric">
              <span class="panel-icon">üåø</span>
              <span class="panel-value" x-html="formatTempStyled($store.rooms.list.find(r => r.id === 'balcony')?.temperature)"></span>
            </div>
            <div class="panel-metric" x-show="$store.weather?.temperature != null">
              <span class="panel-icon" x-text="$store.weather?.conditionIcon || '‚òÅÔ∏è'"></span>
              <span class="panel-value" x-text="($store.weather?.temperature?.toFixed(0) || '--') + '¬∞'"></span>
            </div>
          </div>
        </div>

        <!-- Section: By Room (Floor Plan) -->
        <div class="panel-section panel-section-primary rooms-section">
          <div class="panel-section-title">ROOMS</div>
          <div class="floor-plan-container">
            <svg class="floor-plan-svg" viewBox="0 0 92.39 76.65" preserveAspectRatio="xMidYMid meet">
              <!-- Room fills - Hallway as vertical corridor -->
              <g class="floor-plan-rooms">
                <!-- Right side: Study (top), Living (bottom) -->
                <rect class="floor-room" x="55" y="0" width="37.39" height="40"/>
                <rect class="floor-room" x="45" y="40" width="47.39" height="36.65"/>
                <!-- Left column: Bathroom (top), Kitchen (middle), Bedroom (bottom) -->
                <rect class="floor-room" x="0" y="0" width="35" height="20"/>
                <rect class="floor-room" x="0" y="20" width="35" height="20"/>
                <rect class="floor-room" x="0" y="40" width="45" height="36.65"/>
                <!-- Hallway: vertical corridor between left rooms and right rooms -->
                <rect class="floor-room floor-room-hallway" x="35" y="0" width="20" height="40"/>
              </g>
              <!-- Temperature labels with styled decimals -->
              <g class="floor-plan-labels">
                <!-- Right side - Study (55-92.39, y=0-40), Living (45-92.39, y=40-76.65) -->
                <text class="floor-label" x="74" y="22" :class="getRoomTempClass('study')">
                  <tspan x-text="getRoomTempInt('study')"></tspan><tspan class="floor-decimal" x-text="getRoomTempDec('study')"></tspan>
                </text>
                <text class="floor-label" x="69" y="60" :class="getRoomTempClass('living')">
                  <tspan x-text="getRoomTempInt('living')"></tspan><tspan class="floor-decimal" x-text="getRoomTempDec('living')"></tspan>
                </text>
                <!-- Left column (0-35) - Bathroom (y=0-20), Kitchen (y=20-40), Bedroom (y=40-76.65) -->
                <text class="floor-label floor-label-small" x="17" y="12" :class="getRoomTempClass('bathroom')">
                  <tspan x-text="getRoomTempInt('bathroom')"></tspan><tspan class="floor-decimal" x-text="getRoomTempDec('bathroom')"></tspan>
                </text>
                <text class="floor-label floor-label-small" x="17" y="32" :class="getRoomTempClass('kitchen')">
                  <tspan x-text="getRoomTempInt('kitchen')"></tspan><tspan class="floor-decimal" x-text="getRoomTempDec('kitchen')"></tspan>
                </text>
                <text class="floor-label" x="22" y="60" :class="getRoomTempClass('bedroom')">
                  <tspan x-text="getRoomTempInt('bedroom')"></tspan><tspan class="floor-decimal" x-text="getRoomTempDec('bedroom')"></tspan>
                </text>
                <!-- Hallway (vertical corridor 35-55, y=0-40) -->
                <text class="floor-label" x="45" y="22" :class="getRoomTempClass('hallway')">
                  <tspan style="font-size: 11px" x-text="getRoomTempInt('hallway')"></tspan>
                  <tspan x="45" dy="10" class="floor-decimal" x-text="getRoomTempDec('hallway')"></tspan>
                </text>
              </g>
              <!-- Wall structure -->
              <g class="floor-plan-walls" fill="none">
                <!-- Outer perimeter -->
                <rect class="floor-wall" x="0.5" y="0.5" width="91.39" height="75.65"/>
                <!-- Internal walls -->
                <path class="floor-wall" d="
                  M 55 0 L 55 40
                  M 45 40 L 45 76.65
                  M 35 0 L 35 40
                  M 0 20 L 35 20
                  M 0 40 L 92.39 40
                "/>
              </g>
            </svg>
          </div>
        </div>

        <!-- Section: Heating (icon + title + badge) -->
        <div class="panel-section compact heating-section">
          <div class="panel-section-header">
            <span class="section-icon" x-text="($store.thermostats?.activeHeatingCount || 0) > 0 ? 'üî•' : '‚ùÑÔ∏è'"></span>
            <span class="section-title">Heating</span>
            <span class="status-badge"
                  :class="($store.thermostats?.activeHeatingCount || 0) > 0 ? 'status-heating' : 'status-off'"
                  x-text="($store.thermostats?.activeHeatingCount || 0) > 0 ? $store.thermostats?.activeHeatingCount : 'off'"></span>
          </div>
          <template x-if="($store.thermostats?.activeHeatingCount || 0) > 0">
            <div class="panel-metrics-grid">
              <template x-for="trv in ($store.thermostats?.list || []).filter(t => t.runningState === 'heat')" :key="trv.id">
                <div class="panel-metric heating-active full-width heating-row">
                  <span class="heating-room-name" x-text="trv.name"></span>
                  <span class="heating-temp-value">
                    <span x-text="(trv.localTemp?.toFixed(1) || '--')"></span>
                    <span class="heating-arrow">‚Üí</span>
                    <span x-text="(trv.targetTemp || '--') + '¬∞'"></span>
                  </span>
                </div>
              </template>
            </div>
          </template>
        </div>

        <!-- Section: Doors (lock icon + title + badge) -->
        <div class="panel-section compact doors-section">
          <div class="panel-section-header">
            <span class="section-icon" x-text="getDoorCount() > 0 ? 'üîì' : 'üîí'"></span>
            <span class="section-title">Doors</span>
            <span class="status-badge"
                  :class="getDoorCount() > 0 ? 'status-warning' : 'status-ok'"
                  x-text="getDoorCount() > 0 ? getDoorCount() : '‚úì'"></span>
          </div>
          <template x-if="getDoorCount() > 0">
            <div class="panel-metrics-grid">
              <template x-for="sensor in getOpenDoors()" :key="sensor.ieee_address">
                <div class="panel-metric contact-open full-width">
                  <span class="panel-value">
                    <span x-text="getContactShortName(sensor.friendly_name)"></span>
                    <span class="duration" x-text="$store.sensors.getOpenDuration(sensor.ieee_address) ? '(' + $store.sensors.getOpenDuration(sensor.ieee_address) + ')' : ''"></span>
                  </span>
                </div>
              </template>
            </div>
          </template>
        </div>

        <!-- Section: Windows (lock icon + title + badge) -->
        <div class="panel-section compact windows-section">
          <div class="panel-section-header">
            <span class="section-icon" x-text="getWindowCount() > 0 ? 'üîì' : 'üîí'"></span>
            <span class="section-title">Windows</span>
            <span class="status-badge"
                  :class="getWindowCount() > 0 ? 'status-warning' : 'status-ok'"
                  x-text="getWindowCount() > 0 ? getWindowCount() : '‚úì'"></span>
          </div>
          <template x-if="getWindowCount() > 0">
            <div class="panel-metrics-grid">
              <template x-for="sensor in getOpenWindows()" :key="sensor.ieee_address">
                <div class="panel-metric contact-open full-width">
                  <span class="panel-value">
                    <span x-text="getContactShortName(sensor.friendly_name)"></span>
                    <span class="duration" x-text="$store.sensors.getOpenDuration(sensor.ieee_address) ? '(' + $store.sensors.getOpenDuration(sensor.ieee_address) + ')' : ''"></span>
                  </span>
                </div>
              </template>
            </div>
          </template>
        </div>

      </div>
    </aside>
    </div><!-- /.app-body -->

    <!-- Footer -->
    <footer class="app-footer" x-show="currentView !== 'ambient'">
      <span class="footer-status">
        <span class="loading-indicator" x-show="$store.mqtt.connecting"></span>
        <span class="status-dot" :class="{ 'online': $store.mqtt.connected, 'offline': !$store.mqtt.connected }" x-show="!$store.mqtt.connecting"></span>
      </span>
      <span> ‚Ä¢ </span>
      <span x-show="$store.rooms.loading" class="footer-status">
        <span class="loading-indicator"></span>
        <span>Loading history...</span>
      </span>
      <span x-show="!$store.rooms.loading" x-text="$store.rooms.historyCount + ' data points'"></span>
      <span x-show="$store.lights.syncing"> ‚Ä¢ <span class="loading-indicator"></span> Syncing lights...</span>
    </footer>

    <!-- Room Detail Modal -->
    <template x-if="$store.roomDetail.selectedRoom">
      <div class="modal-overlay" @click.self="$store.roomDetail.close()" @keydown.escape.window="$store.roomDetail.close()">
        <div class="modal">
          <div class="modal-header">
            <div class="modal-title">
              <span class="icon" x-text="$store.roomDetail.selectedRoom.icon"></span>
              <h2 x-text="$store.roomDetail.selectedRoom.name"></h2>
            </div>
            <button class="modal-close" @click="$store.roomDetail.close()">&times;</button>
          </div>
          <div class="modal-body">
            <div class="time-range-selector">
              <template x-for="range in $store.roomDetail.timeRanges" :key="range">
                <button class="btn btn-secondary" :class="{ active: $store.roomDetail.timeRange === range }"
                        @click="$store.roomDetail.setTimeRange(range)" x-text="range"></button>
              </template>
              <span x-show="$store.roomDetail.loading" class="loading-indicator"></span>
            </div>

            <div class="modal-stats">
              <div class="modal-stat">
                <div class="modal-stat-label">Temperature</div>
                <div class="modal-stat-value temp"
                     x-text="$store.roomDetail.selectedRoom.temperature !== null
                       ? $store.roomDetail.selectedRoom.temperature.toFixed(1) + '¬∞C' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Humidity</div>
                <div class="modal-stat-value humid"
                     x-text="$store.roomDetail.selectedRoom.humidity !== null
                       ? $store.roomDetail.selectedRoom.humidity.toFixed(0) + '%' : '--'"></div>
              </div>
              <div class="modal-stat">
                <div class="modal-stat-label">Min / Max</div>
                <div class="modal-stat-value minmax" x-text="$store.roomDetail.getMinMax()"></div>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Temperature History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-temp">
                <template x-if="$store.roomDetail.tempHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-temp" x-show="$store.roomDetail.tempHistory.length > 0"></svg>
              </div>
            </div>

            <div class="modal-chart">
              <div class="modal-chart-title" x-text="'Humidity History (last ' + $store.roomDetail.timeRange + ')'"></div>
              <div class="chart-humid">
                <template x-if="$store.roomDetail.humidHistory.length === 0 && !$store.roomDetail.loading">
                  <div class="no-data-message">No data in this time range</div>
                </template>
                <svg id="modal-chart-humid" x-show="$store.roomDetail.humidHistory.length > 0"></svg>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <span x-text="'Last updated: ' + $store.roomDetail.formatUpdate($store.roomDetail.selectedRoom.lastSeen)"></span>
            <span> ‚Ä¢ </span>
            <span x-text="$store.roomDetail.tempHistory.length + ' temperature readings, ' + $store.roomDetail.humidHistory.length + ' humidity readings'"></span>
          </div>
        </div>
      </div>
    </template>

  </div>

  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <!-- Stub for co2View - provides initial state and reactive getters -->
  <script>
    window.co2View = function() {
      return {
        // CO2 Thresholds (ppm)
        thresholds: { excellent: 600, good: 1000, moderate: 1500, poor: 2000 },

        // State
        timeRange: '6h',
        timeRanges: ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d'],
        loading: false,
        co2History: [],
        tempHistory: [],
        humidHistory: [],
        trendDirection: 'stable',
        trendValue: 0,
        ambientMode: false,
        _moduleLoaded: false,

        // Reactive getters that access the store directly
        get co2Sensor() {
          const sensors = this.$store?.sensors;
          if (!sensors?.devices) return null;
          return sensors.devices.find(d =>
            d.friendly_name?.toLowerCase().includes('co2') && d.sensorType === 'co2'
          );
        },
        get liveData() {
          if (!this.co2Sensor) return null;
          return this.$store?.sensors?.getLiveData?.(this.co2Sensor.ieee_address) ?? null;
        },
        get co2Value() {
          // Live data first, then fall back to last historical value
          if (this.liveData?.co2 != null) return this.liveData.co2;
          if (this.co2History.length > 0) return this.co2History[this.co2History.length - 1].value;
          return null;
        },
        get temperature() {
          if (this.liveData?.temperature != null) return this.liveData.temperature;
          if (this.tempHistory.length > 0) return this.tempHistory[this.tempHistory.length - 1].value;
          return null;
        },
        get humidity() {
          if (this.liveData?.humidity != null) return this.liveData.humidity;
          if (this.humidHistory.length > 0) return this.humidHistory[this.humidHistory.length - 1].value;
          return null;
        },
        get airQualityLevel() {
          const co2 = this.co2Value;
          if (co2 === null) return 'unknown';
          if (co2 < this.thresholds.excellent) return 'excellent';
          if (co2 < this.thresholds.good) return 'good';
          if (co2 < this.thresholds.moderate) return 'moderate';
          if (co2 < this.thresholds.poor) return 'poor';
          return 'bad';
        },
        get co2Color() {
          const colors = { excellent: '#34C759', good: '#30D158', moderate: '#FFD60A', poor: '#FF9500', bad: '#FF3B30', unknown: '#AEAEB2' };
          return colors[this.airQualityLevel];
        },
        get gaugeArc() {
          const maxPPM = 2500;
          const value = Math.min(this.co2Value || 0, maxPPM);
          const percent = value / maxPPM;
          const circumference = 2 * Math.PI * 90;
          return `${percent * circumference} ${circumference}`;
        },
        get tempLevel() {
          const temp = this.temperature;
          if (temp === null) return 'unknown';
          if (temp < 18) return 'cold';
          if (temp < 20) return 'cool';
          if (temp <= 26) return 'comfortable';
          if (temp <= 28) return 'warm';
          return 'hot';
        },
        get tempColor() {
          const colors = { cold: '#90CAF9', cool: '#A5D6A7', comfortable: '#81C784', warm: '#FFE082', hot: '#EF5350', unknown: '#AEAEB2' };
          return colors[this.tempLevel];
        },
        get humidityLevel() {
          const h = this.humidity;
          if (h === null) return 'unknown';
          if (h < 30) return 'dry';
          if (h < 40) return 'low';
          if (h <= 60) return 'optimal';
          if (h <= 70) return 'high';
          return 'humid';
        },
        get humidityColor() {
          const colors = { dry: '#FFCC80', low: '#A5D6A7', optimal: '#81C784', high: '#90CAF9', humid: '#5C6BC0', unknown: '#AEAEB2' };
          return colors[this.humidityLevel];
        },
        get isStale() {
          if (!this.co2Sensor) return true;
          return this.$store?.sensors?.isStale?.(this.co2Sensor.ieee_address) ?? true;
        },
        get trendArrow() {
          if (this.trendDirection === 'rising') return '\u2191';
          if (this.trendDirection === 'falling') return '\u2193';
          return '\u2192';
        },
        get sensorRoom() {
          if (!this.co2Sensor) return 'Unknown';
          const name = this.co2Sensor.friendly_name || '';
          const match = name.match(/\[([^\]]+)\]/);
          return match ? match[1] + ' Room' : 'Room';
        },
        get minMax() {
          if (this.co2History.length === 0) return { min: '--', max: '--' };
          const values = this.co2History.map(d => d.value);
          return { min: Math.round(Math.min(...values)), max: Math.round(Math.max(...values)) };
        },
        get avgCo2() {
          if (this.co2History.length === 0) return '--';
          const sum = this.co2History.reduce((acc, d) => acc + d.value, 0);
          return Math.round(sum / this.co2History.length);
        },
        get co2Percent() { return Math.min(100, ((this.co2Value || 0) / 2500) * 100); },
        get tempPercent() { return Math.min(100, Math.max(0, ((this.temperature || 20) - 15) / 20 * 100)); },
        get humidityPercent() { return Math.min(100, Math.max(0, this.humidity || 0)); },

        // Methods
        init() {
          console.log('[co2-view] Stub initialized, waiting for module...');
          window._co2ViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          if (window._co2ViewMethods && !this._moduleLoaded) {
            console.log('[co2-view] Module methods available, enhancing...');
            this._moduleLoaded = true;
            // Only copy methods, not getters (getters are already defined above)
            const methods = window._co2ViewMethods;
            if (methods.loadHistoricalData) this.loadHistoricalData = methods.loadHistoricalData.bind(this);
            if (methods.queryInflux) this.queryInflux = methods.queryInflux.bind(this);
            if (methods.setTimeRange) this.setTimeRange = methods.setTimeRange.bind(this);
            if (methods.drawChart) this.drawChart = methods.drawChart.bind(this);
            if (methods.drawThresholdZones) this.drawThresholdZones = methods.drawThresholdZones.bind(this);
            if (methods.formatTimeLabel) this.formatTimeLabel = methods.formatTimeLabel.bind(this);
            if (methods.calculateTrend) this.calculateTrend = methods.calculateTrend.bind(this);
            if (methods.formatLastUpdate) this.formatLastUpdate = methods.formatLastUpdate.bind(this);
            // Load historical data now
            this.loadHistoricalData();
          } else if (!this._moduleLoaded) {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        loadHistoricalData() { console.log('[co2-view] Stub loadHistoricalData (waiting for module)'); },
        setTimeRange(range) { this.timeRange = range; },
        drawChart() {},
        calculateTrend() {},
        formatLastUpdate() { return 'No data'; },
        toggleAmbient() { this.ambientMode = !this.ambientMode; },
        destroy() {}
      };
    };
  </script>

  <!-- Stub for thermostatView - reactive stub that pulls from Alpine store -->
  <script>
    window.thermostatView = function() {
      return {
        activeTab: 'overview',
        timeRange: '24h',
        timelineTimeRange: '24h',
        showBackground: false,
        filterRoom: '',
        filterEventType: '',
        tempHistory: {},
        loading: false,
        chartUpdateInterval: null,

        // Time range presets for timeline filtering
        timeRangePresets: [
          { key: '1h', label: '1h' },
          { key: '6h', label: '6h' },
          { key: 'today', label: 'Today' },
          { key: '24h', label: '24h' },
          { key: '7d', label: '7d' }
        ],

        init() {
          console.log('[thermostat-view] Stub initialized, waiting for module...');
          window._thermostatViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          // Check if real module is loaded
          if (window._thermostatViewMethods && !this._moduleLoaded) {
            console.log('[thermostat-view] Module methods available, enhancing...');
            const methods = window._thermostatViewMethods;
            Object.keys(methods).forEach(key => {
              if (typeof methods[key] === 'function') {
                this[key] = methods[key].bind(this);
              }
            });
            this._moduleLoaded = true;
            if (this.setupMqttListener) this.setupMqttListener();
          } else {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        destroy() {
          if (this.chartUpdateInterval) {
            clearInterval(this.chartUpdateInterval);
          }
        },

        // Getters - these pull from the Alpine store
        get thermostats() {
          return Alpine.store('thermostats')?.list ?? [];
        },

        // Get time cutoff based on selected timeline range
        getTimelineCutoff() {
          const now = Date.now();
          const presetMap = {
            '1h': 60 * 60 * 1000,
            '6h': 6 * 60 * 60 * 1000,
            '24h': 24 * 60 * 60 * 1000,
            '7d': 7 * 24 * 60 * 60 * 1000
          };

          if (this.timelineTimeRange === 'today') {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            return today.getTime();
          }

          return now - (presetMap[this.timelineTimeRange] || presetMap['24h']);
        },

        get events() {
          let events = [...(Alpine.store('thermostats')?.events ?? [])];

          // Apply time filter first
          const cutoff = this.getTimelineCutoff();
          events = events.filter(e => e.time >= cutoff);

          // Apply room filter
          if (this.filterRoom) {
            events = events.filter(e => e.roomId === this.filterRoom);
          }
          // Apply event type filter
          if (this.filterEventType) {
            events = events.filter(e => e.eventType === this.filterEventType);
          }
          return events;
        },

        // ALERTS & WARNINGS - Critical issues requiring attention
        get alertsAndWarnings() {
          return this.events.filter(e =>
            e.info?.priority === 'alert' || e.info?.priority === 'warning'
          ).slice(0, 10);
        },

        get alertEvents() {
          return this.events.filter(e => e.info?.priority === 'alert');
        },

        get hasActiveAlerts() {
          return this.alertEvents.length > 0;
        },

        // ACTIVITY - Normal operations (demoted from "important")
        get activityEvents() {
          return this.events.filter(e => e.info?.priority === 'activity').slice(0, 30);
        },

        // IMPORTANT EVENTS - Activity events shown as "Recent Activity" (for backwards compatibility)
        get importantEvents() {
          return this.activityEvents;
        },

        // BACKGROUND - Routine events (collapsed)
        get backgroundEvents() {
          return this.events.filter(e => e.info?.priority === 'background');
        },

        get stats() {
          return Alpine.store('thermostats')?.getStats?.(24) ?? { heatingCycles: 0, setpointChanges: 0 };
        },

        get activeHeatingCount() {
          return Alpine.store('thermostats')?.activeHeatingCount ?? 0;
        },

        get offlineCount() {
          return Alpine.store('thermostats')?.offlineCount ?? 0;
        },

        get uniqueRooms() {
          const rooms = new Set(this.events.map(e => e.roomId));
          return [...rooms].filter(r => r);
        },

        get uniqueEventTypes() {
          const types = new Set(this.events.map(e => e.eventType));
          return [...types].filter(t => t);
        },

        // UI Helper methods
        setTab(tab) { this.activeTab = tab; },
        setTimeRange(range) {
          this.timeRange = range;
          if (this.activeTab === 'trends' && this.loadHistoricalData) {
            this.loadHistoricalData();
          }
        },
        clearFilters() { this.filterRoom = ''; this.filterEventType = ''; },
        setTimelineTimeRange(range) { this.timelineTimeRange = range; },

        getDisplayTemp(t) {
          const temp = t?.pendingTarget ?? t?.targetTemp;
          return temp;
        },
        getHeatingColor(t) {
          if (t?.systemMode === 'off') return 'var(--color-text-tertiary)';
          if (t?.runningState === 'heat') return 'var(--color-danger)';
          return 'var(--color-success)';
        },
        getStatusText(t) {
          if (!t?.available) return 'Offline';
          if (t?.systemMode === 'off') return 'Off';
          if (t?.runningState === 'heat') return 'Heating';
          return 'Idle';
        },
        getStatusIcon(t) {
          if (!t?.available) return 'üì°';
          if (t?.systemMode === 'off') return '‚èπÔ∏è';
          if (t?.runningState === 'heat') return 'üî•';
          return '‚ùÑÔ∏è';
        },
        getProgressPercent(t) {
          if (!t?.localTemp || !t?.targetTemp) return 0;
          // Show actual temperature ratio regardless of heating state
          const progress = (t.localTemp / t.targetTemp) * 100;
          return Math.min(100, Math.max(0, Math.round(progress)));
        },
        getProgressLabel(t) {
          if (!t?.localTemp || !t?.targetTemp) return 'Unknown';
          if (t?.runningState === 'heat') return 'Heating...';
          // Check if within 0.5¬∞ of target (either direction)
          if (Math.abs(t.localTemp - t.targetTemp) <= 0.5) return 'At target';
          if (t.localTemp > t.targetTemp) return 'Above target';
          return 'Below target';
        },
        getBatteryColor(b) {
          if (b === null) return 'var(--color-text-tertiary)';
          if (b < 20) return 'var(--color-danger)';
          if (b < 50) return 'var(--color-warning)';
          return 'var(--color-success)';
        },
        getBatteryIcon(b) { return b === null || b < 20 ? 'ü™´' : 'üîã'; },
        formatTemp(temp) { return temp?.toFixed(1) ?? '--'; },
        // Format temperature with subtle decimal styling (returns HTML)
        formatTempStyled(temp, showDegree = true) {
          if (temp == null) return '--' + (showDegree ? '¬∞' : '');
          const fixed = temp.toFixed(1);
          const [integer, decimal] = fixed.split('.');
          return `${integer}<span class="temp-decimal">.${decimal}</span>${showDegree ? '¬∞' : ''}`;
        },
        // Split temp into whole and decimal parts for styling
        tempParts(temp) {
          if (temp == null) return { whole: '--', decimal: '' };
          const fixed = temp.toFixed(1);
          const [whole, decimal] = fixed.split('.');
          return { whole, decimal: '.' + decimal };
        },

        // Troubleshooting helpers
        getLastStateChange(t) {
          const stats = this.$store.thermostats?.getStatsByDevice?.(t.id, 24);
          if (!stats?.cycles?.length) return 'No data';

          const isHeating = t.runningState === 'heat';
          const mostRecent = stats.cycles[0];  // Already sorted DESC

          // Currently heating - show live duration
          if (isHeating && mostRecent && !mostRecent.completed) {
            const runningMins = Math.round((Date.now() - mostRecent.startTime) / 60000);
            return `Running ${runningMins}m...`;
          }

          // Find most recent COMPLETED cycle (not just most recent start)
          const lastCompleted = stats.cycles.find(c => c.completed);
          if (lastCompleted) {
            const endTime = lastCompleted.endTime ? this.formatRelativeTime(lastCompleted.endTime) : '?';
            const duration = lastCompleted.durationMinutes ?? '?';
            return `Ended ${endTime} (${duration}m)`;
          }

          // No completed cycles - show when last started (incomplete)
          if (mostRecent) {
            return `Started ${this.formatRelativeTime(mostRecent.startTime)} (incomplete)`;
          }

          return 'No data';
        },
        getTodayStats(t) {
          const stats = this.$store.thermostats?.getStatsByDevice?.(t.id, 24) || {
            heatingCycles: 0, heatingMinutes: 0, avgCycleMinutes: 0
          };

          if (stats.heatingCycles === 0) return 'No cycles';

          const total = this.formatDuration(stats.heatingMinutes);
          const avg = stats.avgCycleMinutes > 0 ? ` avg ${stats.avgCycleMinutes}m` : '';

          return `${stats.heatingCycles} cycles ${total}${avg}`;
        },

        // Stub placeholders for pill-based stats (replaced by module)
        getLastCycleText(t) { return 'Loading...'; },
        getCycleCount(t) { return '--'; },
        getTotalTime(t) { return '--'; },
        getAvgTime(t) { return null; },

        formatTime(ts) {
          const date = new Date(ts);
          const now = new Date();
          if (date.toDateString() === now.toDateString()) {
            return date.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
          }
          return date.toLocaleDateString('en-AU', { weekday: 'short', hour: 'numeric', minute: '2-digit' });
        },
        formatRelativeTime(ts) {
          const s = Math.floor((Date.now() - ts) / 1000);
          if (s < 60) return 'Just now';
          if (s < 3600) return `${Math.floor(s / 60)}m ago`;
          if (s < 86400) return `${Math.floor(s / 3600)}h ago`;
          return `${Math.floor(s / 86400)}d ago`;
        },
        formatDuration(m) {
          if (m < 60) return `${m}m`;
          const h = Math.floor(m / 60);
          const mins = m % 60;
          return mins > 0 ? `${h}h ${mins}m` : `${h}h`;
        },
        getEventInfo(type) {
          const types = {
            // ALERT - Requires immediate action
            device_offline: { icon: 'üî¥', color: '#ef4444', label: 'Device Offline', priority: 'alert', action: 'Check device power and Zigbee signal' },
            low_battery_critical: { icon: 'ü™´', color: '#ef4444', label: 'Battery Critical', priority: 'alert', action: 'Replace batteries immediately' },
            // WARNING - Should investigate
            low_battery: { icon: 'üîã', color: '#f59e0b', label: 'Battery Low', priority: 'warning', action: 'Plan to replace batteries soon' },
            window_detected: { icon: 'ü™ü', color: '#f59e0b', label: 'Window Open', priority: 'warning', action: 'Heating paused - close window to resume' },
            // ACTIVITY - Normal operations
            heating_started: { icon: 'üî•', color: '#ef4444', label: 'Heating Started', priority: 'activity' },
            heating_stopped: { icon: '‚ùÑÔ∏è', color: '#3b82f6', label: 'Heating Stopped', priority: 'activity' },
            target_reached: { icon: '‚úÖ', color: '#22c55e', label: 'Target Reached', priority: 'activity' },
            setpoint_changed: { icon: 'üéØ', color: '#f59e0b', label: 'Setpoint Changed', priority: 'activity' },
            mode_changed: { icon: '‚öôÔ∏è', color: '#8b5cf6', label: 'Mode Changed', priority: 'activity' },
            preset_changed: { icon: 'üöÄ', color: '#06b6d4', label: 'Preset Changed', priority: 'activity' },
            child_lock_changed: { icon: 'üîí', color: '#64748b', label: 'Child Lock Changed', priority: 'activity' },
            initial_state: { icon: 'üìç', color: '#6366f1', label: 'Initial State', priority: 'activity' },
            // BACKGROUND - Routine events
            device_online: { icon: 'üì°', color: '#22c55e', label: 'Device Online', priority: 'background' },
            battery_ok: { icon: 'üîã', color: '#22c55e', label: 'Battery OK', priority: 'background' },
            temp_update: { icon: 'üå°Ô∏è', color: '#94a3b8', label: 'Temperature Update', priority: 'background' }
          };
          return types[type] || { icon: 'üìù', color: '#94a3b8', label: type, priority: 'background' };
        },

        // Control methods - delegate to store
        adjustTemp(id, delta) { Alpine.store('thermostats')?.adjustTemp?.(id, delta); },
        setTargetTemp(id, temp) { Alpine.store('thermostats')?.setTargetTemp?.(id, parseFloat(temp)); },
        togglePower(id) { Alpine.store('thermostats')?.togglePower?.(id); },
        setMode(id, mode) { Alpine.store('thermostats')?.setMode?.(id, mode); },
        toggleChildLock(id) {
          const t = Alpine.store('thermostats')?.getThermostat?.(id);
          if (t) Alpine.store('thermostats')?.setChildLock?.(id, t.childLock === 'UNLOCK');
        },

        // Efficiency
        getDeviceStats(id) { return Alpine.store('thermostats')?.getStatsByDevice?.(id, 24) ?? {}; },
        getComparisonStats() {
          const today = this.stats;
          return {
            today,
            yesterday: { heatingCycles: today.heatingCycles + 2, setpointChanges: today.setpointChanges + 1 }
          };
        },

        // Historical data - stub, real methods will come from module
        async loadHistoricalData() { console.log('[thermostat-view] loadHistoricalData stub called'); },
        drawCharts() { console.log('[thermostat-view] drawCharts stub called'); },
        drawThermostatChart(id) { console.log('[thermostat-view] drawThermostatChart stub called'); }
      };
    };
  </script>

  <!-- Stub for mailboxView - reactive stub that waits for module -->
  <script>
    window.mailboxView = function() {
      return {
        // State
        deviceName: '[Mailbox] Motion Sensor',
        dateRange: 'today',
        patternMode: 'hourly',
        mailboxEvents: [],
        loading: false,
        _mqttSetup: false,
        _moduleLoaded: false,

        init() {
          console.log('[mailbox-view] Stub initialized, waiting for module...');
          window._mailboxViewComponent = this;
          this._checkForModule();
        },

        _checkForModule() {
          if (window._mailboxViewMethods && !this._moduleLoaded) {
            console.log('[mailbox-view] Module methods available, enhancing...');
            const methods = window._mailboxViewMethods;
            Object.keys(methods).forEach(key => {
              if (typeof methods[key] === 'function') {
                this[key] = methods[key].bind(this);
              }
            });
            this._moduleLoaded = true;
            if (this.loadMailboxEvents) this.loadMailboxEvents();
            if (this.setupMqttListener) this.setupMqttListener();
          } else {
            setTimeout(() => this._checkForModule(), 100);
          }
        },

        destroy() {
          if (this._refreshInterval) {
            clearInterval(this._refreshInterval);
          }
        },

        // Computed getters
        get filteredEvents() {
          const now = Date.now();
          let startTime, endTime = now;
          switch (this.dateRange) {
            case 'today':
              startTime = new Date().setHours(0, 0, 0, 0);
              break;
            case 'yesterday':
              const yesterday = new Date();
              yesterday.setDate(yesterday.getDate() - 1);
              startTime = yesterday.setHours(0, 0, 0, 0);
              endTime = new Date().setHours(0, 0, 0, 0);
              break;
            case 'week':
              startTime = now - 7 * 24 * 60 * 60 * 1000;
              break;
            default:
              startTime = new Date().setHours(0, 0, 0, 0);
          }
          return this.mailboxEvents.filter(e => e.time >= startTime && e.time <= endTime);
        },

        get deliveryEvents() {
          return this.filteredEvents.filter(e => e.eventType === 'motion_detected');
        },

        get lastDelivery() {
          const deliveries = this.mailboxEvents.filter(e => e.eventType === 'motion_detected');
          return deliveries.length > 0 ? deliveries[0] : null;
        },

        get hasMailToday() {
          const todayStart = new Date().setHours(0, 0, 0, 0);
          return this.mailboxEvents.some(e => e.eventType === 'motion_detected' && e.time >= todayStart);
        },

        get stats() {
          const todayStart = new Date().setHours(0, 0, 0, 0);
          const weekStart = Date.now() - 7 * 24 * 60 * 60 * 1000;
          const allDeliveries = this.mailboxEvents.filter(e => e.eventType === 'motion_detected');
          const todayDeliveries = allDeliveries.filter(e => e.time >= todayStart);
          const weekDeliveries = allDeliveries.filter(e => e.time >= weekStart);
          const deliveryHours = weekDeliveries.map(e => new Date(e.time).getHours());
          const avgHour = deliveryHours.length > 0
            ? Math.round(deliveryHours.reduce((a, b) => a + b, 0) / deliveryHours.length)
            : null;
          return {
            todayCount: todayDeliveries.length,
            weekCount: weekDeliveries.length,
            totalCount: allDeliveries.length,
            avgDeliveryHour: avgHour,
            avgDeliveryTime: avgHour !== null ? this.formatHour(avgHour) : '--'
          };
        },

        get signalHealth() {
          const now = Date.now();
          const twentyFourHoursAgo = now - 24 * 60 * 60 * 1000;
          const recentEvents = this.mailboxEvents.filter(e => e.time >= twentyFourHoursAgo);
          const sortedEvents = [...recentEvents].sort((a, b) => b.time - a.time);
          const lastEvent = sortedEvents[0];
          const lastSeen = lastEvent?.time || null;
          let gaps = 0;
          const thirtyMinutes = 30 * 60 * 1000;
          for (let i = 0; i < sortedEvents.length - 1; i++) {
            if (sortedEvents[i].time - sortedEvents[i + 1].time > thirtyMinutes) gaps++;
          }
          const timeSinceLastSeen = lastSeen ? now - lastSeen : Infinity;
          const isOffline = timeSinceLastSeen > thirtyMinutes;
          const expectedEvents = 24 * 2;
          const uptimePercent = Math.min(100, Math.round((recentEvents.length / expectedEvents) * 100));
          let status = 'healthy', label = 'Healthy';
          if (isOffline) { status = 'critical'; label = 'Offline'; }
          else if (gaps > 3 || uptimePercent < 50) { status = 'warning'; label = 'Intermittent'; }
          else if (recentEvents.length === 0) { status = 'unknown'; label = 'No Data'; }
          return { status, label, lastSeen, uptimePercent, gaps, eventCount: recentEvents.length };
        },

        get hourlyPattern() {
          const hours = new Array(24).fill(0);
          const weekStart = Date.now() - 7 * 24 * 60 * 60 * 1000;
          this.mailboxEvents.filter(e => e.eventType === 'motion_detected' && e.time >= weekStart)
            .forEach(e => hours[new Date(e.time).getHours()]++);
          const max = Math.max(...hours, 1);
          return hours.map((count, hour) => ({
            hour, count, height: (count / max) * 100,
            label: this.formatHourShort(hour), isEmpty: count === 0
          }));
        },

        get dailyPattern() {
          const days = new Array(7).fill(0);
          const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
          const monthStart = Date.now() - 30 * 24 * 60 * 60 * 1000;
          this.mailboxEvents.filter(e => e.eventType === 'motion_detected' && e.time >= monthStart)
            .forEach(e => days[new Date(e.time).getDay()]++);
          const max = Math.max(...days, 1);
          return days.map((count, day) => ({
            day, count, height: (count / max) * 100,
            label: dayNames[day], isEmpty: count === 0
          }));
        },

        get patternData() {
          return this.patternMode === 'hourly' ? this.hourlyPattern : this.dailyPattern;
        },

        // Formatting helpers
        formatTime(timestamp) {
          if (!timestamp) return '--';
          return new Date(timestamp).toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit', hour12: true });
        },
        formatDate(timestamp) {
          if (!timestamp) return '--';
          return new Date(timestamp).toLocaleDateString('en-AU', { weekday: 'short', month: 'short', day: 'numeric' });
        },
        formatDateTime(timestamp) {
          if (!timestamp) return '--';
          return new Date(timestamp).toLocaleString('en-AU', { weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true });
        },
        formatRelativeTime(timestamp) {
          if (!timestamp) return '--';
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          return `${Math.floor(seconds / 86400)}d ago`;
        },
        formatHour(hour) {
          const period = hour >= 12 ? 'PM' : 'AM';
          const displayHour = hour % 12 || 12;
          return `${displayHour}:00 ${period}`;
        },
        formatHourShort(hour) {
          if (hour === 0) return '12a';
          if (hour === 12) return '12p';
          if (hour < 12) return `${hour}a`;
          return `${hour - 12}p`;
        },

        // Event helpers
        getEventIcon(eventType) {
          const icons = { motion_detected: '1f4ec', motion_cleared: '1f4ed', device_online: '1f4e1', device_offline: '26a0' };
          const code = icons[eventType] || '1f4cd';
          return String.fromCodePoint(parseInt(code, 16));
        },
        getEventLabel(eventType) {
          const labels = { motion_detected: 'Mail Arrived', motion_cleared: 'Motion Cleared', device_online: 'Sensor Online', device_offline: 'Sensor Offline' };
          return labels[eventType] || eventType;
        },
        getEventClass(eventType) { return eventType.replace(/_/g, '-'); },

        // Actions
        setDateRange(range) { this.dateRange = range; },
        setPatternMode(mode) { this.patternMode = mode; },
        refresh() { if (this.loadMailboxEvents) this.loadMailboxEvents(); },

        // Stubs - real methods come from module
        async loadMailboxEvents() { console.log('[mailbox-view] loadMailboxEvents stub called'); },
        setupMqttListener() { console.log('[mailbox-view] setupMqttListener stub called'); },
        addLiveEvent(event) { console.log('[mailbox-view] addLiveEvent stub called'); }
      };
    };
  </script>

  <!-- Thermostat View Module - loads store and view -->
  <script type="module">
    import { initThermostatStore } from './js/stores/thermostat-store.js?v=5';
    import { thermostatView } from './views/thermostat.js?v=7';

    // Expose thermostatView globally for Alpine x-data
    window.thermostatView = thermostatView;
    console.log('[thermostat] Module loaded, thermostatView ready');

    // Initialize thermostat store
    function initThermostats() {
      const CONFIG = window.CONFIG;
      if (typeof Alpine !== 'undefined' && CONFIG) {
        if (!Alpine.store('thermostats')) {
          initThermostatStore(Alpine, CONFIG);
          console.log('[thermostat] Thermostat store initialized');
        }
        // Initialize MQTT subscriptions after MQTT connects
        setTimeout(() => {
          const thermostatStore = Alpine.store('thermostats');
          if (thermostatStore) {
            thermostatStore.init?.();
            console.log('[thermostat] MQTT subscriptions initializing');
          }
        }, 2000);
      }
    }

    // Try to initialize when Alpine is ready
    if (typeof Alpine !== 'undefined') {
      initThermostats();
    } else {
      document.addEventListener('alpine:init', () => {
        initThermostatStore(Alpine, window.CONFIG);
      });
      document.addEventListener('DOMContentLoaded', initThermostats);
    }
  </script>

  <!-- Mailbox View Module - loads methods and triggers stub enhancement -->
  <script type="module">
    import { mailboxView } from './views/mailbox.js?v=2';

    // Get the module object and extract the methods
    const moduleObj = mailboxView();
    window._mailboxViewMethods = {
      loadMailboxEvents: moduleObj.loadMailboxEvents,
      setupMqttListener: moduleObj.setupMqttListener,
      addLiveEvent: moduleObj.addLiveEvent
    };
    console.log('[mailbox] Module loaded, methods ready');

    // If stub component exists, trigger enhancement
    if (window._mailboxViewComponent && !window._mailboxViewComponent._moduleLoaded) {
      console.log('[mailbox] Stub found, enhancing with methods...');
      window._mailboxViewComponent._checkForModule();
    }
  </script>

  <!-- CO2 View Module - loads methods and triggers stub enhancement -->
  <script type="module">
    import { co2View } from './views/co2-monitor.js?v=1';

    // Get the module object and extract the methods
    const moduleObj = co2View();
    window._co2ViewMethods = {
      loadHistoricalData: moduleObj.loadHistoricalData,
      queryInflux: moduleObj.queryInflux,
      setTimeRange: moduleObj.setTimeRange,
      drawChart: moduleObj.drawChart,
      drawThresholdZones: moduleObj.drawThresholdZones,
      formatTimeLabel: moduleObj.formatTimeLabel,
      calculateTrend: moduleObj.calculateTrend,
      formatLastUpdate: moduleObj.formatLastUpdate,
      toggleAmbient: moduleObj.toggleAmbient,
      destroy: moduleObj.destroy
    };
    console.log('[co2-view] Module loaded, methods ready');

    // If stub component exists, trigger enhancement
    if (window._co2ViewComponent && !window._co2ViewComponent._moduleLoaded) {
      console.log('[co2-view] Stub found, enhancing with methods...');
      window._co2ViewComponent._checkForModule();
    }
  </script>

  <!-- Sensors Store Module - discovers and tracks sensor data for doors/windows -->
  <script type="module">
    import { initSensorsStore } from './js/stores/sensors-store.js?v=2';

    function initSensors() {
      const CONFIG = window.CONFIG;
      if (typeof Alpine !== 'undefined' && CONFIG) {
        if (!Alpine.store('sensors')) {
          initSensorsStore(Alpine, CONFIG);
          console.log('[sensors] Sensors store initialized');
        }
        // Initialize sensors store after MQTT connects
        setTimeout(() => {
          const sensorsStore = Alpine.store('sensors');
          if (sensorsStore) {
            sensorsStore.init?.();
            sensorsStore.startDurationTicker?.();
            console.log('[sensors] Sensor discovery initialized');

            // Load open timestamps from InfluxDB after devices are discovered
            // This corrects fallback timers with actual open times
            setTimeout(() => {
              sensorsStore.loadOpenSensorTimestamps?.(CONFIG);
            }, 3000);
          }
        }, 2000);
      }
    }

    if (typeof Alpine !== 'undefined') {
      initSensors();
    } else {
      document.addEventListener('alpine:init', () => {
        initSensorsStore(Alpine, window.CONFIG);
      });
      document.addEventListener('DOMContentLoaded', initSensors);
    }
  </script>

  <!-- Events Store Module - tracks door/window/motion events -->
  <script type="module">
    import { initEventsStore } from './js/stores/events-store.js';

    function initEvents() {
      const CONFIG = window.CONFIG;
      if (typeof Alpine !== 'undefined' && CONFIG) {
        if (!Alpine.store('events')) {
          initEventsStore(Alpine, CONFIG);
          console.log('[events] Events store initialized');
        }
        // Load historical events after init
        setTimeout(() => {
          const eventsStore = Alpine.store('events');
          if (eventsStore) {
            eventsStore.loadHistorical?.(24);
            console.log('[events] Historical events loading');
          }
        }, 2000);
      }
    }

    if (typeof Alpine !== 'undefined') {
      initEvents();
    } else {
      document.addEventListener('alpine:init', () => {
        initEventsStore(Alpine, window.CONFIG);
      });
      document.addEventListener('DOMContentLoaded', initEvents);
    }
  </script>

  <script>
    // ========================================
    // CONFIGURATION
    // ========================================
    // Detect local dev (localhost) vs Pi deployment
    const isLocalDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const isNginxProxy = window.location.port === '8888';
    const CONFIG = {
      mqttUrl: isLocalDev
        ? 'ws://pi:9001'  // Local dev ‚Üí connect to Pi's MQTT
        : isNginxProxy
          ? 'ws://' + window.location.host + '/mqtt'  // Pi nginx proxy
          : 'ws://' + window.location.hostname + ':9001',
      baseTopic: 'zigbee2mqtt',
      influxUrl: isLocalDev
        ? 'http://pi:8086'  // Local dev ‚Üí connect to Pi's InfluxDB
        : '/api/influx',
      influxDb: 'homeassistant',
      // Room configuration - isOutdoor: true excludes from home-wide averages
      // Order: Row1: hallway, study | Row2: living, bedroom | Row3: bathroom, kitchen
      rooms: [
        { id: 'hallway', name: 'Hallway', icon: 'üö∂', sensor: '[Hallway] CO2', entityId: 'sensor.hallway_co2', isOutdoor: false },
        { id: 'study', name: 'Study', icon: 'üìö', sensor: '[Study] Temperature & Humidity', entityId: 'sensor.study_temperature_humidity', isOutdoor: false },
        { id: 'living', name: 'Living Room', icon: 'üõãÔ∏è', sensor: '[Living] Temperature & Humidity', entityId: 'sensor.living_temperature_humidity', isOutdoor: false },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', sensor: '[Bed] Temperature & Humidity Sensor', entityId: 'sensor.bed_temperature_humidity_sensor', isOutdoor: false },
        { id: 'bathroom', name: 'Bathroom', icon: 'üöø', sensor: '[Bath] Temperature & Humidity', entityId: 'sensor.bath_temperature_humidity', isOutdoor: false },
        { id: 'kitchen', name: 'Kitchen', icon: 'üç≥', sensor: '[Kitchen] Temperature & Humidity', entityId: 'sensor.kitchen_temperature_humidity', isOutdoor: false },
        { id: 'balcony', name: 'Balcony', icon: 'üåø', sensor: '[Balcony] Temperature & Humidity', entityId: 'sensor.balcony_temperature_humidity', isOutdoor: true }
      ],
      staleThreshold: 5 * 60 * 1000,
      maxHistoryPoints: 500,
      historyHours: 6,
      // Thermostats (SONOFF TRVZB)
      thermostats: [
        { id: 'study', name: 'Study', icon: 'üìö', sensor: '[Study] Thermostat', entityId: 'climate.study_thermostat', roomId: 'study', roomSensor: '[Study] Temperature & Humidity' },
        { id: 'living_inner', name: 'Living Inner', icon: 'üõãÔ∏è', sensor: '[Living] Thermostat Inner', entityId: 'climate.living_thermostat_inner', roomId: 'living', roomSensor: '[Living] Temperature & Humidity' },
        { id: 'living_outer', name: 'Living Outer', icon: 'üõãÔ∏è', sensor: '[Living] Thermostat Outer', entityId: 'climate.living_thermostat_outer', roomId: 'living', roomSensor: '[Living] Temperature & Humidity' },
        { id: 'bedroom', name: 'Bedroom', icon: 'üõèÔ∏è', sensor: '[Bed] Thermostat', entityId: 'climate.bedroom_thermostat', roomId: 'bedroom', roomSensor: '[Bed] Temperature & Humidity Sensor' }
      ]
    };

    // Room-to-sensors mapping for multi-sensor support
    const ROOM_SENSORS = {
      living: {
        climate: [
          { name: '[Living] Temperature & Humidity', label: 'West', isPrimary: true },
          { name: '[Living] Temperature & Humidity 6', label: 'North' },
          { name: '[Living] Temperature & Humidity 7', label: 'Inner' }
        ],
        thermostat: [
          { name: '[Living] Thermostat Inner', label: 'Heater Inner' },
          { name: '[Living] Thermostat Outer', label: 'Heater Outer' }
        ],
        co2: [
          { name: '[Hallway] CO2', label: 'Air Quality' }
        ]
      },
      bedroom: {
        climate: [
          { name: '[Bed] Temperature & Humidity Sensor', label: 'East', isPrimary: true },
          { name: '[Bed] Temperature & Humidity Sensor 9', label: 'North' }
        ],
        thermostat: [
          { name: '[Bed] Thermostat', label: 'Heater' }
        ]
      },
      study: {
        climate: [
          { name: '[Study] Temperature & Humidity', label: 'West', isPrimary: true },
          { name: '[Study] Temperature & Humidity 8', label: 'Inner' }
        ],
        thermostat: [
          { name: '[Study] Thermostat', label: 'Heater' }
        ]
      },
      kitchen: {
        climate: [
          { name: '[Kitchen] Temperature & Humidity', label: 'East', isPrimary: true },
          { name: '[Kitchen] Temperature & Humidity 10', label: 'Inner' }
        ]
      },
      bathroom: {
        climate: [
          { name: '[Bath] Temperature & Humidity', label: 'East', isPrimary: true },
          { name: '[Bath] Temperature & Humidity 11', label: 'Inner' }
        ]
      },
      balcony: {
        climate: [
          { name: '[Balcony] Temperature & Humidity', label: 'Outdoor', isPrimary: true }
        ]
      },
      hallway: {
        climate: [
          { name: '[Hallway] CO2', label: 'CO2 Sensor', isPrimary: true }
        ],
        co2: [
          { name: '[Hallway] CO2', label: 'Air Quality' }
        ]
      }
    };

    // Make CONFIG globally available for modules
    window.CONFIG = CONFIG;
    window.ROOM_SENSORS = ROOM_SENSORS;

    // Global temperature formatting helper (subtle decimal styling)
    window.formatTempStyled = function(temp, showDegree = true) {
      if (temp == null) return '--' + (showDegree ? '¬∞' : '');
      const fixed = temp.toFixed(1);
      const [integer, decimal] = fixed.split('.');
      return `${integer}<span class="temp-decimal">.${decimal}</span>${showDegree ? '¬∞' : ''}`;
    };

    // ========================================
    // ALPINE STORES
    // ========================================
    document.addEventListener('alpine:init', () => {

      // Config store
      Alpine.store('config', CONFIG);

      // MQTT connection store
      Alpine.store('mqtt', {
        connected: false,
        connecting: true,
        client: null,

        connect() {
          this.connecting = true;

          this.client = mqtt.connect(CONFIG.mqttUrl, {
            clientId: 'climate-' + Math.random().toString(16).substr(2, 8),
            reconnectPeriod: 3000,
            connectTimeout: 10000
          });

          this.client.on('connect', () => {
            this.connected = true;
            this.connecting = false;

            // Subscribe to ALL zigbee2mqtt topics (for logs view)
            this.client.subscribe(`${CONFIG.baseTopic}/#`, { qos: 0 });
            console.log(`[mqtt] Subscribed to ${CONFIG.baseTopic}/# (all topics for logs)`);

            // Subscribe to dashboard topics (for TTS notifications, commands, etc.)
            this.client.subscribe('dashboard/#', { qos: 0 });
            console.log('[mqtt] Subscribed to dashboard/# (TTS notifications)');

            // Subscribe to room sensors (primary) - now covered by wildcard but keeping for clarity
            CONFIG.rooms.forEach(room => {
              // Already covered by wildcard
            });

            // Subscribe to all additional sensors from ROOM_SENSORS
            Object.values(ROOM_SENSORS).forEach(roomConfig => {
              const allSensors = [
                ...(roomConfig.climate || []),
                ...(roomConfig.co2 || []),
                ...(roomConfig.motion || []),
                ...(roomConfig.contact || [])
              ];
              allSensors.forEach(sensor => {
                this.client.subscribe(`${CONFIG.baseTopic}/${sensor.name}`, { qos: 0 });
              });
            });

            // Subscribe to light topics (state and availability)
            Alpine.store('lights').list.forEach(light => {
              this.client.subscribe(`${CONFIG.baseTopic}/${light.topic}`, { qos: 0 });
              this.client.subscribe(`${CONFIG.baseTopic}/${light.topic}/availability`, { qos: 0 });
            });
          });

          this.client.on('message', (topic, message) => {
            try {
              const msgStr = message.toString();
              const deviceName = topic.replace(`${CONFIG.baseTopic}/`, '');

              // Capture ALL messages for logs store (before any filtering)
              try {
                const logPayload = JSON.parse(msgStr);
                Alpine.store('logs')?.captureMessage(topic, logPayload);
              } catch (e) {
                // Non-JSON message, capture as-is
                Alpine.store('logs')?.captureMessage(topic, { raw: msgStr });
              }

              // Check if it's an availability message
              if (topic.endsWith('/availability')) {
                const lightTopic = deviceName.replace('/availability', '');
                // Handle both JSON {"state":"online"} and plain string "online"
                let isOnline;
                try {
                  const data = JSON.parse(msgStr);
                  isOnline = data.state === 'online';
                } catch {
                  isOnline = msgStr === 'online';
                }
                Alpine.store('lights').setAvailability(lightTopic, isOnline);
                return;
              }

              const data = JSON.parse(msgStr);

              // Check if it's a room sensor (primary)
              const roomConfig = CONFIG.rooms.find(r => r.sensor === deviceName);
              if (roomConfig) {
                Alpine.store('rooms').updateRoom(deviceName, data);
                // Note: updateRoom() calls updateSensor() internally
                return;
              }

              // Check if it's an additional sensor in any room
              const sensorFound = Alpine.store('rooms').updateSensor(deviceName, data);
              if (sensorFound) return;

              // Check if it's a light
              Alpine.store('lights').updateLight(deviceName, data);
            } catch (e) {
              console.error('MQTT parse error:', e);
            }
          });

          this.client.on('error', (err) => console.error('MQTT Error:', err));
          this.client.on('close', () => { this.connected = false; this.connecting = true; });
          this.client.on('reconnect', () => { this.connecting = true; });
        }
      });

      // Rooms data store (with multi-sensor support)
      Alpine.store('rooms', {
        list: CONFIG.rooms.map(r => {
          // Get all sensors for this room from ROOM_SENSORS config
          const roomSensorConfig = ROOM_SENSORS[r.id] || { climate: [] };
          const allSensors = [
            ...(roomSensorConfig.climate || []).map(s => ({ ...s, type: 'climate' })),
            ...(roomSensorConfig.co2 || []).map(s => ({ ...s, type: 'co2' })),
            ...(roomSensorConfig.thermostat || []).map(s => ({ ...s, type: 'thermostat' })),
            ...(roomSensorConfig.motion || []).map(s => ({ ...s, type: 'motion' })),
            ...(roomSensorConfig.contact || []).map(s => ({ ...s, type: 'contact' }))
          ];

          return {
            ...r,
            temperature: null,
            humidity: null,
            lastSeen: null,
            stale: false,
            tempHistory: [],
            humidHistory: [],
            // Multi-sensor support
            sensors: allSensors.map(s => ({
              ...s,
              temperature: null,
              humidity: null,
              co2: null,
              battery: null,
              lastSeen: null,
              stale: false
            })),
            // Computed room averages
            avgTemperature: null,
            avgHumidity: null,
            tempSpread: null
          };
        }),
        lastUpdate: null,
        loading: false,
        version: 0,  // Reactive trigger for header updates

        get historyCount() {
          return this.list.reduce((sum, r) => sum + r.tempHistory.length + r.humidHistory.length, 0);
        },

        // Indoor rooms only (excludes outdoor rooms like balcony)
        get indoorRooms() {
          return this.list.filter(r => !r.isOutdoor);
        },

        // Home-wide average temperature (indoor rooms only)
        get avgTemperature() {
          const temps = this.indoorRooms.filter(r => r.avgTemperature != null).map(r => r.avgTemperature);
          if (temps.length === 0) return null;
          return temps.reduce((a, b) => a + b, 0) / temps.length;
        },

        // Home-wide average humidity (indoor rooms only)
        get avgHumidity() {
          const humids = this.indoorRooms.filter(r => r.avgHumidity != null).map(r => r.avgHumidity);
          if (humids.length === 0) return null;
          return humids.reduce((a, b) => a + b, 0) / humids.length;
        },

        // CO2 value from hallway sensor
        get co2Value() {
          for (const room of this.list) {
            const co2Sensor = room.sensors.find(s => s.co2 != null);
            if (co2Sensor) return co2Sensor.co2;
          }
          return null;
        },

        updateRoom(sensorName, data) {
          const roomIndex = this.list.findIndex(r => r.sensor === sensorName);
          if (roomIndex === -1) return;

          const room = this.list[roomIndex];
          const now = Date.now();

          let sensorTime = now;
          if (data.last_seen) {
            sensorTime = typeof data.last_seen === 'number' ? data.last_seen : new Date(data.last_seen).getTime();
          }

          if (data.temperature !== undefined) {
            room.temperature = data.temperature;
            room.tempHistory.push({ time: sensorTime, value: data.temperature });
            if (room.tempHistory.length > CONFIG.maxHistoryPoints) room.tempHistory.shift();
          }

          if (data.humidity !== undefined) {
            room.humidity = data.humidity;
            room.humidHistory.push({ time: sensorTime, value: data.humidity });
            if (room.humidHistory.length > CONFIG.maxHistoryPoints) room.humidHistory.shift();
          }

          room.lastSeen = sensorTime;
          room.stale = false;
          this.lastUpdate = now;
          this.version++;  // Force header reactivity

          // Also update in the sensors array if this is a primary sensor
          this.updateSensor(sensorName, data);
        },

        // Update individual sensor in any room's sensors array
        // Updates ALL sensors with matching name (same physical device may be registered as multiple types)
        updateSensor(sensorName, data) {
          const now = Date.now();
          let found = false;

          for (const room of this.list) {
            // Find ALL sensors with this name (not just the first)
            const sensors = room.sensors.filter(s => s.name === sensorName);
            if (sensors.length > 0) {
              found = true;

              let sensorTime = now;
              if (data.last_seen) {
                sensorTime = typeof data.last_seen === 'number' ? data.last_seen : new Date(data.last_seen).getTime();
              }

              // Update ALL matching sensors
              for (const sensor of sensors) {
                if (data.temperature !== undefined) sensor.temperature = data.temperature;
                if (data.local_temperature !== undefined) sensor.temperature = data.local_temperature;
                if (data.humidity !== undefined) sensor.humidity = data.humidity;
                if (data.co2 !== undefined) sensor.co2 = data.co2;
                if (data.battery !== undefined) sensor.battery = data.battery;

                sensor.lastSeen = sensorTime;
                sensor.stale = false;
              }

              // Recalculate room averages
              this._recalculateRoomAverages(room);
              this.lastUpdate = now;
              this.version++;  // Force header reactivity
            }
          }
          return found;
        },

        // Recalculate room averages from all temperature sensors (climate + thermostat)
        _recalculateRoomAverages(room) {
          // Include both climate and thermostat sensors for temperature average
          const tempSensors = room.sensors.filter(s =>
            (s.type === 'climate' || s.type === 'thermostat') && s.temperature != null
          );

          if (tempSensors.length === 0) {
            room.avgTemperature = room.temperature;
            room.avgHumidity = room.humidity;
            room.tempSpread = null;
            return;
          }

          const temps = tempSensors.map(s => s.temperature);
          room.avgTemperature = temps.reduce((a, b) => a + b, 0) / temps.length;
          room.tempSpread = Math.max(...temps) - Math.min(...temps);

          // Humidity only from climate sensors (thermostats don't have humidity)
          const humids = tempSensors.filter(s => s.humidity != null).map(s => s.humidity);
          if (humids.length > 0) {
            room.avgHumidity = humids.reduce((a, b) => a + b, 0) / humids.length;
          }
        },

        async loadHistorical() {
          this.loading = true;
          for (const room of this.list) {
            try {
              const tempQuery = `SELECT value FROM "¬∞C" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_temperature' AND time > now() - ${CONFIG.historyHours}h ORDER BY time ASC`;
              const tempUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(tempQuery)}`;
              const tempRes = await fetch(tempUrl);
              const tempData = await tempRes.json();

              if (tempData.results?.[0]?.series?.[0]?.values) {
                const values = tempData.results[0].series[0].values;
                room.tempHistory = values.map(v => ({ time: new Date(v[0]).getTime(), value: v[1] }));
                room.temperature = values[values.length - 1][1];
                room.lastSeen = new Date(values[values.length - 1][0]).getTime();
              }

              const humidQuery = `SELECT value FROM "%" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_humidity' AND time > now() - ${CONFIG.historyHours}h ORDER BY time ASC`;
              const humidUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(humidQuery)}`;
              const humidRes = await fetch(humidUrl);
              const humidData = await humidRes.json();

              if (humidData.results?.[0]?.series?.[0]?.values) {
                const values = humidData.results[0].series[0].values;
                room.humidHistory = values.map(v => ({ time: new Date(v[0]).getTime(), value: v[1] }));
                room.humidity = values[values.length - 1][1];
              }
            } catch (e) {
              console.error(`Failed to load history for ${room.name}:`, e);
            }
          }
          this.lastUpdate = Date.now();
          this.loading = false;
        },

        checkStale() {
          const now = Date.now();
          this.list.forEach(room => {
            if (room.lastSeen && (now - room.lastSeen) > CONFIG.staleThreshold) {
              room.stale = true;
            }
          });
        }
      });

      // Lights store
      Alpine.store('lights', {
        list: [
          {
            id: 'study_light',
            name: 'Study Light',
            icon: 'üìö',
            topic: '[Study] IKEA Light',
            state: 'OFF',
            brightness: 254,
            colorTemp: 370,
            linkquality: null,
            lastSeen: null,
            syncing: false,
            available: true
          },
          {
            id: 'living_light',
            name: 'Living Room Light',
            icon: 'üõãÔ∏è',
            topic: '[Living] IKEA Light',
            state: 'OFF',
            brightness: 254,
            colorTemp: 370,
            linkquality: null,
            lastSeen: null,
            syncing: false,
            available: true
          }
        ],
        syncing: false,
        initializing: true,
        _brightnessTimeout: null,
        _colorTempTimeout: null,

        get anyLightSyncing() {
          return this.list.some(l => l.syncing);
        },

        get lightsOnCount() {
          return this.list.filter(l => l.state === 'ON' && l.available).length;
        },

        presets: {
          reading: { brightness: 254, colorTemp: 300 },
          relax: { brightness: 150, colorTemp: 400 },
          bright: { brightness: 254, colorTemp: 250 },
          night: { brightness: 30, colorTemp: 454 }
        },

        scenes: {
          movie: { state: 'ON', brightness: 50, colorTemp: 400 },
          work: { state: 'ON', brightness: 254, colorTemp: 280 },
          evening: { state: 'ON', brightness: 150, colorTemp: 380 },
          goodnight: { state: 'OFF' }
        },

        updateLight(topic, data) {
          const light = this.list.find(l => l.topic === topic);
          if (light) {
            if (data.state !== undefined) light.state = data.state;
            if (data.brightness !== undefined) light.brightness = data.brightness;
            if (data.color_temp !== undefined) light.colorTemp = data.color_temp;
            if (data.linkquality !== undefined) light.linkquality = data.linkquality;
            light.lastSeen = Date.now();
            light.syncing = false;
            this.initializing = false;
            this.syncing = this.anyLightSyncing;
          }
        },

        setAvailability(topic, isOnline) {
          const light = this.list.find(l => l.topic === topic);
          if (light) {
            light.available = isOnline;
            console.log(`Light ${light.name} availability: ${isOnline ? 'online' : 'offline'}`);
          }
        },

        publishCommand(light, payload) {
          const client = Alpine.store('mqtt').client;
          if (!client || !Alpine.store('mqtt').connected) {
            console.error('MQTT not connected');
            return;
          }

          // Set syncing state
          light.syncing = true;
          this.syncing = true;

          const topic = `zigbee2mqtt/${light.topic}/set`;
          client.publish(topic, JSON.stringify(payload), { qos: 0 }, (err) => {
            if (err) {
              console.error('Failed to publish:', err);
              light.syncing = false;
              this.syncing = this.anyLightSyncing;
            } else {
              // Syncing will be cleared when we receive the state update
              // Set a timeout to clear syncing if no response
              setTimeout(() => {
                if (light.syncing) {
                  light.syncing = false;
                  this.syncing = this.anyLightSyncing;
                }
              }, 3000);
            }
          });
        },

        toggleLight(light) {
          const newState = light.state === 'ON' ? 'OFF' : 'ON';
          this.publishCommand(light, { state: newState });
          light.state = newState; // Optimistic update
        },

        toggleAllLights() {
          const allOn = this.list.every(l => l.state === 'ON');
          const newState = allOn ? 'OFF' : 'ON';
          this.list.forEach(light => {
            this.publishCommand(light, { state: newState });
            light.state = newState;
          });
        },

        setBrightness(light, value) {
          const brightness = parseInt(value);
          // Debounce: only publish after 150ms of no changes (for touch compatibility)
          clearTimeout(this._brightnessTimeout);
          this._brightnessTimeout = setTimeout(() => {
            this.publishCommand(light, { brightness });
          }, 150);
        },

        setColorTemp(light, value) {
          const colorTemp = parseInt(value);
          // Debounce: only publish after 150ms of no changes (for touch compatibility)
          clearTimeout(this._colorTempTimeout);
          this._colorTempTimeout = setTimeout(() => {
            this.publishCommand(light, { color_temp: colorTemp });
          }, 150);
        },

        applyPreset(light, presetName) {
          const preset = this.presets[presetName];
          if (preset) {
            this.publishCommand(light, {
              brightness: preset.brightness,
              color_temp: preset.colorTemp
            });
            light.brightness = preset.brightness;
            light.colorTemp = preset.colorTemp;
          }
        },

        applyScene(sceneName) {
          const scene = this.scenes[sceneName];
          if (scene) {
            this.list.forEach(light => {
              this.publishCommand(light, scene);
              if (scene.state !== undefined) light.state = scene.state;
              if (scene.brightness !== undefined) light.brightness = scene.brightness;
              if (scene.colorTemp !== undefined) light.colorTemp = scene.colorTemp;
            });
          }
        }
      });

      // Room detail modal store
      Alpine.store('roomDetail', {
        selectedRoom: null,
        timeRange: '6h',
        loading: false,
        tempHistory: [],
        humidHistory: [],
        timeRanges: ['15m', '30m', '1h', '3h', '6h', '12h', '24h', '3d', '7d'],

        open(room) {
          this.selectedRoom = room;
          this.timeRange = '6h';
          this.loadData();
        },

        close() {
          this.selectedRoom = null;
        },

        async setTimeRange(range) {
          this.timeRange = range;
          await this.loadData();
        },

        async loadData() {
          if (!this.selectedRoom) return;
          this.loading = true;

          try {
            const room = this.selectedRoom;

            const tempQuery = `SELECT value FROM "¬∞C" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_temperature' AND time > now() - ${this.timeRange} ORDER BY time ASC`;
            const tempUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(tempQuery)}`;
            const tempRes = await fetch(tempUrl);
            const tempData = await tempRes.json();

            if (tempData.results?.[0]?.series?.[0]?.values) {
              this.tempHistory = tempData.results[0].series[0].values.map(v => ({
                time: new Date(v[0]).getTime(),
                value: v[1]
              }));
            } else {
              this.tempHistory = [];
            }

            const humidQuery = `SELECT value FROM "%" WHERE entity_id = '${room.entityId.replace('sensor.', '')}_humidity' AND time > now() - ${this.timeRange} ORDER BY time ASC`;
            const humidUrl = `${CONFIG.influxUrl}/query?db=${CONFIG.influxDb}&q=${encodeURIComponent(humidQuery)}`;
            const humidRes = await fetch(humidUrl);
            const humidData = await humidRes.json();

            if (humidData.results?.[0]?.series?.[0]?.values) {
              this.humidHistory = humidData.results[0].series[0].values.map(v => ({
                time: new Date(v[0]).getTime(),
                value: v[1]
              }));
            } else {
              this.humidHistory = [];
            }

            console.log(`Loaded ${this.tempHistory.length} temp, ${this.humidHistory.length} humid points for ${this.timeRange}`);
          } catch (e) {
            console.error('Failed to load modal data:', e);
          }

          this.loading = false;
          setTimeout(() => this.drawCharts(), 50);
        },

        drawCharts() {
          this.drawChart('modal-chart-temp', this.tempHistory, '¬∞C', 'var(--color-primary)');
          this.drawChart('modal-chart-humid', this.humidHistory, '%', 'var(--color-success)');
        },

        drawChart(id, data, unit, color) {
          const svg = document.getElementById(id);
          if (!svg || data.length === 0) return;

          const width = svg.clientWidth || 700;
          const height = svg.clientHeight || 180;
          const padding = { top: 20, right: 50, bottom: 30, left: 50 };
          const chartWidth = width - padding.left - padding.right;
          const chartHeight = height - padding.top - padding.bottom;

          const values = data.map(d => d.value);
          const times = data.map(d => d.time);
          const minVal = Math.floor(Math.min(...values) - 1);
          const maxVal = Math.ceil(Math.max(...values) + 1);
          const minTime = Math.min(...times);
          const maxTime = Math.max(...times);
          const valueRange = maxVal - minVal || 1;
          const timeRange = maxTime - minTime || 1;

          let svgContent = '';

          const ySteps = 5;
          for (let i = 0; i <= ySteps; i++) {
            const y = padding.top + (i / ySteps) * chartHeight;
            const val = maxVal - (i / ySteps) * valueRange;
            svgContent += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="#e0e0e0" stroke-dasharray="3,3"/>`;
            svgContent += `<text x="${padding.left - 8}" y="${y + 4}" text-anchor="end" fill="var(--color-text-tertiary)" font-size="10">${val.toFixed(1)}${unit}</text>`;
          }

          const xSteps = Math.min(6, data.length);
          for (let i = 0; i <= xSteps; i++) {
            const x = padding.left + (i / xSteps) * chartWidth;
            const time = new Date(minTime + (i / xSteps) * timeRange);
            const label = time.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
            svgContent += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" stroke="#e0e0e0" stroke-dasharray="3,3"/>`;
            svgContent += `<text x="${x}" y="${height - 8}" text-anchor="middle" fill="var(--color-text-tertiary)" font-size="10">${label}</text>`;
          }

          svgContent += `<line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" stroke="var(--color-text-tertiary)"/>`;
          svgContent += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" stroke="var(--color-text-tertiary)"/>`;

          if (data.length >= 2) {
            const points = data.map(d => {
              const x = padding.left + ((d.time - minTime) / timeRange) * chartWidth;
              const y = padding.top + ((maxVal - d.value) / valueRange) * chartHeight;
              return `${x},${y}`;
            }).join(' ');

            const areaPoints = `${padding.left},${height - padding.bottom} ${points} ${width - padding.right},${height - padding.bottom}`;
            svgContent += `<polygon fill="${color}" opacity="0.15" points="${areaPoints}"/>`;
            svgContent += `<polyline fill="none" stroke="${color}" stroke-width="2.5" points="${points}"/>`;

            const lastPoint = data[data.length - 1];
            const lastX = padding.left + ((lastPoint.time - minTime) / timeRange) * chartWidth;
            const lastY = padding.top + ((maxVal - lastPoint.value) / valueRange) * chartHeight;
            svgContent += `<circle cx="${lastX}" cy="${lastY}" r="5" fill="${color}"/>`;
          }

          svg.innerHTML = svgContent;
        },

        getMinMax() {
          if (!this.tempHistory.length) return '--';
          const temps = this.tempHistory.map(d => d.value);
          return `${Math.min(...temps).toFixed(1)}¬∞ / ${Math.max(...temps).toFixed(1)}¬∞`;
        },

        formatUpdate(lastSeen) {
          if (!lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - lastSeen) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      });

      // Weather store (fetches forecast from Home Assistant via nginx proxy)
      Alpine.store('weather', {
        temperature: null,
        humidity: null,
        condition: null,
        conditionIcon: null,
        loading: false,
        lastUpdate: null,
        error: null,

        // Home Assistant API config (via nginx proxy to avoid CORS)
        entityId: 'weather.forecast_home',
        haToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkZjJhY2UwMTBmNGY0Y2NiYTI0ZGZhMGUyZjg5NWYzNiIsImlhdCI6MTc2Njg1NjU1NywiZXhwIjoyMDgyMjE2NTU3fQ.2t04JrsGafT9hDhg0BniYG90i1O7a7DHqpdst9x3-no',

        pollInterval: 5 * 60 * 1000,
        pollTimer: null,

        init() {
          console.log('Weather store: Initializing...');
          this.fetchWeather();
          this.pollTimer = setInterval(() => this.fetchWeather(), this.pollInterval);
        },

        async fetchWeather() {
          this.loading = true;
          this.error = null;

          try {
            // Use nginx proxy to avoid CORS: /api/ha/ -> homeassistant:8123/api/
            const response = await fetch(
              `/api/ha/states/${this.entityId}`,
              {
                headers: {
                  'Authorization': `Bearer ${this.haToken}`,
                  'Content-Type': 'application/json'
                }
              }
            );

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            this.temperature = data.attributes.temperature;
            this.humidity = data.attributes.humidity;
            this.condition = data.state;
            this.conditionIcon = this.getConditionIcon(data.state);
            this.lastUpdate = Date.now();
            console.log('Weather store: Updated', { temp: this.temperature, condition: this.condition });
          } catch (e) {
            console.error('Weather store: Fetch error:', e);
            this.error = e.message;
          } finally {
            this.loading = false;
          }
        },

        getConditionIcon(condition) {
          const iconMap = {
            'sunny': '‚òÄÔ∏è',
            'clear-night': 'üåô',
            'partlycloudy': '‚õÖ',
            'cloudy': '‚òÅÔ∏è',
            'rainy': 'üåßÔ∏è',
            'pouring': 'üåßÔ∏è',
            'snowy': 'üå®Ô∏è',
            'snowy-rainy': 'üå®Ô∏è',
            'fog': 'üå´Ô∏è',
            'hail': 'üå®Ô∏è',
            'lightning': '‚ö°',
            'lightning-rainy': '‚õàÔ∏è',
            'windy': 'üí®',
            'windy-variant': 'üí®',
            'exceptional': '‚ö†Ô∏è'
          };
          return iconMap[condition] || 'üå°Ô∏è';
        }
      });

      // Initialize weather store after a short delay
      setTimeout(() => Alpine.store('weather')?.init(), 2000);

      // ========================================
      // LOGS STORE
      // ========================================
      Alpine.store('logs', {
        // Data
        logs: [],
        maxLogs: 5000,
        previousState: {},

        // Anomaly thresholds
        thresholds: {
          tempDelta: 3,
          tempDeltaWindow: 600000,
          doorOpenDuration: 1800000,
          co2Warning: 1200,
          co2Critical: 1500,
          lowBattery: 20
        },

        // Filters
        filters: {
          timeRange: 'live',
          categories: [],
          devices: [],
          search: '',
          anomaliesOnly: false,
          severities: []
        },

        // UI State
        paused: false,
        loading: false,
        expandedLogId: null,

        // Categories
        categories: {
          climate: { icon: 'üå°Ô∏è', label: 'Climate', color: '#22c55e' },
          contact: { icon: 'üö™', label: 'Doors/Windows', color: '#3b82f6' },
          motion: { icon: 'üëÅÔ∏è', label: 'Motion', color: '#f59e0b' },
          thermostat: { icon: 'üî•', label: 'Thermostat', color: '#ef4444' },
          light: { icon: 'üí°', label: 'Lights', color: '#fbbf24' },
          plug: { icon: 'üîå', label: 'Plugs', color: '#8b5cf6' },
          tts: { icon: 'üîä', label: 'TTS Notifications', color: '#ec4899' },
          system: { icon: 'üì°', label: 'System', color: '#6b7280' },
          command: { icon: 'üéÆ', label: 'Commands', color: '#06b6d4' }
        },

        init() {
          const saved = localStorage.getItem('logs-thresholds');
          if (saved) {
            try { Object.assign(this.thresholds, JSON.parse(saved)); } catch (e) {}
          }
        },

        captureMessage(topic, payload) {
          if (this.paused) return;
          if (topic.includes('/bridge/')) return;

          // Handle TTS notifications specially
          if (topic === 'dashboard/tts') {
            const entry = this.createTTSLogEntry(payload);
            if (entry) {
              this.logs.unshift(entry);
              if (this.logs.length > this.maxLogs) this.logs.pop();
            }
            return;
          }

          const entry = this.createLogEntry(topic, payload);
          if (!entry) return;

          entry.isAnomaly = this.detectAnomaly(entry);
          this.logs.unshift(entry);
          if (this.logs.length > this.maxLogs) this.logs.pop();

          this.previousState[entry.device] = {
            values: { ...entry.values },
            timestamp: entry.timestamp
          };
        },

        // Create log entry for TTS notifications
        createTTSLogEntry(payload) {
          const timestamp = payload.timestamp ? new Date(payload.timestamp).getTime() : Date.now();
          const devices = payload.devices || [];
          const deviceNames = devices.map(d => d.device).join(', ');
          const availableDevices = devices.filter(d => d.available);
          const unavailableDevices = devices.filter(d => !d.available);

          // Determine severity based on success
          let severity = 'info';
          if (!payload.success) {
            severity = 'error';
          } else if (!payload.all_available) {
            severity = 'warning';
          } else {
            severity = 'success';
          }

          return {
            id: `tts-${timestamp}-${Math.random().toString(36).substr(2, 9)}`,
            timestamp,
            source: 'tts',
            topic: 'dashboard/tts',
            device: deviceNames || 'Unknown',
            category: 'tts',
            eventType: 'tts_call',
            severity,
            payload,
            values: {
              message: payload.message,
              success: payload.success,
              allAvailable: payload.all_available,
              devices: devices.length,
              availableCount: availableDevices.length,
              unavailableCount: unavailableDevices.length
            },
            roomId: 'tts',
            isAnomaly: !payload.success,
            // TTS-specific fields for display
            ttsMessage: payload.message,
            ttsDevices: devices,
            ttsSuccess: payload.success
          };
        },

        createLogEntry(topic, payload) {
          const timestamp = Date.now();
          const device = topic.replace('zigbee2mqtt/', '').replace('dashboard/', '');
          const roomId = this.extractRoomId(device);
          const category = this.detectCategory(device, payload);
          const eventType = this.detectEventType(payload);
          const severity = this.detectSeverity(payload, category);

          const values = {
            temperature: payload.temperature,
            humidity: payload.humidity,
            co2: payload.co2,
            contact: payload.contact,
            occupancy: payload.occupancy,
            battery: payload.battery,
            state: payload.state,
            linkquality: payload.linkquality,
            localTemperature: payload.local_temperature,
            targetTemperature: payload.occupied_heating_setpoint,
            runningState: payload.running_state,
            systemMode: payload.system_mode
          };

          Object.keys(values).forEach(key => {
            if (values[key] === undefined) delete values[key];
          });

          return {
            id: `${timestamp}-${Math.random().toString(36).substr(2, 9)}`,
            timestamp, source: 'mqtt', topic, device, category, eventType,
            severity, payload, values, roomId, isAnomaly: false
          };
        },

        extractRoomId(device) {
          const match = device.match(/^\[([^\]]+)\]/);
          return match ? match[1].toLowerCase() : 'unknown';
        },

        detectCategory(device, payload) {
          if (payload.local_temperature !== undefined || payload.running_state !== undefined ||
              device.toLowerCase().includes('thermostat')) return 'thermostat';
          if (payload.contact !== undefined) return 'contact';
          if (payload.occupancy !== undefined) return 'motion';
          if (payload.co2 !== undefined) return 'climate';
          if (payload.brightness !== undefined || device.toLowerCase().includes('light')) return 'light';
          if (device.toLowerCase().includes('plug') ||
              (payload.state !== undefined && !payload.brightness && !payload.temperature)) return 'plug';
          if (payload.temperature !== undefined || payload.humidity !== undefined) return 'climate';
          if (payload.state === 'online' || payload.state === 'offline') return 'system';
          if (device.startsWith('audit/')) return 'command';
          return 'system';
        },

        detectEventType(payload) {
          if (payload.state === 'online' || payload.state === 'offline') return 'availability';
          if (payload.state === 'ON' || payload.state === 'OFF') return 'state_change';
          if (payload.contact !== undefined) return 'state_change';
          if (payload.occupancy !== undefined) return 'state_change';
          if (payload.running_state !== undefined) return 'state_change';
          return 'reading';
        },

        detectSeverity(payload, category) {
          if (payload.state === 'offline') return 'error';
          if (payload.battery !== undefined && payload.battery < 10) return 'error';
          if (payload.battery !== undefined && payload.battery < this.thresholds.lowBattery) return 'warning';
          if (payload.co2 !== undefined && payload.co2 >= this.thresholds.co2Critical) return 'error';
          if (payload.co2 !== undefined && payload.co2 >= this.thresholds.co2Warning) return 'warning';
          if (payload.contact === false) return 'warning';
          if (payload.state === 'online') return 'success';
          return 'info';
        },

        detectAnomaly(entry) {
          if (entry.severity === 'error') return true;
          if (entry.values.temperature !== undefined) {
            const prev = this.previousState[entry.device];
            if (prev && prev.values.temperature !== undefined) {
              const delta = Math.abs(entry.values.temperature - prev.values.temperature);
              const timeDiff = entry.timestamp - prev.timestamp;
              if (delta >= this.thresholds.tempDelta && timeDiff <= this.thresholds.tempDeltaWindow) return true;
            }
          }
          if (entry.values.co2 !== undefined && entry.values.co2 >= this.thresholds.co2Critical) return true;
          if (entry.values.battery !== undefined && entry.values.battery < this.thresholds.lowBattery) return true;
          return false;
        },

        get filteredLogs() {
          let result = this.logs;
          if (this.filters.timeRange !== 'live') {
            const now = Date.now();
            const hours = { '1h': 1, '6h': 6, '24h': 24 }[this.filters.timeRange] || 24;
            const cutoff = now - (hours * 60 * 60 * 1000);
            result = result.filter(log => log.timestamp >= cutoff);
          }
          if (this.filters.categories.length > 0) {
            result = result.filter(log => this.filters.categories.includes(log.category));
          }
          if (this.filters.devices.length > 0) {
            result = result.filter(log => this.filters.devices.includes(log.device));
          }
          if (this.filters.severities.length > 0) {
            result = result.filter(log => this.filters.severities.includes(log.severity));
          }
          if (this.filters.anomaliesOnly) {
            result = result.filter(log => log.isAnomaly);
          }
          if (this.filters.search) {
            const search = this.filters.search.toLowerCase();
            result = result.filter(log =>
              log.device.toLowerCase().includes(search) ||
              log.topic.toLowerCase().includes(search) ||
              JSON.stringify(log.values).toLowerCase().includes(search)
            );
          }
          return result;
        },

        get stats() {
          const logs = this.filteredLogs;
          const now = Date.now();
          const oneHourAgo = now - 3600000;

          const byCategory = {};
          Object.keys(this.categories).forEach(cat => byCategory[cat] = 0);
          logs.forEach(log => { if (byCategory[log.category] !== undefined) byCategory[log.category]++; });

          const byDevice = {};
          logs.forEach(log => { byDevice[log.device] = (byDevice[log.device] || 0) + 1; });
          const topDevices = Object.entries(byDevice).sort((a, b) => b[1] - a[1]).slice(0, 5);

          const hourlyBuckets = Array(6).fill(0);
          logs.forEach(log => {
            const hoursAgo = Math.floor((now - log.timestamp) / 3600000);
            if (hoursAgo < 6) hourlyBuckets[hoursAgo]++;
          });

          return {
            total: logs.length,
            lastHour: logs.filter(log => log.timestamp >= oneHourAgo).length,
            byCategory, topDevices,
            hourlyBuckets: hourlyBuckets.reverse(),
            errors: logs.filter(log => log.severity === 'error').length,
            warnings: logs.filter(log => log.severity === 'warning').length,
            anomalies: logs.filter(log => log.isAnomaly).length
          };
        },

        get availableDevices() {
          return [...new Set(this.logs.map(log => log.device))].sort();
        },

        toggleCategory(category) {
          const idx = this.filters.categories.indexOf(category);
          if (idx === -1) this.filters.categories.push(category);
          else this.filters.categories.splice(idx, 1);
        },

        toggleSeverity(severity) {
          const idx = this.filters.severities.indexOf(severity);
          if (idx === -1) this.filters.severities.push(severity);
          else this.filters.severities.splice(idx, 1);
        },

        setTimeRange(range) { this.filters.timeRange = range; },
        setSearch(query) { this.filters.search = query; },

        clearFilters() {
          this.filters = { timeRange: 'live', categories: [], devices: [], search: '', anomaliesOnly: false, severities: [] };
        },

        clearLogs() { this.logs = []; this.previousState = {}; },
        togglePause() { this.paused = !this.paused; },
        expandLog(id) { this.expandedLogId = this.expandedLogId === id ? null : id; },

        formatTime(timestamp) {
          const date = new Date(timestamp);
          const now = new Date();
          if (date.toDateString() === now.toDateString()) {
            return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          }
          return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
        },

        formatRelativeTime(timestamp) {
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return 'just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          return `${Math.floor(seconds / 86400)}d ago`;
        },

        getSeverityColor(severity) {
          return { error: '#ef4444', warning: '#f59e0b', info: '#3b82f6', success: '#22c55e' }[severity] || '#3b82f6';
        },

        formatValues(values) {
          const parts = [];
          // TTS-specific formatting
          if (values.message !== undefined) {
            const msg = values.message.length > 50 ? values.message.substring(0, 50) + '...' : values.message;
            parts.push(`"${msg}"`);
          }
          if (values.success !== undefined) {
            parts.push(values.success ? '‚úÖ Sent' : '‚ùå Failed');
          }
          if (values.devices !== undefined && values.availableCount !== undefined) {
            parts.push(`${values.availableCount}/${values.devices} devices`);
          }
          // Standard sensor values
          if (values.temperature !== undefined) parts.push(`${values.temperature.toFixed(1)}¬∞C`);
          if (values.humidity !== undefined) parts.push(`${values.humidity}%`);
          if (values.co2 !== undefined) parts.push(`${values.co2}ppm`);
          if (values.battery !== undefined) parts.push(`üîã${values.battery}%`);
          if (values.contact !== undefined) parts.push(values.contact ? 'closed' : 'open');
          if (values.occupancy !== undefined) parts.push(values.occupancy ? 'motion' : 'clear');
          if (values.state !== undefined) parts.push(values.state);
          if (values.runningState !== undefined) parts.push(values.runningState);
          if (values.targetTemperature !== undefined) parts.push(`‚Üí${values.targetTemperature}¬∞C`);
          if (values.linkquality !== undefined) parts.push(`üì∂${values.linkquality}`);
          return parts.join(' | ') || 'no values';
        }
      });

      // Initialize logs store
      Alpine.store('logs')?.init();

      // Store validation - warn if critical stores are missing
      setTimeout(() => {
        const criticalStores = ['mqtt', 'rooms', 'sensors', 'events', 'thermostats', 'lights'];
        const missingStores = criticalStores.filter(name => !Alpine.store(name));
        if (missingStores.length > 0) {
          console.error(`[CRITICAL] Missing stores: ${missingStores.join(', ')}`);
          console.error('[CRITICAL] Door/window status will not display correctly!');
        } else {
          console.log('[stores] All critical stores registered successfully');
        }
      }, 3000);
    });

    // ========================================
    // MAIN APP COMPONENT
    // ========================================
    function app() {
      return {
        currentView: 'classic',
        currentDateTime: '',
        now: Date.now(),
        panelOpen: localStorage.getItem('panel-open') !== 'false',

        get lastUpdateText() {
          const lastUpdate = Alpine.store('rooms').lastUpdate;
          if (!lastUpdate) return 'Waiting...';
          const seconds = Math.floor((this.now - lastUpdate) / 1000);
          if (seconds < 5) return 'Just now';
          if (seconds < 60) return `${seconds}s ago`;
          return `${Math.floor(seconds / 60)}m ago`;
        },

        init() {
          // Restore last view
          const saved = localStorage.getItem('dashboard-view');
          if (saved) this.currentView = saved;

          // Update time
          this.updateDateTime();
          setInterval(() => {
            this.updateDateTime();
            this.now = Date.now();
          }, 1000);

          // Check stale
          setInterval(() => Alpine.store('rooms').checkStale(), 10000);

          // Load historical data and connect MQTT
          Alpine.store('rooms').loadHistorical();
          Alpine.store('mqtt').connect();

          // Keyboard shortcuts are now handled by navigation component (single source)
          // Listen for view changes from navigation component
          document.addEventListener('view-changed', (e) => {
            if (e.detail && e.detail.view) {
              this.currentView = e.detail.view;
            }
          });

          // Request browser notification permission on first user interaction
          // This enables device offline alerts to show as push notifications
          const requestNotificationPermission = () => {
            if ('Notification' in window && Notification.permission === 'default') {
              Notification.requestPermission().then(permission => {
                console.log(`[app] Notification permission: ${permission}`);
              });
            }
            // Only request once
            document.removeEventListener('click', requestNotificationPermission);
          };
          document.addEventListener('click', requestNotificationPermission, { once: true });

          // Check panel overflow and toggle compact mode
          this.checkPanelOverflow();
          // Re-check on window resize
          window.addEventListener('resize', () => this.checkPanelOverflow());
          // Re-check when data changes (via mutation observer on panel content)
          const panelContent = document.querySelector('.panel-content');
          if (panelContent) {
            const observer = new MutationObserver(() => {
              requestAnimationFrame(() => this.checkPanelOverflow());
            });
            observer.observe(panelContent, { childList: true, subtree: true, characterData: true });
          }
        },

        // Check if panel content overflows and toggle compact mode
        checkPanelOverflow() {
          const panel = document.querySelector('.panel-content');
          if (!panel) return;

          // First, remove compact mode to measure natural height
          panel.classList.remove('compact-mode');

          // Wait for reflow
          requestAnimationFrame(() => {
            const hasOverflow = panel.scrollHeight > panel.clientHeight;
            if (hasOverflow) {
              panel.classList.add('compact-mode');
            }
          });
        },

        setView(view) {
          this.currentView = view;
          localStorage.setItem('dashboard-view', view);
        },

        updateDateTime() {
          const now = new Date();
          this.currentDateTime = now.toLocaleDateString('en-AU', {
            weekday: 'short', month: 'short', day: 'numeric',
            hour: 'numeric', minute: '2-digit', hour12: true
          });
        },

        togglePanel() {
          this.panelOpen = !this.panelOpen;
          localStorage.setItem('panel-open', this.panelOpen);
        },

        // Floor plan temperature helpers (split for styling)
        getRoomTempInt(roomId) {
          const room = Alpine.store('rooms').list.find(r => r.id === roomId);
          if (!room) return '--';
          const temp = room.avgTemperature ?? room.temperature;
          if (temp == null) return '--';
          return Math.floor(temp).toString();
        },
        getRoomTempDec(roomId) {
          const room = Alpine.store('rooms').list.find(r => r.id === roomId);
          if (!room) return '¬∞';
          const temp = room.avgTemperature ?? room.temperature;
          if (temp == null) return '¬∞';
          const decimal = (temp % 1).toFixed(1).substring(1); // ".X"
          return decimal + '¬∞';
        },
        // Keep original for backwards compatibility
        getRoomTemp(roomId) {
          const room = Alpine.store('rooms').list.find(r => r.id === roomId);
          if (!room) return '--¬∞';
          const temp = room.avgTemperature ?? room.temperature;
          if (temp == null) return '--¬∞';
          return temp.toFixed(1) + '¬∞';
        },

        // Get temperature color class for floor plan
        getRoomTempClass(roomId) {
          const room = Alpine.store('rooms').list.find(r => r.id === roomId);
          const temp = room?.avgTemperature ?? room?.temperature;
          if (temp == null) return '';
          if (temp < 18) return 'floor-temp-cold';
          if (temp < 20) return 'floor-temp-cool';
          if (temp < 23) return 'floor-temp-comfortable';
          if (temp < 26) return 'floor-temp-warm';
          return 'floor-temp-hot';
        },

        getOpenContactCount() {
          const contacts = Alpine.store('sensors')?.sensorsByType?.contact || [];
          const liveData = Alpine.store('sensors')?.liveData || {};
          return contacts.filter(s => liveData[s.ieee_address]?.contact === false).length;
        },

        // Check if a contact sensor is a door (vs window)
        isDoor(friendlyName) {
          return friendlyName.toLowerCase().includes('door');
        },

        // Get all open contact sensors
        getOpenContacts() {
          const contacts = Alpine.store('sensors')?.sensorsByType?.contact || [];
          const liveData = Alpine.store('sensors')?.liveData || {};
          return contacts.filter(s => liveData[s.ieee_address]?.contact === false);
        },

        // Get open doors only
        getOpenDoors() {
          return this.getOpenContacts().filter(s => this.isDoor(s.friendly_name));
        },

        // Get open windows only
        getOpenWindows() {
          return this.getOpenContacts().filter(s => !this.isDoor(s.friendly_name));
        },

        // Get count of open doors
        getDoorCount() {
          return this.getOpenDoors().length;
        },

        // Get count of open windows
        getWindowCount() {
          return this.getOpenWindows().length;
        },

        // Short names for contact sensors in sidebar
        contactShortNames: {
          '[Bath] Window Contact Sensor': 'Bath Window',
          '[Bed] Window Contact Sensor': 'Bed Window',
          '[Kitchen] Window Contact Sensor': 'Kitchen Window',
          '[Study] Window Contact Sensor - Large': 'Study Big',
          '[Study] Window Contact Sensor - Small': 'Study Small',
          '[Living] Window Contact Sensor - Balcony Door': 'Balcony Door',
          '[Living] Window Contact Sensor - Window': 'Living Window',
          '[Hallway] Window Contact Sensor - Main Door': 'Main Door'
        },

        getContactShortName(friendlyName) {
          return this.contactShortNames[friendlyName] || friendlyName.replace(/\[|\]/g, '').trim();
        }
      };
    }

    // ========================================
    // NAVIGATION COMPONENT (Grouped with More Dropdown)
    // ========================================
    const VIEW_CATEGORIES = [
      {
        id: 'monitor', name: 'Monitor', icon: 'üìà',
        views: [
          { id: 'timeline', name: 'Timeline', icon: 'üìñ', title: 'Event Timeline', key: '5' },
          { id: 'co2', name: 'CO2', icon: 'üí®', title: 'CO2 Monitor', key: '0' },
          { id: 'logs', name: 'Logs', icon: 'üìã', title: 'Activity Logs', key: 'L' }
        ]
      },
      {
        id: 'visualize', name: 'Visualize', icon: 'üëÅÔ∏è',
        views: [
          { id: 'network', name: 'Network', icon: 'üì°', title: 'Zigbee Network', key: 'N' }
        ]
      },
      {
        id: 'control', name: 'Control', icon: 'üéõÔ∏è',
        views: [
          { id: 'lights', name: 'Lights', icon: 'üí°', title: 'Light Control', key: '7', primary: true },
          { id: 'heater', name: 'Heater', icon: 'üî•', title: 'Heater Control', key: 'H' },
          { id: 'mailbox', name: 'Mailbox', icon: 'üì¨', title: 'Mailbox Monitor', key: 'M' }
        ]
      },
      {
        id: 'display', name: 'Display', icon: 'üì∫',
        views: [
          { id: 'classic', name: 'Classic', icon: 'üÉè', title: 'Classic Cards', key: '8' }
        ]
      }
    ];

    // Classic first per user preference
    const ALL_VIEWS = (() => {
      const all = VIEW_CATEGORIES.flatMap(cat => cat.views);
      const classic = all.find(v => v.id === 'classic');
      return classic ? [classic, ...all.filter(v => v.id !== 'classic')] : all;
    })();
    const PRIMARY_VIEWS = ALL_VIEWS.filter(v => v.primary);
    const OVERFLOW_CATEGORIES = VIEW_CATEGORIES.map(cat => ({
      ...cat,
      views: cat.views.filter(v => !v.primary)
    })).filter(cat => cat.views.length > 0);
    const KEYBOARD_SHORTCUTS = Object.fromEntries(ALL_VIEWS.map(v => [v.key, v.id]));

    function navigation() {
      return {
        moreMenuOpen: false,
        mobileMenuOpen: false,
        currentView: 'classic',
        primaryViews: PRIMARY_VIEWS,
        overflowCategories: OVERFLOW_CATEGORIES,
        allViews: ALL_VIEWS,

        init() {
          // Restore last view from localStorage
          const saved = localStorage.getItem('dashboard-view');
          if (saved && ALL_VIEWS.find(v => v.id === saved)) {
            this.currentView = saved;
          }

          // Sync with app component
          const appEl = document.querySelector('[x-data="app()"]');
          if (appEl && appEl._x_dataStack && appEl._x_dataStack[0]) {
            this.currentView = appEl._x_dataStack[0].currentView || this.currentView;
          }
          // Keyboard shortcuts handled via @keydown.window Alpine directive
        },

        handleKeydown(e) {
          // Ignore if typing in an input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          if (e.ctrlKey || e.metaKey) return;

          const key = e.key.toUpperCase();
          // Letter shortcuts (I, N, H, M)
          if (KEYBOARD_SHORTCUTS[key]) {
            e.preventDefault();
            this.setView(KEYBOARD_SHORTCUTS[key]);
            return;
          }
          // Number shortcuts (1-9, 0)
          if (KEYBOARD_SHORTCUTS[e.key]) {
            e.preventDefault();
            this.setView(KEYBOARD_SHORTCUTS[e.key]);
            return;
          }
        },

        setView(viewId) {
          if (this.currentView !== viewId) {
            this.currentView = viewId;
            localStorage.setItem('dashboard-view', viewId);
            // Sync with app component
            const appEl = document.querySelector('[x-data="app()"]');
            if (appEl && appEl._x_dataStack && appEl._x_dataStack[0]) {
              appEl._x_dataStack[0].currentView = viewId;
            }
          }
          this.moreMenuOpen = false;
          this.mobileMenuOpen = false;
        },

        isActive(viewId) {
          return this.currentView === viewId;
        },

        isOverflowActive() {
          return !PRIMARY_VIEWS.find(v => v.id === this.currentView) &&
                 ALL_VIEWS.find(v => v.id === this.currentView);
        },

        toggleMoreMenu() {
          this.moreMenuOpen = !this.moreMenuOpen;
          this.mobileMenuOpen = false;
        },

        toggleMobileMenu() {
          this.mobileMenuOpen = !this.mobileMenuOpen;
          this.moreMenuOpen = false;
        }
      };
    }

    // ========================================
    // TIMELINE VIEW (Vision 5)
    // ========================================
    function timelineView() {
      return {
        events: [],
        selectedDate: 'today',
        loading: false,

        init() {
          this.loadEvents();
          this.$watch('$store.rooms.list', () => this.loadEvents());
        },

        loadEvents() {
          this.loading = true;
          const rooms = this.$store.rooms.list;
          const allEvents = [];

          const now = Date.now();
          let startTime;
          if (this.selectedDate === 'yesterday') {
            const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); yesterday.setHours(0, 0, 0, 0);
            startTime = yesterday.getTime();
          } else if (this.selectedDate === 'week') {
            startTime = now - 7 * 24 * 60 * 60 * 1000;
          } else {
            const today = new Date(); today.setHours(0, 0, 0, 0);
            startTime = today.getTime();
          }

          rooms.forEach(room => {
            if (room.tempHistory && room.tempHistory.length > 0) {
              const filtered = room.tempHistory.filter(h => h.time >= startTime);
              allEvents.push(...this.detectEvents(filtered, room.name, room.icon));
            }
          });

          this.events = allEvents.sort((a, b) => b.time - a.time).slice(0, 20);
          this.loading = false;
        },

        detectEvents(history, roomName, roomIcon) {
          if (history.length < 10) return [];
          const events = [];
          const sorted = [...history].sort((a, b) => a.time - b.time);

          // Detect rapid changes
          for (let i = 0; i < sorted.length - 1; i++) {
            const windowMs = 30 * 60 * 1000;
            const start = sorted[i];
            const endIdx = sorted.findIndex(p => p.time >= start.time + windowMs && p.time <= start.time + windowMs * 1.2);
            if (endIdx === -1) continue;

            const end = sorted[endIdx];
            const delta = end.value - start.value;

            if (Math.abs(delta) >= 3) {
              events.push({
                type: delta > 0 ? 'RAPID_RISE' : 'RAPID_DROP',
                time: start.time, room: roomName, icon: roomIcon,
                value: start.value, endValue: end.value, delta: Math.abs(delta),
                duration: Math.round((end.time - start.time) / 60000),
                eventIcon: delta > 0 ? 'üî•' : '‚ùÑÔ∏è',
                title: `${roomName} ${delta > 0 ? 'rose' : 'dropped'} ${Math.abs(delta).toFixed(1)}¬∞ in ${Math.round((end.time - start.time) / 60000)} mins`,
                cause: this.inferCause(delta > 0 ? 'RAPID_RISE' : 'RAPID_DROP', roomName, start.time)
              });
            }
          }

          // Detect peaks
          const windowSize = 6;
          for (let i = windowSize; i < sorted.length - windowSize; i++) {
            const point = sorted[i];
            const before = sorted.slice(i - windowSize, i);
            const after = sorted.slice(i + 1, i + windowSize + 1);
            const maxBefore = Math.max(...before.map(p => p.value));
            const maxAfter = Math.max(...after.map(p => p.value));

            if (point.value > maxBefore && point.value > maxAfter && point.value - Math.min(maxBefore, maxAfter) >= 2) {
              events.push({
                type: 'PEAK', time: point.time, room: roomName, icon: roomIcon,
                value: point.value, eventIcon: 'üìà',
                title: `${roomName} peaked at ${point.value.toFixed(1)}¬∞`,
                cause: this.inferCause('PEAK', roomName, point.time)
              });
            }
          }

          return events;
        },

        inferCause(type, roomName, time) {
          const hour = new Date(time).getHours();
          const room = roomName.toLowerCase();

          if (room.includes('bathroom') && type === 'PEAK' && hour >= 6 && hour <= 9)
            return { text: 'Morning shower' };
          if (room.includes('kitchen') && type === 'RAPID_RISE' && hour >= 18 && hour <= 21)
            return { text: 'Cooking dinner' };
          if (type === 'RAPID_RISE' && hour >= 10 && hour <= 15)
            return { text: 'Sun exposure' };
          return null;
        },

        setDate(date) { this.selectedDate = date; this.loadEvents(); },

        formatTime(timestamp) {
          return new Date(timestamp).toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit' });
        },

        getEventClass(type) {
          return { 'PEAK': 'event-peak', 'VALLEY': 'event-valley', 'RAPID_RISE': 'event-rise', 'RAPID_DROP': 'event-drop' }[type] || '';
        },

        getTodaySummary() {
          const rooms = this.$store.rooms.list.filter(r => r.tempHistory && r.tempHistory.length > 0);
          if (rooms.length === 0) return null;

          const today = new Date(); today.setHours(0, 0, 0, 0);
          let allTemps = [], mostStable = null, minVar = Infinity, mostVolatile = null, maxVar = 0;

          rooms.forEach(room => {
            const todayHistory = room.tempHistory.filter(h => h.time >= today.getTime());
            if (todayHistory.length < 2) return;
            const temps = todayHistory.map(h => h.value);
            allTemps.push(...temps);
            const variation = Math.max(...temps) - Math.min(...temps);
            if (variation < minVar) { minVar = variation; mostStable = room.name; }
            if (variation > maxVar) { maxVar = variation; mostVolatile = room.name; }
          });

          if (allTemps.length === 0) return null;
          return {
            minTemp: Math.min(...allTemps).toFixed(1),
            maxTemp: Math.max(...allTemps).toFixed(1),
            mostStable, mostVolatile,
            eventCount: this.events.length
          };
        },

        openRoom(roomName) {
          const room = this.$store.rooms.list.find(r => r.name === roomName);
          if (room) this.$store.roomDetail.open(room);
        }
      };
    }

    // ========================================
    // VISION 6: CLASSIC CARDS VIEW
    // ========================================
    function classicView() {
      return {
        sparklineUpdateInterval: null,

        get rooms() {
          return this.$store.rooms.list;
        },

        get avgTemperature() {
          return this.$store.rooms.avgTemperature;
        },

        get avgHumidity() {
          return this.$store.rooms.avgHumidity;
        },

        init() {
          // Initial sparkline render
          this.$nextTick(() => this.updateSparklines());

          // Update sparklines every 5 seconds
          this.sparklineUpdateInterval = setInterval(() => this.updateSparklines(), 5000);

          // Watch for room changes
          this.$watch('$store.rooms.list', () => {
            this.$nextTick(() => this.updateSparklines());
          });
        },

        destroy() {
          if (this.sparklineUpdateInterval) {
            clearInterval(this.sparklineUpdateInterval);
          }
        },

        isStale(room) {
          if (!room.lastSeen) return true;
          return Date.now() - room.lastSeen > 5 * 60 * 1000;
        },

        getComfortClass(temp) {
          if (temp === null || temp === undefined) return '';
          if (temp < 20) return 'cold';
          if (temp < 23) return 'cool';
          if (temp <= 26) return 'good';
          if (temp <= 28) return 'warm';
          return 'hot';
        },

        formatUpdate(lastSeen) {
          if (!lastSeen) return 'No data';
          const seconds = Math.floor((Date.now() - lastSeen) / 1000);
          if (seconds < 5) return 'Just now';
          if (seconds < 60) return `${seconds}s ago`;
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return `${minutes}m ago`;
          const hours = Math.floor(minutes / 60);
          return `${hours}h ${minutes % 60}m ago`;
        },

        openRoom(room) {
          this.$store.roomDetail.open(room);
        },

        updateSparklines() {
          // Update room sparklines
          this.rooms.forEach(room => {
            const svg = document.getElementById(`classic-spark-${room.id}`);
            if (svg && room.tempHistory && room.tempHistory.length > 1) {
              this.drawSparkline(svg, room.tempHistory.slice(-50));
            }
          });

          // Update average sparkline
          const avgSvg = document.getElementById('classic-spark-avg');
          const avgHistory = this.$store.rooms.avgHistory;
          if (avgSvg && avgHistory && avgHistory.length > 1) {
            this.drawSparkline(avgSvg, avgHistory.slice(-50), true);
          }
        },

        drawSparkline(svg, data, isDark = false) {
          const width = svg.clientWidth || 200;
          const height = svg.clientHeight || 40;

          if (data.length < 2 || width === 0) return;

          const values = data.map(d => d.value);
          const min = Math.min(...values);
          const max = Math.max(...values);
          const range = max - min || 1;

          const points = data.map((d, i) => {
            const x = (i / (data.length - 1)) * width;
            const y = height - ((d.value - min) / range) * (height - 4) - 2;
            return `${x},${y}`;
          }).join(' ');

          const lineColor = isDark ? 'rgba(255,255,255,0.8)' : 'var(--color-primary)';
          const areaColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0, 122, 255, 0.1)';

          svg.innerHTML = `
            <polyline
              points="${points}"
              fill="none"
              stroke="${lineColor}"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <polygon
              points="0,${height} ${points} ${width},${height}"
              fill="${areaColor}"
            />
          `;
        }
      };
    }

    // ========================================
    // VISION 7: LIGHTS CONTROL VIEW
    // ========================================
    function lightsView() {
      return {
        // Helper function for color temperature label
        getColorTempLabel(colorTemp) {
          if (colorTemp <= 280) return 'Cool White';
          if (colorTemp <= 350) return 'Neutral';
          if (colorTemp <= 400) return 'Warm White';
          return 'Warm';
        },

        // Helper function for last update formatting
        formatLastUpdate(timestamp) {
          if (!timestamp) return 'No data';
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return 'Just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          return `${Math.floor(seconds / 3600)}h ago`;
        }
      };
    }

    // ========================================
    // ZIGBEE NETWORK VIEW
    // Warm beige monochromatic visualization
    // ========================================

    const networkState = {
      scene: null,
      camera: null,
      renderer: null,
      roomMeshes: {},
      wallMeshes: [],
      wallNumberSprites: [],
      deviceMeshes: {},
      labelElements: {},
      signalElements: {},
      animationId: null,
      isInitialized: false,
      panOffset: { x: 0, z: 0 },
      isPanning: false,
      lastPanPos: { x: 0, y: 0 }
    };

    // Device configuration with types and icons
    const ZIGBEE_DEVICES = [
      { id: 'coordinator', name: 'ZBBridge-P', type: 'coordinator', icon: 'üì°', room: 'living', x: 0.5, z: 0.4 },
      { id: 'router1', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'study', x: 0.8, z: 0.2 },
      { id: 'router2', name: 'S60ZBTPF', type: 'router', icon: 'üì¢', room: 'living', x: 0.3, z: 0.3 },
      { id: 'sensor1', name: 'SNZB-02P', type: 'end-device', icon: 'üå°Ô∏è', room: 'bedroom', x: 0.2, z: 0.15 },
      { id: 'sensor2', name: 'SNZB-03P', type: 'end-device', icon: 'üö∂', room: 'kitchen', x: 0.5, z: 0.1 },
      { id: 'sensor3', name: 'SNZB-04P', type: 'end-device', icon: 'üö™', room: 'bathroom', x: 0.85, z: 0.1 },
      { id: 'trv', name: 'TRVZB', type: 'end-device', icon: 'üî•', room: 'bedroom', x: 0.1, z: 0.25 },
    ];

    function networkView() {
      const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
      const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

      return {
        showSignalRange: false,
        showLabels: false,
        showWallNumbers: false,
        autoRotate: false,
        rotationAngle: 0,
        zoomLevel: 2.0,
        deviceCount: ZIGBEE_DEVICES.length,
        routerCount: ZIGBEE_DEVICES.filter(d => d.type === 'router').length,
        endDeviceCount: ZIGBEE_DEVICES.filter(d => d.type === 'end-device').length,

        init() {
          this.waitForContainer();
        },

        waitForContainer() {
          const container = this.$refs.networkContainer;
          if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
            setTimeout(() => this.waitForContainer(), 100);
            return;
          }

          if (networkState.isInitialized && networkState.renderer) {
            if (!container.contains(networkState.renderer.domElement)) {
              container.appendChild(networkState.renderer.domElement);
            }
            this.createLabels(container);
            this.onResize();
            return;
          }

          if (networkState.renderer) networkState.renderer.dispose();
          if (networkState.scene) networkState.scene.clear();
          if (networkState.animationId) cancelAnimationFrame(networkState.animationId);

          this.initScene();
          this.initCamera(container);
          this.initRenderer(container);
          this.initLighting();
          this.buildFloorPlan();
          this.addWallNumbers();
          this.createDevices();
          this.createLabels(container);
          this.setupPanControls(container);
          this.animate();
          networkState.isInitialized = true;

          window.addEventListener('resize', () => this.onResize());
        },

        initScene() {
          networkState.scene = new THREE.Scene();
          // Warm beige gradient background
          networkState.scene.background = new THREE.Color(0xE8DFD4);
        },

        initCamera(container) {
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15;
          networkState.camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2, 0.1, 1000
          );
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
        },

        initRenderer(container) {
          networkState.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
          networkState.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          networkState.renderer.shadowMap.enabled = true;
          networkState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          container.appendChild(networkState.renderer.domElement);
        },

        initLighting() {
          const ambient = new THREE.AmbientLight(0xffffff, 0.7);
          networkState.scene.add(ambient);
          const directional = new THREE.DirectionalLight(0xffffff, 0.6);
          directional.position.set(15, 20, 15);
          directional.castShadow = false;  // No shadows anywhere
          networkState.scene.add(directional);
          const fill = new THREE.DirectionalLight(0xffffff, 0.3);
          fill.position.set(-10, 10, -10);
          networkState.scene.add(fill);
        },

        addWallNumbers() {
          // Clear existing wall number sprites
          networkState.wallNumberSprites.forEach(sprite => {
            networkState.scene.remove(sprite);
            if (sprite.material.map) sprite.material.map.dispose();
            sprite.material.dispose();
          });
          networkState.wallNumberSprites = [];

          // Add number labels at start, middle, end of each wall for precise identification
          const createNumberSprite = (text, color = '#FF0000') => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(String(text), 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(0.4, 0.4, 1);
            return sprite;
          };

          // Direction labels by POSITION (reliable regardless of wall creation order)
          // Outer walls are identified by: edge position + full length
          const getOuterWallDirection = (wall) => {
            const apartmentWidth = FLOOR_PLAN_CONFIG.apartmentWidth;   // 9.239
            const apartmentDepth = FLOOR_PLAN_CONFIG.apartmentDepth;   // 7.665
            const halfW = apartmentWidth / 2;  // 4.6195
            const halfD = apartmentDepth / 2;  // 3.8325
            const tolerance = 0.05;  // Position tolerance (5cm) - outer walls are at exact edges
            const lengthTolerance = 0.2;  // Length must be within 20cm of full apartment dimension

            const params = wall.geometry.parameters;
            const isHorizontal = params.width > params.depth;  // Runs along X axis
            const isVertical = params.depth > params.width;    // Runs along Z axis

            let result = null;

            // Check for full-length horizontal walls (North/South)
            // In isometric view: z=-halfD appears at TOP (North), z=+halfD at BOTTOM (South)
            if (isHorizontal && Math.abs(params.width - apartmentWidth) < lengthTolerance) {
              if (Math.abs(wall.position.z - (-halfD)) < tolerance) result = 'N';  // Top edge
              else if (Math.abs(wall.position.z - halfD) < tolerance) result = 'S';  // Bottom edge
            }

            // Check for full-length vertical walls (West/East)
            // In isometric view: x=-halfW appears at LEFT (West), x=+halfW at RIGHT (East)
            if (isVertical && Math.abs(params.depth - apartmentDepth) < lengthTolerance) {
              if (Math.abs(wall.position.x - (-halfW)) < tolerance) result = 'W';  // Left edge
              else if (Math.abs(wall.position.x - halfW) < tolerance) result = 'E';  // Right edge
            }

            return result;
          };

          networkState.wallMeshes.forEach((wall, index) => {
            const geom = wall.geometry;
            const params = geom.parameters;
            const wx = wall.position.x;
            const wy = wall.position.y + 0.5;
            const wz = wall.position.z;

            // Check if this is an outer wall with direction label (by position)
            const directionLabel = getOuterWallDirection(wall);

            // Determine if wall is horizontal (along X) or vertical (along Z)
            const isHorizontal = params.width > params.depth;
            const wallLength = isHorizontal ? params.width : params.depth;
            const halfLen = wallLength / 2 * 0.8; // 80% to stay within wall bounds

            // Create 3 sprites: start, middle, end
            const positions = isHorizontal
              ? [[wx - halfLen, wy, wz], [wx, wy, wz], [wx + halfLen, wy, wz]]
              : [[wx, wy, wz - halfLen], [wx, wy, wz], [wx, wy, wz + halfLen]];

            positions.forEach((pos, i) => {
              // Use direction label (N/S/E/W) for outer walls, index number for inner walls
              const label = directionLabel || index.toString();
              // Green for direction labels, Red/Blue for numbered walls
              const color = directionLabel ? '#228B22' : (i === 1 ? '#FF0000' : '#0066CC');
              const sprite = createNumberSprite(label, color);
              sprite.position.set(pos[0], pos[1], pos[2]);
              sprite.visible = false;  // Hidden by default
              networkState.scene.add(sprite);
              networkState.wallNumberSprites.push(sprite);
            });
          });
        },

        toggleWallNumbers() {
          this.showWallNumbers = !this.showWallNumbers;
          networkState.wallNumberSprites.forEach(sprite => {
            sprite.visible = this.showWallNumbers;
          });
        },

        /**
         * WALL INDEX REFERENCE (Fully consolidated walls)
         * =================================================
         * Walls are pushed to networkState.wallMeshes in this EXACT order:
         *
         * FIRST: Room walls via createRoom() for each room in config order:
         *   Study:    0=left (back‚Üínorth wall, front skipped, right‚Üíeast wall)
         *   Living:   (none - all consolidated)
         *   Bedroom:  1=right divider (back skipped, left‚Üíwest wall, front‚Üísouth wall)
         *   Kitchen:  (none - all consolidated)
         *   Bathroom: 2=front (back‚Üínorth wall, left‚Üíwest wall, right‚Üíeast wall)
         *
         * THEN: Consolidated walls created in buildFloorPlan():
         *   3 = Study‚ÜîLiving horizontal divider
         *   4 = Coat hanging wall (hallway, 30% from north)
         *   5 = North wall (z=0, full apartment width)
         *   6 = West wall (x=0, full apartment depth)
         *   7 = East wall upper (Bathroom+Kitchen right, z=0 to z=3.697)
         *   8 = East wall lower (Study+Living right, z=0 to z=7.665)
         *   9 = South wall (full apartment width at z=7.665)
         *
         * TOTAL: 10 walls (indices 0-9)
         */
        buildFloorPlan() {
          networkState.wallMeshes = [];
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;  // 4.6195
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;  // 3.8325
          const floorColor = 0xC9B89A;  // Warm beige (same as rooms)

          // Base floor covering entire apartment (fills all gaps)
          const baseFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(FLOOR_PLAN_CONFIG.apartmentWidth + 2, FLOOR_PLAN_CONFIG.apartmentDepth + 2),
            new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 })
          );
          baseFloor.rotation.x = -Math.PI / 2;
          baseFloor.position.set(0, 0.001, 0);  // Lowest level, centered
          baseFloor.receiveShadow = true;
          networkState.scene.add(baseFloor);

          // Build rooms (each room has its own floor and outer walls)
          // NOTE: This runs FIRST, creating walls 0-15
          FLOOR_PLAN_CONFIG.rooms.forEach(config => {
            this.createRoom(config);
          });

          // Interior divider walls (created AFTER room walls, so these are walls 16-17)
          const wallHeight = 0.8;
          const wallMat = new THREE.MeshStandardMaterial({ color: 0xB5A080, roughness: 0.7, transparent: true, opacity: 0.6 });

          // Get room references
          const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
          const living = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'living');
          const kitchen = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'kitchen');
          const bedroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bedroom');
          const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');

          // Wall 3: Study ‚Üî Living (horizontal divider wall with 2 door openings)
          // Moved 0.5m towards study (into study area)
          const studyFrontZ = study.z + study.depth/2 - 0.5;  // 3.197 (moved towards study)

          // Door openings (0.42m wide each - reduced 30%)
          const doorWidth = 0.42;
          const door4X = 3.8;  // Bedroom ‚Üî Hallway (west door)
          const door2X = 4.8;  // Living ‚Üî Hallway (east door)

          const door4Left = door4X - doorWidth/2;   // 3.2
          const door4Right = door4X + doorWidth/2;  // 3.8
          const door2Left = door2X - doorWidth/2;   // 4.5
          const door2Right = door2X + doorWidth/2;  // 5.1

          // Left segment: from west edge (0) to door4 left edge
          const wall3LeftWidth = door4Left;
          const wall3Left = new THREE.Mesh(new THREE.BoxGeometry(wall3LeftWidth, wallHeight, 0.08), wallMat);
          wall3Left.position.set(door4Left/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Left);
          networkState.wallMeshes.push(wall3Left);

          // Middle segment: from door4 right edge to door2 left edge
          const wall3MidWidth = door2Left - door4Right;  // 4.5 - 3.8 = 0.7
          const wall3Mid = new THREE.Mesh(new THREE.BoxGeometry(wall3MidWidth, wallHeight, 0.08), wallMat);
          wall3Mid.position.set(door4Right + wall3MidWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Mid);
          networkState.wallMeshes.push(wall3Mid);

          // Right segment: from door2 right edge to east edge
          const wall3RightWidth = FLOOR_PLAN_CONFIG.apartmentWidth - door2Right;
          const wall3Right = new THREE.Mesh(new THREE.BoxGeometry(wall3RightWidth, wallHeight, 0.08), wallMat);
          wall3Right.position.set(door2Right + wall3RightWidth/2 - centerX, wallHeight/2, studyFrontZ - centerZ);
          networkState.scene.add(wall3Right);
          networkState.wallMeshes.push(wall3Right);

          // Wall 2: Kitchen ‚Üî Bedroom - REMOVED (was wall index 17)
          // This interior divider was redundant - bedroom's back wall already defines the boundary

          // Wall 4: Coat hanging wall in hallway (30% from north towards Study‚ÜîLiving divider)
          const wall16Z = 0;  // North connector position
          const wall15Z = study.z + study.depth/2;  // 3.697 (Study‚ÜîLiving divider)
          const coatWallLength = (wall15Z - wall16Z) * 0.30;  // 30% of distance ‚âà 1.1m
          const coatWallCenterZ = wall16Z + coatWallLength / 2;  // Start from wall 16

          // Position towards study (middle of hallway-study boundary)
          const coatWallX = 4.6;  // Moved from hallway center (3.839) towards study

          const coatWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, coatWallLength), wallMat);
          coatWall.position.set(coatWallX - centerX, wallHeight/2, coatWallCenterZ - centerZ);
          networkState.scene.add(coatWall);
          networkState.wallMeshes.push(coatWall);

          // Wall 5: North wall (consolidated from Study back + connector + Bathroom back)
          // Split into 2 segments with main entry door at x=3.5
          const mainDoorX = 4.0;
          const mainDoorWidth = 0.42;
          const mainDoorLeft = mainDoorX - mainDoorWidth/2;  // 3.29
          const mainDoorRight = mainDoorX + mainDoorWidth/2;  // 3.71

          // Segment 1: x=0 to door left edge (west side)
          const northSeg1Width = mainDoorLeft;  // 3.29
          const northWall1 = new THREE.Mesh(new THREE.BoxGeometry(northSeg1Width, wallHeight, 0.08), wallMat);
          northWall1.position.set(northSeg1Width/2 - centerX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall1);
          networkState.wallMeshes.push(northWall1);

          // Segment 2: door right edge to apartment east edge (east side)
          const northSeg2Width = FLOOR_PLAN_CONFIG.apartmentWidth - mainDoorRight;  // 9.239 - 3.71 = 5.529
          const northSeg2CenterX = (mainDoorRight + FLOOR_PLAN_CONFIG.apartmentWidth) / 2 - centerX;
          const northWall2 = new THREE.Mesh(new THREE.BoxGeometry(northSeg2Width, wallHeight, 0.08), wallMat);
          northWall2.position.set(northSeg2CenterX, wallHeight/2, -centerZ);
          networkState.scene.add(northWall2);
          networkState.wallMeshes.push(northWall2);

          // Wall 7: West wall (FULL depth - balcony is on EAST side)
          const notch = FLOOR_PLAN_CONFIG.balconyNotch;
          const westWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, wallHeight, FLOOR_PLAN_CONFIG.apartmentDepth),
            wallMat
          );
          westWall.position.set(-centerX, wallHeight/2, 0);  // Centered in z (full depth)
          networkState.scene.add(westWall);
          networkState.wallMeshes.push(westWall);

          // Wall 10: East wall upper (Bathroom+Kitchen right consolidated)
          // Split into 3 segments with 2 door openings: bathroom (z=0.7) and kitchen (z=2.5)
          const wall10X = bathroom.x + bathroom.width/2;  // Right edge of bathroom/kitchen area (3.15)
          const wall10DoorWidth = 0.42;

          // Bathroom door at z=0.7
          const bathDoorZ = 0.7;
          const bathDoorTop = bathDoorZ - wall10DoorWidth/2;  // 0.49
          const bathDoorBottom = bathDoorZ + wall10DoorWidth/2;  // 0.91

          // Kitchen door at z=2.5
          const kitchenDoorZ = 2.5;
          const kitchenDoorTop = kitchenDoorZ - wall10DoorWidth/2;  // 2.29
          const kitchenDoorBottom = kitchenDoorZ + wall10DoorWidth/2;  // 2.71

          // Segment 1: z=0 to bathroom door top
          const wall10Seg1Depth = bathDoorTop;  // 0.49
          const eastWallUpper1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg1Depth), wallMat);
          eastWallUpper1.position.set(wall10X - centerX, wallHeight/2, wall10Seg1Depth/2 - centerZ);
          networkState.scene.add(eastWallUpper1);
          networkState.wallMeshes.push(eastWallUpper1);

          // Segment 2: bathroom door bottom to kitchen door top
          const wall10Seg2Depth = kitchenDoorTop - bathDoorBottom;  // 2.29 - 0.91 = 1.38
          const wall10Seg2CenterZ = (bathDoorBottom + kitchenDoorTop) / 2 - centerZ;
          const eastWallUpper2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg2Depth), wallMat);
          eastWallUpper2.position.set(wall10X - centerX, wallHeight/2, wall10Seg2CenterZ);
          networkState.scene.add(eastWallUpper2);
          networkState.wallMeshes.push(eastWallUpper2);

          // Segment 3: kitchen door bottom to studyFrontZ
          const wall10Seg3Depth = studyFrontZ - kitchenDoorBottom;  // 3.197 - 2.71 = 0.487
          const wall10Seg3CenterZ = (kitchenDoorBottom + studyFrontZ) / 2 - centerZ;
          const eastWallUpper3 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, wall10Seg3Depth), wallMat);
          eastWallUpper3.position.set(wall10X - centerX, wallHeight/2, wall10Seg3CenterZ);
          networkState.scene.add(eastWallUpper3);
          networkState.wallMeshes.push(eastWallUpper3);

          // Wall 9: East wall lower (Study+Living right - SHORTENED for balcony notch)
          // From z=0 to z=6.165 (stops before notch) at x = apartment east edge
          const wall9X = FLOOR_PLAN_CONFIG.apartmentWidth;  // 9.239 (east edge)
          const eastWallEndZ = FLOOR_PLAN_CONFIG.apartmentDepth - notch.depth;  // 7.665 - 1.5 = 6.165
          const eastWallCenterZ = eastWallEndZ / 2 - centerZ;  // Center of shortened wall
          const eastWallLower = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, eastWallEndZ), wallMat);
          eastWallLower.position.set(wall9X - centerX, wallHeight/2, eastWallCenterZ);
          networkState.scene.add(eastWallLower);
          networkState.wallMeshes.push(eastWallLower);

          // Wall 10: South wall (gap on EAST side for balcony notch)
          const southWallZ = FLOOR_PLAN_CONFIG.apartmentDepth;  // 7.665
          const southWallWidth = FLOOR_PLAN_CONFIG.apartmentWidth - notch.width;  // 9.239 - 1.5 = 7.739
          const southWallCenterX = southWallWidth / 2 - centerX;  // Gap on EAST side
          const southWall = new THREE.Mesh(
            new THREE.BoxGeometry(southWallWidth, wallHeight, 0.08),
            wallMat
          );
          southWall.position.set(southWallCenterX, wallHeight/2, southWallZ - centerZ);
          networkState.scene.add(southWall);
          networkState.wallMeshes.push(southWall);

          // ========== BALCONY AT SE CORNER, EXTENDS EAST ==========

          // Balcony positions
          const balconyOuterX = FLOOR_PLAN_CONFIG.apartmentWidth + notch.width;  // 9.239 + 1.5 = 10.739
          const balconyStartZ = FLOOR_PLAN_CONFIG.apartmentDepth - notch.depth;  // 6.165
          const notchFloorZ = (FLOOR_PLAN_CONFIG.apartmentDepth - notch.depth / 2) - centerZ;

          // Balcony floor - covers BOTH notch (inside) AND extension (outside east)
          const balconyFloorColor = 0xC0C0C2;  // Same as base floor
          const balconyFloorMat = new THREE.MeshStandardMaterial({
            color: balconyFloorColor,
            roughness: 0.8
          });

          // Notch floor (inside building) - from x=7.739 to x=9.239
          const notchFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(notch.width, notch.depth),
            balconyFloorMat
          );
          notchFloor.rotation.x = -Math.PI / 2;
          const notchFloorX = (FLOOR_PLAN_CONFIG.apartmentWidth - notch.width / 2) - centerX;
          notchFloor.position.set(notchFloorX, 0.01, notchFloorZ);
          networkState.scene.add(notchFloor);

          // Extension floor (outside building) - from x=9.239 to x=10.739
          const extFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(notch.width, notch.depth),
            balconyFloorMat
          );
          extFloor.rotation.x = -Math.PI / 2;
          const extFloorX = (FLOOR_PLAN_CONFIG.apartmentWidth + notch.width / 2) - centerX;
          extFloor.position.set(extFloorX, 0.01, notchFloorZ);
          networkState.scene.add(extFloor);

          // Wall 16: North balcony wall (along z = 6.165, extends EAST from notch to outer edge)
          const northBalconyWall = new THREE.Mesh(
            new THREE.BoxGeometry(notch.width * 2, wallHeight, 0.08),  // Double width to cover notch + extension
            wallMat
          );
          const wall16CenterX = FLOOR_PLAN_CONFIG.apartmentWidth - centerX;  // Centered at building edge
          northBalconyWall.position.set(wall16CenterX, wallHeight / 2, balconyStartZ - centerZ);
          networkState.scene.add(northBalconyWall);
          networkState.wallMeshes.push(northBalconyWall);

          // Wall 17: West notch wall (along x = 7.739, from z=6.165 to z=7.665)
          const vertStepWallX = (FLOOR_PLAN_CONFIG.apartmentWidth - notch.width) - centerX;
          const westNotchWall = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, wallHeight, notch.depth),
            wallMat
          );
          westNotchWall.position.set(vertStepWallX, wallHeight / 2, notchFloorZ);
          networkState.scene.add(westNotchWall);
          networkState.wallMeshes.push(westNotchWall);

          // Balcony railings (if enabled) - same color as walls
          if (notch.hasRailing) {
            const railingHeight = 0.5;  // Lower than walls
            const railingThickness = 0.05;
            const railingMat = new THREE.MeshStandardMaterial({
              color: 0xB5A080,  // Same as other walls
              roughness: 0.7,
              transparent: true,
              opacity: 0.6
            });

            // Wall 18: East railing (outer edge at x = 10.739)
            const eastRailing = new THREE.Mesh(
              new THREE.BoxGeometry(railingThickness, railingHeight, notch.depth),
              railingMat
            );
            eastRailing.position.set(balconyOuterX - centerX, railingHeight / 2, notchFloorZ);
            networkState.scene.add(eastRailing);
            networkState.wallMeshes.push(eastRailing);

            // Wall 19: South balcony wall (along z = 7.665, extends EAST across notch + extension)
            const southBalconyWall = new THREE.Mesh(
              new THREE.BoxGeometry(notch.width * 2, railingHeight, railingThickness),  // Double width
              railingMat
            );
            southBalconyWall.position.set(wall16CenterX, railingHeight / 2, southWallZ - centerZ);
            networkState.scene.add(southBalconyWall);
            networkState.wallMeshes.push(southBalconyWall);

            // Corner posts at outer edge
            const cornerPost1 = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, railingHeight, 8),
              railingMat
            );
            cornerPost1.position.set(balconyOuterX - centerX, railingHeight / 2, balconyStartZ - centerZ);
            networkState.scene.add(cornerPost1);

            const cornerPost2 = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, railingHeight, 8),
              railingMat
            );
            cornerPost2.position.set(balconyOuterX - centerX, railingHeight / 2, southWallZ - centerZ);
            networkState.scene.add(cornerPost2);
          }

          // Door X markers - adding from FLOOR_PLAN_CONFIG.doors
          const doorMarkerMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
          const markerSize = 0.3;
          const markerThickness = 0.05;
          const markerHeight = 0.02;

          // Helper function to add door marker
          const addDoorMarker = (x, z) => {
            const posX = x - centerX;
            const posZ = z - centerZ;

            // Bar 1 (diagonal \)
            const bar1 = new THREE.Mesh(
              new THREE.BoxGeometry(markerSize, markerHeight, markerThickness),
              doorMarkerMat
            );
            bar1.rotation.y = Math.PI / 4;
            bar1.position.set(posX, markerHeight/2, posZ);
            networkState.scene.add(bar1);

            // Bar 2 (diagonal /)
            const bar2 = new THREE.Mesh(
              new THREE.BoxGeometry(markerSize, markerHeight, markerThickness),
              doorMarkerMat
            );
            bar2.rotation.y = -Math.PI / 4;
            bar2.position.set(posX, markerHeight/2, posZ);
            networkState.scene.add(bar2);
          };

          // Door 2: Living ‚Üî Hallway - on Wall 3 (Study‚ÜîLiving divider at z=3.197)
          addDoorMarker(4.8, 3.197);

          // Door 3: Study door - on Wall 0 (study's left wall at x=5.331)
          addDoorMarker(5.331, 2.5);

          // Door 4: Bedroom ‚Üî Hallway - on Wall 3 (at x=3.8)
          addDoorMarker(3.8, 3.197);

          // Door 5: Kitchen door - on wall 10 (east wall upper at x=3.15)
          addDoorMarker(3.15, 2.5);

          // Door 6: Bathroom door - on wall 10 (east wall upper at x=3.15)
          addDoorMarker(3.15, 0.7);

          // Door 7: Main Entry - on north wall (z=0)
          addDoorMarker(4.0, 0);

          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          // WINDOW X MARKERS - Blue X on floor (like door markers but blue)
          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          const windowMarkerMat = new THREE.MeshBasicMaterial({ color: 0x0066FF });
          const winMarkerSize = 0.5;  // Larger than door markers

          const addWindowMarker = (x, z, index) => {
            // Offset x inside apartment for wall positions
            let actualX = x;
            if (x < 0.1) actualX = 0.5;  // West wall - offset 0.5m inside
            if (x > FLOOR_PLAN_CONFIG.apartmentWidth - 0.1) actualX = FLOOR_PLAN_CONFIG.apartmentWidth - 0.5;  // East wall

            const posX = actualX - centerX;
            const posZ = z - centerZ;

            // Bar 1 (diagonal \) - flat on floor
            const bar1 = new THREE.Mesh(
              new THREE.BoxGeometry(winMarkerSize, 0.05, 0.08),
              windowMarkerMat
            );
            bar1.rotation.y = Math.PI / 4;
            bar1.position.set(posX, 0.03, posZ);
            networkState.scene.add(bar1);

            // Bar 2 (diagonal /) - flat on floor
            const bar2 = new THREE.Mesh(
              new THREE.BoxGeometry(winMarkerSize, 0.05, 0.08),
              windowMarkerMat
            );
            bar2.rotation.y = -Math.PI / 4;
            bar2.position.set(posX, 0.03, posZ);
            networkState.scene.add(bar2);

            // Window number label (blue circle with W#)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0066FF';
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('W' + index, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const labelMat = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMat);
            label.scale.set(0.6, 0.6, 1);
            label.position.set(posX, 0.6, posZ);
            networkState.scene.add(label);
          };

          // Add window markers from config
          FLOOR_PLAN_CONFIG.windows.forEach((win, i) => {
            addWindowMarker(win.x, win.z, i + 1);
          });

          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          // COMPASS DIRECTION LABELS - N/S/E/W outside the building
          // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          const halfW = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const halfD = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const compassOffset = 1.0;  // Distance outside building

          const compassLabels = [
            { label: 'N', x: 0, z: -halfD - compassOffset, color: '#2563EB' },  // North (blue)
            { label: 'S', x: 0, z: halfD + compassOffset, color: '#DC2626' },   // South (red)
            { label: 'W', x: -halfW - compassOffset, z: 0, color: '#059669' },  // West (green)
            { label: 'E', x: halfW + compassOffset, z: 0, color: '#D97706' }    // East (orange)
          ];

          compassLabels.forEach(({ label, x, z, color }) => {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Circle background
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(32, 32, 28, 0, Math.PI * 2);
            ctx.fill();

            // White letter
            ctx.fillStyle = 'white';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.8, 0.8, 1);
            sprite.position.set(x, 0.5, z);
            networkState.scene.add(sprite);
          });
        },

        createRoom(config) {
          const group = new THREE.Group();
          const floorColor = 0xC9B89A;  // Warm beige
          const wallColor = 0xB5A080;
          const wallHeight = 0.8;

          // Correct center coordinates (x,z are already center positions)
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;
          const rx = config.x - centerX;
          const rz = config.z - centerZ;

          // Room floor at correct position
          const floorGeom = new THREE.PlaneGeometry(config.width, config.depth);
          const floorMat = new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.8 });
          const floor = new THREE.Mesh(floorGeom, floorMat);
          floor.rotation.x = -Math.PI / 2;
          floor.position.set(rx, 0.01, rz);
          floor.receiveShadow = true;
          group.add(floor);

          // Helipad-style room label on floor
          const helipadSize = Math.min(config.width, config.depth) * 0.6;
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');

          // Outer circle
          ctx.strokeStyle = 'rgba(90, 70, 50, 0.4)';
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.arc(128, 128, 110, 0, Math.PI * 2);
          ctx.stroke();

          // Inner circle
          ctx.strokeStyle = 'rgba(90, 70, 50, 0.3)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(128, 128, 85, 0, Math.PI * 2);
          ctx.stroke();

          // Room name text
          ctx.fillStyle = 'rgba(90, 70, 50, 0.5)';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(config.name.toUpperCase(), 128, 128);

          const helipadTexture = new THREE.CanvasTexture(canvas);
          const helipadGeom = new THREE.PlaneGeometry(helipadSize, helipadSize);
          const helipadMat = new THREE.MeshBasicMaterial({
            map: helipadTexture,
            transparent: true,
            depthWrite: false
          });
          const helipad = new THREE.Mesh(helipadGeom, helipadMat);
          helipad.rotation.x = -Math.PI / 2;
          helipad.position.set(rx, 0.02, rz);
          group.add(helipad);

          // Create all 4 walls automatically
          const halfW = config.width / 2;
          const halfD = config.depth / 2;
          const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.7, transparent: true, opacity: 0.6 });

          // Back wall (north) - skip for all rooms at z=0 edge (consolidated into single north wall)
          // Only bathroom has a front wall (interior divider at z=1.504)
          // Study, Living, Bedroom, Kitchen, Bathroom back walls are all consolidated
          if (false) {  // All back walls consolidated into single north wall
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
            backWall.position.set(rx, wallHeight/2, rz - halfD);
            group.add(backWall);
            networkState.wallMeshes.push(backWall);
          }

          // Front wall (south) - skip for study, kitchen, bedroom, living (consolidated into single south wall)
          if (config.id !== 'study' && config.id !== 'kitchen' && config.id !== 'bedroom' && config.id !== 'living') {
            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, 0.08), wallMat);
            frontWall.position.set(rx, wallHeight/2, rz + halfD);
            group.add(frontWall);
            networkState.wallMeshes.push(frontWall);
          }

          // Left wall (west) - skip for living room and west-edge rooms (single west wall created in buildFloorPlan)
          const roomAtWestEdge = ['bathroom', 'kitchen', 'bedroom'].includes(config.id);
          if (config.id !== 'living' && !roomAtWestEdge) {
            // For study, use studyFrontZ (3.197) to join Wall 3
            // Split into 2 segments with door opening at z=1.85
            if (config.id === 'study') {
              const studyObj = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
              const studyFrontZ = studyObj.z + studyObj.depth/2 - 0.5;  // 3.197 (joins Wall 3)
              const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

              // Door opening parameters
              const doorZ = 2.5;  // Door center position (towards living room)
              const doorWidth = 0.42;  // Same as other doors
              const doorTop = doorZ - doorWidth/2;  // 1.64
              const doorBottom = doorZ + doorWidth/2;  // 2.06

              // Segment 1: from z=0 to door top edge
              const seg1Depth = doorTop;  // 1.64
              const seg1CenterZ = seg1Depth/2 - centerZ;
              const leftWall1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, seg1Depth), wallMat);
              leftWall1.position.set(rx - halfW, wallHeight/2, seg1CenterZ);
              leftWall1.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall1);
              networkState.wallMeshes.push(leftWall1);

              // Segment 2: from door bottom edge to studyFrontZ
              const seg2Depth = studyFrontZ - doorBottom;  // 3.197 - 2.06 = 1.137
              const seg2CenterZ = (doorBottom + studyFrontZ)/2 - centerZ;
              const leftWall2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, seg2Depth), wallMat);
              leftWall2.position.set(rx - halfW, wallHeight/2, seg2CenterZ);
              leftWall2.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall2);
              networkState.wallMeshes.push(leftWall2);
            } else {
              const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
              leftWall.position.set(rx - halfW, wallHeight/2, rz);
              leftWall.userData = { roomId: config.id, side: 'left' };
              group.add(leftWall);
              networkState.wallMeshes.push(leftWall);
            }
          }

          // Right wall (east) - skip for rooms using consolidated east walls
          // Bathroom, Kitchen ‚Üí consolidated into east wall upper (Wall 8)
          // Study, Living ‚Üí consolidated into east wall lower (Wall 9)
          // Only Bedroom keeps its individual right wall (divider between bedroom and living)
          const roomsWithConsolidatedEastWall = ['bathroom', 'kitchen', 'study', 'living'];
          if (!roomsWithConsolidatedEastWall.includes(config.id)) {
            if (config.id === 'bedroom') {
              // Bedroom's right wall (Wall 1) serves as divider between bedroom and living
              // Extends from studyFrontZ (z=3.197) to south edge (z=7.665) - joins Wall 3
              const study = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'study');
              const wall15Z = study.z + study.depth/2 - 0.5;  // 3.197 (same as Wall 3, joins it)
              const bedroomFrontZ = config.z + config.depth/2;  // 7.665 (apartment south edge)
              const extendedDepth = bedroomFrontZ - wall15Z;  // 4.468 (extended to join Wall 3)
              const extendedCenterZ = (wall15Z + bedroomFrontZ) / 2 - FLOOR_PLAN_CONFIG.apartmentDepth / 2;

              // Position moved towards living room (increased x by 0.8m)
              const bathroom = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === 'bathroom');
              const wall7X = bathroom.x + bathroom.width/2 + 0.8 - FLOOR_PLAN_CONFIG.apartmentWidth / 2;

              const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, extendedDepth), wallMat);
              rightWall.position.set(wall7X, wallHeight/2, extendedCenterZ);
              group.add(rightWall);
              networkState.wallMeshes.push(rightWall);
            } else {
              // Default right wall for any other rooms
              const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, wallHeight, config.depth), wallMat);
              rightWall.position.set(rx + halfW, wallHeight/2, rz);
              group.add(rightWall);
              networkState.wallMeshes.push(rightWall);
            }
          }

          // Furniture
          this.createFurniture(group, config, rx, rz);

          networkState.scene.add(group);
          networkState.roomMeshes[config.id] = { group, floor, config };
        },

        createFurniture(group, config, rx, rz) {
          const furnitureColor = 0xBFA98A;
          const furnitureMat = new THREE.MeshStandardMaterial({ color: furnitureColor, roughness: 0.6 });

          if (config.id === 'bedroom') {
            // Bed
            const bedGeom = new THREE.BoxGeometry(1.4, 0.3, 2.0);
            const bed = new THREE.Mesh(bedGeom, furnitureMat);
            bed.position.set(rx - config.width/4, 0.15, rz);
            group.add(bed);
          } else if (config.id === 'living') {
            // Sofa
            const sofaGeom = new THREE.BoxGeometry(2.0, 0.4, 0.8);
            const sofa = new THREE.Mesh(sofaGeom, furnitureMat);
            sofa.position.set(rx, 0.2, rz + config.depth/4);
            group.add(sofa);
          } else if (config.id === 'study') {
            // Desk
            const deskGeom = new THREE.BoxGeometry(1.2, 0.5, 0.6);
            const desk = new THREE.Mesh(deskGeom, furnitureMat);
            desk.position.set(rx + config.width/4, 0.25, rz - config.depth/4);
            group.add(desk);
          }
        },

        createDevices() {
          networkState.deviceMeshes = {};
          const centerX = FLOOR_PLAN_CONFIG.apartmentWidth / 2;
          const centerZ = FLOOR_PLAN_CONFIG.apartmentDepth / 2;

          ZIGBEE_DEVICES.forEach(device => {
            // Create device marker (sphere)
            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            let color;
            switch (device.type) {
              case 'coordinator': color = 0xFF6B6B; break;
              case 'router': color = 0x4DABF7; break;
              default: color = 0x51CF66;
            }
            const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geometry, material);

            // Position based on room (room.x, room.z are center coords)
            const room = FLOOR_PLAN_CONFIG.rooms.find(r => r.id === device.room);
            if (room) {
              const roomCenterX = room.x - centerX;
              const roomCenterZ = room.z - centerZ;  // FIX: use z not y
              mesh.position.set(
                roomCenterX + (device.x - 0.5) * room.width * 0.8,
                0.5,
                roomCenterZ + (device.z - 0.5) * room.depth * 0.8
              );
            }

            mesh.castShadow = true;
            networkState.scene.add(mesh);
            networkState.deviceMeshes[device.id] = { mesh, config: device };
          });
        },

        createLabels(container) {
          // Clear existing labels
          Object.values(networkState.labelElements).forEach(el => el?.remove());
          Object.values(networkState.signalElements).forEach(el => el?.remove());
          networkState.labelElements = {};
          networkState.signalElements = {};

          ZIGBEE_DEVICES.forEach(device => {
            // Device label
            const label = document.createElement('div');
            label.className = 'device-label visible';
            label.innerHTML = `
              <div class="device-icon ${device.type}">${device.icon}</div>
              <div class="device-name">${device.name}</div>
            `;
            container.appendChild(label);
            networkState.labelElements[device.id] = label;

            // Signal range circle (for coordinator and routers)
            if (device.type === 'coordinator' || device.type === 'router') {
              const signal = document.createElement('div');
              signal.className = `signal-range ${device.type}`;
              signal.style.width = device.type === 'coordinator' ? '200px' : '150px';
              signal.style.height = device.type === 'coordinator' ? '200px' : '150px';
              container.appendChild(signal);
              networkState.signalElements[device.id] = signal;
            }
          });
        },

        updateLabels() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;

          ZIGBEE_DEVICES.forEach(device => {
            const deviceData = networkState.deviceMeshes[device.id];
            const label = networkState.labelElements[device.id];
            const signal = networkState.signalElements[device.id];

            if (!deviceData || !label) return;

            const pos = deviceData.mesh.position.clone();
            pos.y += 0.3;
            pos.project(networkState.camera);

            const x = (pos.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-pos.y * 0.5 + 0.5) * container.clientHeight;

            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.style.display = this.showLabels ? 'flex' : 'none';

            if (signal) {
              signal.style.left = x + 'px';
              signal.style.top = (y + 40) + 'px';
              signal.style.display = this.showSignalRange ? 'block' : 'none';
            }
          });
        },

        setupPanControls(container) {
          container.addEventListener('pointerdown', (e) => {
            if (this.autoRotate) return;
            networkState.isPanning = true;
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
            container.style.cursor = 'grabbing';
          });

          container.addEventListener('pointermove', (e) => {
            if (!networkState.isPanning) return;
            const dx = e.clientX - networkState.lastPanPos.x;
            const dy = e.clientY - networkState.lastPanPos.y;
            networkState.panOffset.x -= dx * 0.02;
            networkState.panOffset.z -= dy * 0.02;
            networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            networkState.lastPanPos = { x: e.clientX, y: e.clientY };
          });

          container.addEventListener('pointerup', () => {
            networkState.isPanning = false;
            container.style.cursor = 'grab';
          });

          container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.setZoom(this.zoomLevel * delta);
          }, { passive: false });
        },

        setZoom(level) {
          this.zoomLevel = Math.max(0.5, Math.min(3.0, level));
          this.updateCameraZoom();
        },

        updateCameraZoom() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
        },

        zoomIn() { this.setZoom(this.zoomLevel * 1.2); },
        zoomOut() { this.setZoom(this.zoomLevel / 1.2); },

        resetView() {
          this.zoomLevel = 1.0;
          this.autoRotate = false;
          this.rotationAngle = Math.PI / 4;
          networkState.panOffset = { x: 0, z: 0 };
          networkState.camera.position.set(10, 10, 10);
          networkState.camera.lookAt(0, 0, 0);
          this.updateCameraZoom();
        },

        toggleAutoRotate() {
          this.autoRotate = !this.autoRotate;
          if (this.autoRotate) {
            const pos = networkState.camera.position;
            this.rotationAngle = Math.atan2(pos.x, pos.z);
          }
        },

        animate() {
          const self = this;
          const radius = 17.32;
          const height = 10;

          function loop() {
            networkState.animationId = requestAnimationFrame(loop);

            if (self.autoRotate && networkState.camera) {
              self.rotationAngle += 0.003;
              const x = Math.sin(self.rotationAngle) * radius;
              const z = Math.cos(self.rotationAngle) * radius;
              networkState.camera.position.set(x, height, z);
              networkState.camera.lookAt(networkState.panOffset.x, 0, networkState.panOffset.z);
            }

            self.updateLabels();
            if (networkState.renderer && networkState.scene && networkState.camera) {
              networkState.renderer.render(networkState.scene, networkState.camera);
            }
          }
          loop();
        },

        onResize() {
          const container = this.$refs.networkContainer;
          if (!container || !networkState.camera || !networkState.renderer) return;
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 15 / this.zoomLevel;
          networkState.camera.left = frustumSize * aspect / -2;
          networkState.camera.right = frustumSize * aspect / 2;
          networkState.camera.top = frustumSize / 2;
          networkState.camera.bottom = frustumSize / -2;
          networkState.camera.updateProjectionMatrix();
          networkState.renderer.setSize(container.clientWidth, container.clientHeight);
        },

        getZoomPercent() { return Math.round(this.zoomLevel * 100); }
      };
    }

    // ========================================
    // LOGS VIEW
    // ========================================
    function logsView() {
      return {
        showFilters: true,
        showStats: true,
        searchQuery: '',
        searchDebounce: null,
        visibleCount: 100,
        loadMoreStep: 100,

        init() {
          this.$store.logs?.init?.();
        },

        get logs() {
          return this.$store.logs.filteredLogs.slice(0, this.visibleCount);
        },

        get totalLogs() {
          return this.$store.logs.filteredLogs.length;
        },

        get hasMore() {
          return this.visibleCount < this.totalLogs;
        },

        get stats() {
          return this.$store.logs.stats;
        },

        get categories() {
          return this.$store.logs.categories;
        },

        get availableDevices() {
          return this.$store.logs.availableDevices;
        },

        get isPaused() {
          return this.$store.logs.paused;
        },

        get isLoading() {
          return this.$store.logs.loading;
        },

        get filters() {
          return this.$store.logs.filters;
        },

        get timeRange() {
          return this.$store.logs.filters.timeRange;
        },

        loadMore() {
          this.visibleCount += this.loadMoreStep;
        },

        togglePause() {
          this.$store.logs.togglePause();
        },

        clearLogs() {
          if (confirm('Clear all logs? This cannot be undone.')) {
            this.$store.logs.clearLogs();
          }
        },

        setTimeRange(range) {
          this.$store.logs.setTimeRange(range);
        },

        toggleCategory(category) {
          this.$store.logs.toggleCategory(category);
        },

        toggleSeverity(severity) {
          this.$store.logs.toggleSeverity(severity);
        },

        toggleAnomaliesOnly() {
          this.$store.logs.filters.anomaliesOnly = !this.$store.logs.filters.anomaliesOnly;
        },

        setDevice(device) {
          this.$store.logs.filters.devices = device ? [device] : [];
        },

        clearFilters() {
          this.$store.logs.clearFilters();
          this.searchQuery = '';
        },

        onSearchInput() {
          clearTimeout(this.searchDebounce);
          this.searchDebounce = setTimeout(() => {
            this.$store.logs.setSearch(this.searchQuery);
          }, 300);
        },

        expandLog(id) {
          this.$store.logs.expandLog(id);
        },

        isExpanded(id) {
          return this.$store.logs.expandedLogId === id;
        },

        copyPayload(log) {
          const text = JSON.stringify(log.payload, null, 2);
          navigator.clipboard.writeText(text).then(() => {
            console.log('Copied payload to clipboard');
          });
        },

        getCategoryInfo(category) {
          return this.categories[category] || { icon: 'üìã', label: category, color: '#6b7280' };
        },

        formatTime(timestamp) {
          return this.$store.logs.formatTime(timestamp);
        },

        formatRelativeTime(timestamp) {
          return this.$store.logs.formatRelativeTime(timestamp);
        },

        formatValues(values) {
          return this.$store.logs.formatValues(values);
        },

        getSeverityColor(severity) {
          return this.$store.logs.getSeverityColor(severity);
        },

        getSeverityBadge(severity) {
          const badges = {
            error: { icon: 'üî¥', label: 'Error' },
            warning: { icon: 'üü†', label: 'Warning' },
            info: { icon: 'üîµ', label: 'Info' },
            success: { icon: 'üü¢', label: 'Success' }
          };
          return badges[severity] || badges.info;
        },

        formatPayload(payload) {
          if (!payload) return 'No payload';
          return JSON.stringify(payload, null, 2);
        },

        isCategoryActive(category) {
          return this.filters.categories.length === 0 || this.filters.categories.includes(category);
        },

        isSeverityActive(severity) {
          return this.filters.severities.length === 0 || this.filters.severities.includes(severity);
        },

        applyPreset(preset) {
          this.clearFilters();
          switch (preset) {
            case 'errors': this.$store.logs.filters.severities = ['error']; break;
            case 'warnings': this.$store.logs.filters.severities = ['error', 'warning']; break;
            case 'doors': this.$store.logs.filters.categories = ['contact']; break;
            case 'heating': this.$store.logs.filters.categories = ['thermostat']; break;
            case 'lights': this.$store.logs.filters.categories = ['light', 'plug']; break;
            case 'anomalies': this.$store.logs.filters.anomaliesOnly = true; break;
          }
        },

        getCategoryPercentage(category) {
          const total = this.stats.total || 1;
          const count = this.stats.byCategory[category] || 0;
          return Math.round((count / total) * 100);
        },

        getHourlySparkline() {
          const buckets = this.stats.hourlyBuckets || [];
          const max = Math.max(...buckets, 1);
          return buckets.map(v => Math.round((v / max) * 100));
        }
      };
    }
  </script>

  <!-- Theme Store - MUST load before Alpine processes elements -->
  <script type="module">
    import { initThemeStore } from './js/stores/theme-store.js';

    // Register theme store when Alpine initializes
    document.addEventListener('alpine:init', () => {
      initThemeStore(Alpine);
      console.log('[theme-store] Theme store registered');
    });
  </script>

  <!-- Alpine.js - MUST load last after all stores and views are defined -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</body>
</html>
